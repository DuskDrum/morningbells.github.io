<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MorningBells</title>
  
  
  <link href="https://morningbells.github.io/atom.xml" rel="self"/>
  
  <link href="https://morningbells.github.io/"/>
  <updated>2021-11-17T08:33:43.275Z</updated>
  <id>https://morningbells.github.io/</id>
  
  <author>
    <name>MorningBells</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring与Web</title>
    <link href="https://morningbells.github.io/2021/11/17/spring%E4%B8%8EWeb/"/>
    <id>https://morningbells.github.io/2021/11/17/spring%E4%B8%8EWeb/</id>
    <published>2021-11-17T08:32:43.000Z</published>
    <updated>2021-11-17T08:33:43.275Z</updated>
    
    <content type="html"><![CDATA[<p>spring与Web快速回顾</p><span id="more"></span><h3 id="Spring与Web与后端"><a href="#Spring与Web与后端" class="headerlink" title="Spring与Web与后端"></a>Spring与Web与后端</h3><h4 id="SpringMvc"><a href="#SpringMvc" class="headerlink" title="SpringMvc"></a>SpringMvc</h4><p>Spring将请求在调度Servlet、处理器映射(handler mapping)、控制器以及视图解析器(view resolver)之间移动</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211111175416774.png" alt="image-20211111175416774"></p><h4 id="怎么快速通过拓展AbstractAnnotationConfigDispatcherServletInitializer搭建spring-mvc"><a href="#怎么快速通过拓展AbstractAnnotationConfigDispatcherServletInitializer搭建spring-mvc" class="headerlink" title="怎么快速通过拓展AbstractAnnotationConfigDispatcherServletInitializer搭建spring-mvc"></a>怎么快速通过拓展AbstractAnnotationConfigDispatcherServletInitializer搭建spring-mvc</h4><ul><li><p>AbstractAnnotationConfigDispatcherServletInitializer：此类的任意拓展类都会自动地配置DispatcherServlet和Spring应用上下文，Spring的应用上下文会位于应用程序的Servlet上下文之中。</p><ul><li>DispatcherServlet: 此类启动时，会创建Spring应用上下文， 并加载配置文件或配置类中所声明的bean</li><li>ContextLoaderListener：创建另外一个应用上下文</li><li>DispatcherServlet和ContextLoaderListener的区别：DispatcherServlet加载包含Web组件的bean(控制器、视图解析器、处理器映射)，而ContextLoaderListener要加载应用中的其他(驱动应用后端的中间层、数据层组件)bean。AbstractAnnotationConfigDispatcherServletInitializer会同时创建他们</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">    <span class="comment">// 定义拦截器 ContextLoaderListener 应用上下文中的 beans</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class[] &#123; RootConfig.class &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">    <span class="comment">// 定义 DispatcherServlet 应用上下文中的 beans;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Class[] &#123; WebMvcConfig.class &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123; <span class="keyword">new</span> DelegatingFilterProxy(<span class="string">&quot;csrfFilter&quot;</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SpringServletContainerInitializer: 这个类会查找实现WebApplicationInitializer的类并将配置的任务交给它们完成</p></li><li><p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf">CSRF</a>：跨站请求伪造，会有一些不法的方法通过伪装发送错误的页面请求。可以通过 <strong>同步器令牌模式</strong>和<strong>相同站点属性</strong>预防此攻击，对应可以用到CsrfFilter、HttpSessionCsrfTokenRepository、CsrfRequestDataValueProcessor，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSRF protection. Here we only include the CsrfFilter instead of all of Spring Security.</span></span><br><span class="line"><span class="comment">// See https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf</span></span><br><span class="line"><span class="comment">// for more information on Spring Security&#x27;s CSRF protection</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CsrfFilter <span class="title">csrfFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CsrfFilter(<span class="keyword">new</span> HttpSessionCsrfTokenRepository());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provides automatic CSRF token inclusion when using Spring MVC Form tags or Thymeleaf.</span></span><br><span class="line"><span class="comment">// See http://localhost:8080/#forms and form.jsp for examples</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestDataValueProcessor <span class="title">requestDataValueProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CsrfRequestDataValueProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个最小可用的SpringMvc启动类包含几个方面的内容</p><ul><li>@EnableWebMvc：用来启动Spring MVC</li><li>@ComponentScan：用来组件扫描</li><li>配置视图解析器</li><li>配置资源处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.springframework.samples.mvc&quot;)</span> <span class="comment">// 代码扫描</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 启动springMvc</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">registry.addFormatterForFieldAnnotation(<span class="keyword">new</span> MaskFormatAnnotationFormatterFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">resolvers.add(<span class="keyword">new</span> CustomArgumentResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle HTTP GET requests for /resources/** by efficiently serving</span></span><br><span class="line"><span class="comment">// static resources under $&#123;webappRoot&#125;/resources/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>).addResourceLocations(<span class="string">&quot;/resources/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>, <span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">UrlPathHelper pathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">pathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>); <span class="comment">// For @MatrixVariable&#x27;s</span></span><br><span class="line">configurer.setUrlPathHelper(pathHelper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line">configurer.setDefaultTimeout(<span class="number">3000</span>);</span><br><span class="line">configurer.registerCallableInterceptors(<span class="keyword">new</span> TimeoutCallableProcessingInterceptor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="怎么拓展spring-mvc的配置"><a href="#怎么拓展spring-mvc的配置" class="headerlink" title="怎么拓展spring-mvc的配置"></a>怎么拓展spring-mvc的配置</h4><h5 id="自定义DispatcherServlet配置"><a href="#自定义DispatcherServlet配置" class="headerlink" title="自定义DispatcherServlet配置"></a>自定义<strong>DispatcherServlet</strong>配置</h5><ul><li>重载customizeRegistration方法</li></ul><h5 id="添加其他的Servlet和Filter"><a href="#添加其他的Servlet和Filter" class="headerlink" title="添加其他的Servlet和Filter"></a>添加其他的<strong>Servlet</strong>和<strong>Filter</strong></h5><p>如果除了DispatcherServlet和ContextLoaderListener以外，还想创建其他的应用上下文。</p><ul><li>实现WebApplicationInitializer接口，并创建注册一个新的Servlet</li></ul></li></ul><h4 id="处理multipart形式的数据"><a href="#处理multipart形式的数据" class="headerlink" title="处理multipart形式的数据"></a>处理<strong>multipart</strong>形式的数据</h4><p>multipart文件用来支持上传照片和视频功能</p><ul><li>我们必须要配置一个 multipart解析器，并配置在DispatcherServlet中，告诉它该如何读取multipart请求。</li><li>multipart解析器可以通过实现此接口MultipartResolver获得</li><li>Spring内置了两个MultipartResolver：<ul><li>CommonsMultipartResolver:使用Jakarta Commons FileUpload解析multipart请求;</li><li>StandardServletMultipartResolver:依赖于Servlet 3.0对 multipart请求的支持(始于Spring 3.1)。</li></ul></li><li>配置文件最大大小</li></ul><h4 id="控制器通知ControllerAdvice"><a href="#控制器通知ControllerAdvice" class="headerlink" title="控制器通知ControllerAdvice"></a>控制器通知ControllerAdvice</h4><ul><li>控制器通知：@ControllerAdvice<ul><li>@ExceptionHandler</li><li>@InitBinder</li><li>@ModelAttribute</li></ul></li></ul><h4 id="跨定向"><a href="#跨定向" class="headerlink" title="跨定向"></a>跨定向</h4><ul><li>redirect</li></ul><h3 id="Spring-Web-Flow"><a href="#Spring-Web-Flow" class="headerlink" title="Spring Web Flow"></a>Spring Web Flow</h3><p>Spring Web Flow是Spring MVC的扩展，它支持开发基于流程的应用程序。它将流程的定义与实现流程行为的类和视图分离开来。</p><ul><li>Spring Web Flow是基于Spring MVC的，所以所有流程都需要首先经过DispatcherServlet</li></ul><h4 id="swf的配置流程"><a href="#swf的配置流程" class="headerlink" title="swf的配置流程"></a>swf的配置流程</h4><h5 id="第一步装配流程执行器"><a href="#第一步装配流程执行器" class="headerlink" title="第一步装配流程执行器"></a>第一步装配流程执行器</h5><p>在Spring中，<a href="flow:flow-executor">flow:flow-executor</a>元素会创建一个流程执行器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">flow:flow-executor</span> <span class="attr">id</span>=<span class="string">&quot;flowExecutor&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第二步配置流程注册表"><a href="#第二步配置流程注册表" class="headerlink" title="第二步配置流程注册表"></a>第二步配置流程注册表</h5><p>流程注册表(flow registry)的工作是加载流程定义并让流程执行器能够使用它们</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">flow:flow-registry</span> <span class="attr">id</span>=<span class="string">&quot;flowRegistry&quot;</span> <span class="attr">base-path</span>=<span class="string">&quot;/WEB-INF/flows&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">flow:flow-location-pattern</span> <span class="attr">value</span>=<span class="string">&quot;*-flow.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow:flow-registry</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第三步处理流程请求"><a href="#第三步处理流程请求" class="headerlink" title="第三步处理流程请求"></a>第三步处理流程请求</h5><p>对于流程而言，我们需要一个FlowHandlerMapping来 帮助DispatcherServlet将流程请求发送给Spring Web Flow。在 Spring应用上下文中，FlowHandlerMapping的配置如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.webflow.mvc.servlet.FlowHandlerMapping&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;flowRegistry&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;flowRegistry&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="流程的组件"><a href="#流程的组件" class="headerlink" title="流程的组件"></a>流程的组件</h4><p>在Spring Web Flow中，流程是由三个主要元素定义的:状态、转移和 流程数据。</p><ul><li><p>状态(State)是流程中事件发生的地点</p><p>行为(Action)：行为状态是流程逻辑发生的地方</p><p>决策 (Decision)：决策状态将流程分成两个方向，它会基于流程数据的评估结果确定流程方向</p><p>结束(End)：结束状态是流程的最后一站。一旦进入End状态，流程就会终止</p><p>子流程 (Subflow)：子流程状态会在当前正在运行的流程上下文中启动一个新的流程</p><p>视图(View)：视图状态会暂停流程并邀请用户参与流程</p></li><li><p>转移(transition)就 是连接这些点的公路。在流程中，你通过转移的方式从一个状态到另 一个状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">to</span>=<span class="string">&quot;customerReady&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>流程数据</p></li></ul><h4 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h4><h5 id="Spring-Security被分为11个模块"><a href="#Spring-Security被分为11个模块" class="headerlink" title="Spring Security被分为11个模块"></a>Spring Security被分为11个模块</h5><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>ACL</td><td>支持通过访问控制列表(access control list，ACL)为域对象提 供安全性</td></tr><tr><td>切面(Aspects)</td><td>一个很小的模块，当使用Spring Security注解时，会使用基于 AspectJ的切面，而不是使用标准的Spring AOP</td></tr><tr><td>CAS客户端 (CAS Client)</td><td>提供与Jasig的中心认证服务(Central Authentication Service， CAS)进行集成的功能</td></tr><tr><td>配置 (Configuration)</td><td>包含通过XML和Java配置Spring Security的功能支持</td></tr><tr><td>核心(Core)</td><td>提供Spring Security基本库</td></tr><tr><td>加密 (Cryptography)</td><td><code>提供了加密和密码编码的功能 </code></td></tr><tr><td>LDAP</td><td>支持基于LDAP进行认证</td></tr><tr><td>OpenID</td><td>支持使用OpenID进行集中式认证</td></tr><tr><td>Remoting</td><td>提供了对Spring Remoting的支持</td></tr><tr><td>标签库(Tag Library)</td><td>Spring Security的JSP标签库</td></tr><tr><td>Web</td><td>提供了Spring Security基于Filter的Web安全性支持</td></tr></tbody></table><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>Spring Security借助一系列Servlet Filter来提供各种安全性功能。</p><p>但是不需要配置N多个过滤器，使用过滤器链springSecurityFilterChain。</p><h4 id="编写简单的Security项目"><a href="#编写简单的Security项目" class="headerlink" title="编写简单的Security项目"></a>编写简单的Security项目</h4><ol><li>必须创建一个实现了WebSecurityConfigurer接口(或者拓展了WebSecurityConfigurerAdapter)的Bean</li><li>引入@EnableWebSecurity注解将会启用Web安全功能</li><li>配置了@AuthenticationPrincipal的参数就会被Spring-Security认为是principal或者username</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;spring与Web快速回顾&lt;/p&gt;</summary>
    
    
    
    <category term="框架整理" scheme="https://morningbells.github.io/categories/%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/"/>
    
    
    <category term="spring-mvc" scheme="https://morningbells.github.io/tags/spring-mvc/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心</title>
    <link href="https://morningbells.github.io/2021/11/10/Spring%E6%A0%B8%E5%BF%83/"/>
    <id>https://morningbells.github.io/2021/11/10/Spring%E6%A0%B8%E5%BF%83/</id>
    <published>2021-11-10T13:59:29.000Z</published>
    <updated>2021-11-17T08:31:07.691Z</updated>
    
    <content type="html"><![CDATA[<p>Spring相关知识总结</p><span id="more"></span><h3 id="Spring核心"><a href="#Spring核心" class="headerlink" title="Spring核心"></a>Spring核心</h3><p>spring有丰富的功能，不过这些功能都依赖于两个核心特性。依赖注入DI和面向切面AOP。</p><p>spring可以有如此高的成就，归根结底是它最根本的使命: 简化java的开发，spring有四个关键策略</p><ul><li>基于POJO的轻量级和最小侵入性编程;</li><li>通过依赖注入和面向接又实现松耦合;</li><li>基于切面和惯例进行声明式编程;</li><li>通过切面和模板减少样板式代码。</li></ul><h4 id="依赖注入DI"><a href="#依赖注入DI" class="headerlink" title="依赖注入DI"></a>依赖注入DI</h4><h4 id="应用切面"><a href="#应用切面" class="headerlink" title="应用切面"></a>应用切面</h4><h4 id="Spring容器"><a href="#Spring容器" class="headerlink" title="Spring容器"></a>Spring容器</h4><p>spring应用中，bean对象生存于Spring容器中，容器负责对象的创建、装配、整个生命周期的管理。</p><p>容器中使用DI来管理各个应用组件。</p><p>Spring容器分成两大类：beanFactory和ApplicationContext</p><ul><li>BeanFactory：最简单的容器，提供最基础的DI</li><li>ApplicationContext：由BeanFactory构建，提供额外的功能<ul><li>AnnotationConfigApplicationContext从一个或多个基于Java的配置类中加载Spring应用上下文。</li><li>AnnotationConfigWebApplicationContext从一个或多个基于Java的配置类中加载Spring Web应用上下文。</li><li>ClassPathXmlApplicationContext 从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li><li>FileSystemXmlapplicationcontext 从文件系统下的一个或多个XML配置文件中加载上下文定义。 XmlWebApplicationContext从Web应用下的一个或多个XML配置文件中加载上下文定义。</li></ul></li></ul><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>Spring容器中的bean生命周期比较复杂</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211110114238947.png" alt="image-20211110114238947"></p><h4 id="Spring-核心模块"><a href="#Spring-核心模块" class="headerlink" title="Spring 核心模块"></a>Spring 核心模块</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211110114336961.png" alt="image-20211110114336961"></p><h5 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><strong>Instrumentation</strong></h5><p>Spring的Instrumentation模块提供了为JVM添加代理(agent)的功能。 具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文 件，就像这些文件是被类加载器加载的一样。</p><h4 id="Spring-Protfolio"><a href="#Spring-Protfolio" class="headerlink" title="Spring Protfolio"></a>Spring Protfolio</h4><ul><li><strong>Spring Web Flow</strong>：<a href="http://projects.spring.io/spring-webflow/">建立于Spring MVC框架之上，它为基于流程的会话式 Web应用(可以想一下购物车或者向导功能)提供了支持</a></li><li><strong>Spring Web Service</strong>：[将Spring bean以声明的方式发布为Web Service的功能](<a href="http://docs.spring.io/spring-">http://docs.spring.io/spring-</a> ws/site/)</li><li><strong>Spring Security</strong>：<a href="http://projects.spring.io/spring-security/">利用Spring AOP，Spring Security为Spring应用提供了声明式的安全机制</a></li><li><strong>Spring Integration</strong>：<a href="http://projects.spring.io/spring-integration/">提供了多种通用应用集成模式的Spring声明式风格实现</a></li><li><strong>Spring Batch</strong>：[需要对数据进行大量操作时，没有任何技术可以比批处理更胜 任这种场景](<a href="http://projects.spring.io/">http://projects.spring.io/</a> spring-batch/)</li><li><strong>Spring Data</strong>：Spring Data使得在Spring中使用任何数据库都变得非常容易</li><li><strong>Spring Social</strong>：社交网络是互联网领域中新兴的一种潮流，可以了 解一下Spring Social，这是Spring的一个社交网络扩展模块。<ul><li>查看网址 <a href="https://spring.io/guides/gs/accessing-facebook/%E5%B8%AE%E5%8A%A9%E4%BD%A0%E8%BF%9E%E6%8E%A5Facebook">https://spring.io/guides/gs/accessing-facebook/帮助你连接Facebook</a></li><li>查看网站 <a href="https://spring.io/guides/gs/accessing-twitter/%E5%B8%AE%E5%8A%A9%E4%BD%A0%E8%BF%9E%E6%8E%A5Twitter">https://spring.io/guides/gs/accessing-twitter/帮助你连接Twitter</a></li></ul></li><li><strong>Spring Mobile</strong>：Spring Mobile是Spring MVC新的扩展模 块，用于支持移动Web应用开发</li><li><strong>Spring for Android</strong>：<a href="http://projects.spring.io/spring-android/">与Spring Mobile相关</a></li><li><strong>Spring Boot</strong>：致力于简化Spring本身</li></ul><h4 id="Spring的Bean配置方案"><a href="#Spring的Bean配置方案" class="headerlink" title="Spring的Bean配置方案"></a>Spring的Bean配置方案</h4><ul><li>在XML中进行显式配置。</li><li>在Java中进行显式配置。</li><li>隐式的bean发现机制和自动装配。</li></ul><p>在注入中使用@Import和@ImportResource拆分配置</p><h4 id="Profile-bean"><a href="#Profile-bean" class="headerlink" title="Profile bean"></a>Profile bean</h4><ul><li>使用@Profile指定某个bean属于哪个Profile</li><li>使用@ActiveProfiles，指定集成测试的环境</li><li>spring.profiles.default：指定默认使用的环境</li><li>Spring.profiles.active：比spring.profiles.default的权重更高</li></ul><h4 id="条件化的Bean"><a href="#条件化的Bean" class="headerlink" title="条件化的Bean"></a>条件化的Bean</h4><p>有一些条件化的场景，比如说希望某个Bean当另外特定的Bean声明后才会创建。或者只有某个配置是具体的值时，才会创建某个Bean。</p><p>Spring提供了@Conditional注解，可以用在带有@Bean注解的方法上。如果给定的条件计算结果为true，才会进行bean创建</p><p>对应会有@Conditional注解，比如说@ConditionalOnBean、@ConditionalOnClass等，这些注解的实现结构相似，不过会有不同的计算条件、匹配逻辑。</p><p>所有的具体匹配逻辑实现了Condition函数式接口，此接口只有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext var1, AnnotatedTypeMetadata var2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中ConditionContext也是个接口，其中定义了几个方法用来检查一些信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的BeanDefinitionRegistry可以检查BeanDefinition</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ConfigurableListableBeanFactory可以检查bean是否存在, 也可以探查bean的属性</span></span><br><span class="line">    <span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Environment检查环境变量是否存在,以及它的值是什么;</span></span><br><span class="line">    <span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ResourceLoader可以读取并探查所加载的资源;</span></span><br><span class="line">    <span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ClassLoader加载并检查类是否存在。</span></span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中AnnotatedTypeMetadata也是一个接口，可以用来检查带有@Bean注解的方法上还有什么其他的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查询注解</span></span><br><span class="line">    <span class="function">MergedAnnotations <span class="title">getAnnotations</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 判断带有@Bean注解的方法是不是还有其他特定的注解。借助其他的那些方法，我们能够检查@Bean注解的方法上其他注解的属性。</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAnnotated</span><span class="params">(String annotationName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAnnotations().isPresent(annotationName);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAnnotationAttributes(annotationName, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span> </span>&#123;</span><br><span class="line">        MergedAnnotation&lt;Annotation&gt; annotation = <span class="keyword">this</span>.getAnnotations().get(annotationName, (Predicate)<span class="keyword">null</span>, MergedAnnotationSelectors.firstDirectlyDeclared());</span><br><span class="line">        <span class="keyword">return</span> !annotation.isPresent() ? <span class="keyword">null</span> : annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAllAnnotationAttributes(annotationName, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span> </span>&#123;</span><br><span class="line">        Adapt[] adaptations = Adapt.values(classValuesAsString, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (MultiValueMap)<span class="keyword">this</span>.getAnnotations().stream(annotationName).filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toMultiValueMap((map) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> map.isEmpty() ? <span class="keyword">null</span> : map;</span><br><span class="line">        &#125;, adaptations));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SPEL语法"><a href="#SPEL语法" class="headerlink" title="SPEL语法"></a>SPEL语法</h4><h4 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring相关知识总结&lt;/p&gt;</summary>
    
    
    
    <category term="技术书籍摘录" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    <category term="框架设计" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Spring" scheme="https://morningbells.github.io/tags/Spring/"/>
    
    <category term="《Spring实战》" scheme="https://morningbells.github.io/tags/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>maven总结</title>
    <link href="https://morningbells.github.io/2021/11/10/maven%E6%80%BB%E7%BB%93/"/>
    <id>https://morningbells.github.io/2021/11/10/maven%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-10T02:20:26.000Z</published>
    <updated>2021-11-17T08:31:07.693Z</updated>
    
    <content type="html"><![CDATA[<p>maven相关知识总结</p><span id="more"></span><h3 id="Maven总结"><a href="#Maven总结" class="headerlink" title="Maven总结"></a>Maven总结</h3><h4 id="maven概念模型"><a href="#maven概念模型" class="headerlink" title="maven概念模型"></a>maven概念模型</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211103224429410.png" alt="image-20211103224429410"></p><h4 id="maven的生命周期"><a href="#maven的生命周期" class="headerlink" title="maven的生命周期"></a>maven的生命周期</h4><p>maven有三套生命周期，分别是clean(清理项目)、default(项目构建)、site(生成项目站点)。三个大的生命周期蕴含着其他小的阶段</p><p>maven本身是只规定这些阶段，不会实际实现细节，具体实现会交给插件完成。</p><h5 id="clean周期"><a href="#clean周期" class="headerlink" title="clean周期"></a>clean周期</h5><ul><li>pre-clean:准备清理，执行清理前需要完成的工作</li><li>clean:真正的清理工作，清理上一次构建过程生成的文件，比如编译后的class文件等</li><li>post-clean:执行清理后的一些后续工作</li></ul><h5 id="default-周期"><a href="#default-周期" class="headerlink" title="default 周期"></a><strong>default</strong> <strong>周期</strong></h5><ul><li>validate:验证，验证项目结构是否正常，校验必要的配置文件是否存在</li><li>initialize:初始化配置，比如初始化参数、创建必要的目录等</li><li>generate-sources:生成源代码编译目录 ，产生在编译过程中需要的源代码</li><li>process-sources:处理项目源代码，比如过滤值</li><li>generate-resources:生成资源目录，在classpath包下</li><li>process-resources:处理资源文件，将资源文件复制到classpath的对应包中</li><li>complie:编译源代码</li><li>process-classes:处理编译后文件</li><li>generate-test-sources:生成测试目录</li><li>process-test-sources:处理项目测试资源文件，复制测试资源文件到 outputclasspath</li><li>generate-test-resources:生成测试资源文件</li><li>process-test-resources:处理测试资源文件</li><li>test-compile:编译测试代码</li><li>process-test-classes:处理测试代码</li><li>test:单元测试运行测试代码</li><li>prepare-package:打包前的准备</li><li>package:将编译好的代码打包成为 jar 或者 war 或者 ear 等等</li><li>pre-integration-test:准备整体测试</li><li>integration-test:整体测试</li><li>post-integration-test:为整体测试收尾</li><li>verify:验证</li><li>install:安装到本地 Maven 库</li><li>deploy:将最终包部署到远程 Maven 仓库</li></ul><h5 id="site周期"><a href="#site周期" class="headerlink" title="site周期"></a>site周期</h5><ul><li>pre-site:准备生成站点</li><li>site:生成站点及文档</li><li>post-site:站点收尾</li><li>site-deploy:将生成的站点发布到服务器上</li></ul><h5 id="mvn命令与生命周期"><a href="#mvn命令与生命周期" class="headerlink" title="mvn命令与生命周期"></a>mvn命令与生命周期</h5><ul><li>mvn clean：指的是clean生命周期的pre-clean和clean阶段</li><li>mvn test：指的是default生命周期中从开始到test的所有阶段都按照顺序执行</li><li>mvn clean install：指的是调用clean生命周期的clean阶段和default生命周期的install阶段</li></ul><h4 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h4><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>为方便指定执行插件的某个功能，将插件的每个功能叫目标。这样就可以实现在哪个阶段，执行哪个插件的具体哪个目标。</p><h5 id="插件绑定生命周期"><a href="#插件绑定生命周期" class="headerlink" title="插件绑定生命周期"></a>插件绑定生命周期</h5><ul><li>内置绑定：<ul><li>Maven的插件在安装好后，会自动为生命周期的主要阶段绑定插件的目标。插件如果定义了某个生命周期的阶段，会默认绑定在该阶段</li><li>安装Maven-clean-plugin插件，maven在clean阶段会自动调用maven-clean-plugin的clean目标</li><li>maven-site-plugin插件，该插件有两个目标:site和deploy。所以maven会将site的目标绑定在site生命周期，deploy目标绑定在deploy生命周期</li></ul></li><li>自定义绑定：<ol><li>指定需要绑定的插件</li><li>通过executions下的execution子元素配置执行任务，指定任务id</li><li>使用标签phase指定绑定的阶段，goals中的goal标签指定对应的任务目标</li></ol></li></ul><h4 id="依赖的传递"><a href="#依赖的传递" class="headerlink" title="依赖的传递"></a>依赖的传递</h4><h5 id="版本冲突该采用哪个版本-依赖调解"><a href="#版本冲突该采用哪个版本-依赖调解" class="headerlink" title="版本冲突该采用哪个版本-依赖调解"></a>版本冲突该采用哪个版本-依赖调解</h5><ol><li>依赖调解第一原则:路径优先。谁的依赖深度浅用谁的</li><li>依赖调解第二原则:声明优先。假设路径深度相等，那么声明在前的会被引用。</li></ol><h4 id="版本锁定dependencyManagement"><a href="#版本锁定dependencyManagement" class="headerlink" title="版本锁定dependencyManagement"></a>版本锁定dependencyManagement</h4><h4 id="pom内置属性"><a href="#pom内置属性" class="headerlink" title="pom内置属性"></a>pom内置属性</h4><ol><li>$ {project. build. sourceDirectory} :项目的主源码目录，默认是 src/main/java</li><li>${project. build. testSourceDirectory} :项目的测试源码目录，默认是 src/test/ Java 。</li><li>${project. build. directory} :项 目构建输出目录，默认是 target。</li><li>$ {project. outputDirectory}:项目主代码编译输出目录，默认是 target/classes</li><li>$ {proj巳ct. testOutputDirectory}:项目测试代码编译输出目录，默认是 target/testclasses。</li><li>${project. groupld} :项目的 groupld。</li><li>$ {project. artifactld} :项目的 artifactId。</li><li>$ {project. version} :项目的版本 。</li><li>${project. build. finalName}: 项目输出的文件名称，默认为${project.artifactld }-${project. version}。</li></ol><h3 id="Maven常见标签"><a href="#Maven常见标签" class="headerlink" title="Maven常见标签"></a>Maven常见标签</h3><h4 id="Build标签以及属性"><a href="#Build标签以及属性" class="headerlink" title="Build标签以及属性"></a>Build标签以及属性</h4><p>Build标签用来做构建</p><table><thead><tr><th align="left">Element</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>sourceDirectory</code></td><td align="left"><code>String</code></td><td align="left">此元素指定包含项目源的目录。生成的构建系统将在构建项目时编译此目录中的源代码。给出的路径是相对于项目描述符的。</td></tr><tr><td align="left"><code>scriptSourceDirectory</code></td><td align="left"><code>String</code></td><td align="left">此元素指定包含项目脚本源的目录。该目录与 sourceDirectory 不同，因为它的内容在大多数情况下将被复制到输出目录（因为脚本是解释而不是编译）。</td></tr><tr><td align="left"><code>testSourceDirectory</code></td><td align="left"><code>String</code></td><td align="left">此元素指定包含项目单元测试源的目录。生成的构建系统将在测试项目时编译这些目录。给出的路径是相对于项目描述符的。</td></tr><tr><td align="left"><code>outputDirectory</code></td><td align="left"><code>String</code></td><td align="left">放置已编译应用程序类的目录。</td></tr><tr><td align="left"><code>testOutputDirectory</code></td><td align="left"><code>String</code></td><td align="left">放置已编译测试类的目录。</td></tr><tr><td align="left"><code>extensions/extension*</code></td><td align="left"><code>List&lt;Extension&gt;</code></td><td align="left"><strong>（许多）</strong>从这个项目中使用的一组构建扩展。</td></tr><tr><td align="left"><code>defaultGoal</code></td><td align="left"><code>String</code></td><td align="left">当项目没有指定时要执行的默认目标（或 Maven 2 中的阶段）。请注意，在多模块构建的情况下，只有顶级项目的默认目标是相关的，即忽略子模块的默认目标。从 Maven 3 开始，多个目标/阶段可以用空格分隔。</td></tr><tr><td align="left"><code>resources/resource*</code></td><td align="left"><code>List&lt;Resource&gt;</code></td><td align="left"><strong>（许多）</strong>此元素描述所有类路径资源，例如与项目关联的属性文件。这些资源通常包含在最终包中。</td></tr><tr><td align="left"><code>testResources/testResource*</code></td><td align="left"><code>List&lt;Resource&gt;</code></td><td align="left"><strong>（许多）</strong>此元素描述所有类路径资源，例如与项目的单元测试关联的属性文件。</td></tr><tr><td align="left"><code>directory</code></td><td align="left"><code>String</code></td><td align="left">放置构建生成的所有文件的目录。</td></tr><tr><td align="left"><code>finalName</code></td><td align="left"><code>String</code></td><td align="left">将调用生成的工件的文件名（不包括扩展名，并且没有路径信息）。默认值为<code>$&#123;artifactId&#125;-$&#123;version&#125;</code>。</td></tr><tr><td align="left"><code>filters/filter*</code></td><td align="left"><code>List&lt;String&gt;</code></td><td align="left"><strong>（许多）</strong>启用过滤时使用的过滤器属性文件列表。</td></tr><tr><td align="left"><code>pluginManagement</code></td><td align="left"><code>PluginManagement</code></td><td align="left">默认插件信息可供从中派生的项目参考。除非引用，否则此插件配置将不会被解析或绑定到生命周期。给定插件的任何本地配置都将在这里覆盖插件的整个定义。</td></tr><tr><td align="left"><code>plugins/plugin*</code></td><td align="left"><code>List&lt;Plugin&gt;</code></td><td align="left"><strong>（许多）</strong>要使用的插件列表。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;maven相关知识总结&lt;/p&gt;</summary>
    
    
    
    <category term="技术书籍摘录" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    <category term="框架设计" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="maven" scheme="https://morningbells.github.io/tags/maven/"/>
    
    <category term="《maven实战》" scheme="https://morningbells.github.io/tags/%E3%80%8Amaven%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>架构设计</title>
    <link href="https://morningbells.github.io/2021/11/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://morningbells.github.io/2021/11/03/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-03T14:01:04.000Z</published>
    <updated>2021-11-17T08:31:07.696Z</updated>
    
    <content type="html"><![CDATA[<p>软件架构设计</p><span id="more"></span><h3 id="软件框架设计原则"><a href="#软件框架设计原则" class="headerlink" title="软件框架设计原则"></a>软件框架设计原则</h3><h4 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h4><p>功能迭代需要对拓展开放、对修改关闭。意思是需要增加新功能不应该在源代码上去修改，而是增加新的代码，比如新的工厂实现类</p><h4 id="2-依赖倒置原则"><a href="#2-依赖倒置原则" class="headerlink" title="2. 依赖倒置原则"></a>2. 依赖倒置原则</h4><p>设计代码结构时，底层模块应该依赖高层模块。举个例子，应该由各个渠道的实现系统来依赖渠道管理系统(通过dubbo的版本号，或者其他手段)</p><h4 id="3-单一职责原则"><a href="#3-单一职责原则" class="headerlink" title="3. 单一职责原则"></a>3. 单一职责原则</h4><p>一段代码最好只对应一个职责。这样可以避免因为一个职责改动了代码，导致其他职责功能发生故障</p><h4 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h4><p>不要建立一个很庞大臃肿的通用单一接口，这样会导致接口实现类很多方法都是空的，影响阅读。(高内聚，低耦合)</p><h4 id="5-迪米特原则"><a href="#5-迪米特原则" class="headerlink" title="5. 迪米特原则"></a>5. 迪米特原则</h4><p>最少知道原则，尽量降低类与类之间的耦合度，一个对象应该对其他对象保持最少的了解。</p><h4 id="6-里氏替换原则"><a href="#6-里氏替换原则" class="headerlink" title="6. 里氏替换原则"></a>6. 里氏替换原则</h4><p>主要针对父子类。引用父类的地方一定可以换成具体的子类，而且程序逻辑不变。子类可以拓展父类的功能，但是不能改变父类原有的功能</p><h4 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7. 合成复用原则"></a>7. 合成复用原则</h4><p>指尽量使用对象组合(has-a)/聚合(contanis-a)而不是继承关系达到 软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度， 一个类的变化对其他类造成的影响相对较少。</p><p>继承叫作白箱复用，相当于把所有的实现细节暴露给子类。组合/ 聚合称为黑箱复用，我们是无法获取到类以外的对象的实现细节的。</p><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><h4 id="1-什么是康威定律"><a href="#1-什么是康威定律" class="headerlink" title="1. 什么是康威定律"></a>1. 什么是康威定律</h4><p>康威定律其实是一句格言，指出组织设计系统来反映他们自己的沟通结构。</p><blockquote><p>一个组织的系统通常被设计成这个组织通信结构的副本</p></blockquote><p>大致意思是设计系统的企业，它们生产的设计等同于企业内的沟通结构。大致意思是说，产品必然是其组织沟通结构的缩影，因为跨部门沟通非常困难，成本较高，开发者会趋利避害的寻找更简单的替代方案</p><h4 id="2-康威定律的四条子定律"><a href="#2-康威定律的四条子定律" class="headerlink" title="2. 康威定律的四条子定律"></a>2. 康威定律的四条子定律</h4><h5 id="第一定律-Communication-dictates-design"><a href="#第一定律-Communication-dictates-design" class="headerlink" title="第一定律 Communication dictates design"></a><strong>第一定律 Communication dictates design</strong></h5><p>组织沟通方式会通过系统设计表达出来</p><h5 id="第二定律-There-is-never-enough-time-to-do-something-right-but-there-is-always-enough-time-to-do-it-over"><a href="#第二定律-There-is-never-enough-time-to-do-something-right-but-there-is-always-enough-time-to-do-it-over" class="headerlink" title="第二定律 There is never enough time to do something right, but there is always enough time to do it over"></a><strong>第二定律 There is never enough time to do something right, but there is always enough time to do it over</strong></h5><p>时间再多一件事情也不可能做的完美，但总有时间做完一件事情</p><p>其中：敏捷开发巨头之一Erik Hollnagel （2009）在他的书中阐述了类似的观点：</p><p>​    1）问题太复杂？那么不妨忽略不必要的细节；</p><p>​    2）没有足够的资源？放弃无用的功能；</p><h5 id="第三定律-There-is-a-homomorphism-from-the-linear-graph-of-a-system-to-the-linear-graph-of-its-design-organization"><a href="#第三定律-There-is-a-homomorphism-from-the-linear-graph-of-a-system-to-the-linear-graph-of-its-design-organization" class="headerlink" title="第三定律 There is a homomorphism from the linear graph of a system to the linear graph of its design organization"></a><strong>第三定律 There is a homomorphism from the linear graph of a system to the linear graph of its design organization</strong></h5><p>线型系统和线型组织架构间有潜在的异质同态特性</p><h5 id="第四定律-The-structures-of-large-systems-tend-to-disintegrate-during-development-qualitatively-more-so-than-with-small-systems"><a href="#第四定律-The-structures-of-large-systems-tend-to-disintegrate-during-development-qualitatively-more-so-than-with-small-systems" class="headerlink" title="第四定律 The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems"></a><strong>第四定律 The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems</strong></h5><p>大的系统组织总是比小系统更倾向于分解</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;软件架构设计&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="https://morningbells.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="软件架构设计" scheme="https://morningbells.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《码农翻身-用故事给技术加点料》摘录-总结</title>
    <link href="https://morningbells.github.io/2021/11/01/%E3%80%8A%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E7%94%A8%E6%95%85%E4%BA%8B%E7%BB%99%E6%8A%80%E6%9C%AF%E5%8A%A0%E7%82%B9%E6%96%99%E3%80%8B%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/"/>
    <id>https://morningbells.github.io/2021/11/01/%E3%80%8A%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E7%94%A8%E6%95%85%E4%BA%8B%E7%BB%99%E6%8A%80%E6%9C%AF%E5%8A%A0%E7%82%B9%E6%96%99%E3%80%8B%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-01T10:15:13.000Z</published>
    <updated>2021-11-17T08:31:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>《码农翻身-用故事给技术加点料》，读后感&amp;摘抄</p><span id="more"></span><p>《码农翻身-用故事给技术加点料》读后感</p><h3 id="线程池事故总结"><a href="#线程池事故总结" class="headerlink" title="线程池事故总结"></a>线程池事故总结</h3><h4 id="1-不加锁导致线程不安全"><a href="#1-不加锁导致线程不安全" class="headerlink" title="1. 不加锁导致线程不安全"></a>1. 不加锁导致线程不安全</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211026114840402.png" alt="image-20211026114840402"></p><p>解决方案：加锁，同时只允许一个线程操作账户</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211026115015213.png" alt="image-20211026115015213"></p><h4 id="2-死锁-转账时"><a href="#2-死锁-转账时" class="headerlink" title="2. 死锁(转账时)"></a>2. 死锁(转账时)</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211026115103641.png" alt="image-20211026115103641"></p><p>解决方案：按照资源”优先级”来获取锁。举个例子：导演的优先级比演员高，所以大家都先来竞争导演的锁(优先级可以使用hashCode或者账户id来加锁)</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211026115754231.png" alt="image-20211026115754231"></p><h3 id="TCP-IP协议总结"><a href="#TCP-IP协议总结" class="headerlink" title="TCP/IP协议总结"></a>TCP/IP协议总结</h3><h4 id="1-三次握手四次挥手"><a href="#1-三次握手四次挥手" class="headerlink" title="1. 三次握手四次挥手"></a>1. 三次握手四次挥手</h4><h4 id="2-滑动窗口协议"><a href="#2-滑动窗口协议" class="headerlink" title="2. 滑动窗口协议"></a>2. 滑动窗口协议</h4><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="1-速度比较"><a href="#1-速度比较" class="headerlink" title="1. 速度比较"></a>1. 速度比较</h4><p>CPU速度为纳秒级别，人间1秒，CPU已经做了10亿次动作了</p><p>内存，比CPU慢百倍</p><p>磁盘，比CPU慢百万倍</p><p>缓存，大概100纳秒</p><h4 id="2-其他组件"><a href="#2-其他组件" class="headerlink" title="2. 其他组件"></a>2. 其他组件</h4><ul><li>BIOS：是电脑的基本输入输出系统，是连接电脑硬件与软件的桥梁。BIOS是电脑启动加载的第一个软件，它是一组固定在电脑主板上的<strong>ROM芯片上</strong>的程序，它保存着电脑最重要的输入输出程序，开机后自检程序和系统自启动程序，它可以从<strong>COMS</strong>中读取系统设置中的具体信息。</li><li>中断向量表： 中断源的识别标志，可用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址称为中断向量</li><li>磁盘扇区：在计算机磁盘存储器，一个<strong>扇区</strong>（英文：<strong>sector</strong>）是磁盘或光盘上一个磁道的分区。每个扇区存储固定数量用户可访问的数据，传统上512字节对于硬盘驱动器（HDD）和2048字节对于CD-ROM和DVD-ROM。较新的硬盘驱动器使用4096字节（4 KiB）扇区，这被称为先进格式化（Advanced Format）（AF）。</li><li>操作系统：<strong>操作系统</strong>（英语：<strong>O</strong>perating <strong>S</strong>ystem，缩写：<strong>OS</strong>）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。</li></ul><h4 id="3-程序局部性原理"><a href="#3-程序局部性原理" class="headerlink" title="3. 程序局部性原理"></a>3. 程序局部性原理</h4><p>一个内存位置被访问，他周围的内存也很快被访问到。</p><p>所以系统会做一个优化，将内存周围的东西放到缓存中去，这个做法有好有坏，读取的时候速度会更快，但是更新的时候还需要修改缓存行中的内容会变慢。</p><p>所以对于更新较多的场景，会做一些缓存行对齐来提高效率。比如:Disruptor框架。比如java的@Contended</p><h4 id="4-CPU流水线"><a href="#4-CPU流水线" class="headerlink" title="4. CPU流水线"></a>4. CPU流水线</h4><p>cpu流水线技术是一种将指令分解为多步，并让不同指令的各步操作重叠，从而实现几条指令并行处理，以加速程序运行过程的技术。指令的每步有各自独立的电路来处理，每完成一步，就进到下一步，而前一步则处理后续指令。</p><h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><h4 id="冯·诺依曼计算机结构"><a href="#冯·诺依曼计算机结构" class="headerlink" title="冯·诺依曼计算机结构"></a>冯·诺依曼计算机结构</h4><p>五个部件：运算器、控制器、存储器、输入设备、输出设备</p><h4 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h4><p>进程控制块PCB：指令行数、寄存器的值、用了多少时间、等待了多少时间等</p><p>段地址和偏移地址的结合：</p><p>地址静态重定位：</p><p>基址寄存器：</p><p>内存管理单元MMU：</p><p>分时系统：把CPU运行时间分成一个个的<strong>时间片</strong>, 时间片用完了就会切换进程</p><p>局部性原理：</p><pre><code>* 时间局部性;如果程序中的某条指令开始执行，则不久之后该指令可能再次被执行; 如果某数据被访问 ， 则不久之后该数据可能再次被访问 。* 空间局部性:指一旦程序访问了某个存储单元，则不久之后，真附近的存储单元也将被访问。</code></pre><p>分块装入内存：</p><p>虚拟内存、台页：</p><h3 id="翻译器"><a href="#翻译器" class="headerlink" title="翻译器"></a>翻译器</h3><p>计算机需要二进制语言，人类没办法记住这么复杂的二进制，所以用一些人文理解的单词或者字母对应具体的二进制，也叫做汇编语言。但是计算机识别不了汇编语言，所以需要翻译器(汇编器)来翻译</p><h4 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h4><p>汇编器负责把汇编语言写的程序翻译成机器语言，这个翻译过程基本上就是一一对应 的关系。</p><p>优点是：贴近机器，效率极高</p><p>缺点是：需要手动处理管理内存中的帧栈</p><h4 id="乔姆斯"><a href="#乔姆斯" class="headerlink" title="乔姆斯"></a>乔姆斯</h4><p>他是一位自然语言结构的研究家，将语言分为了0型文法、 l 型文法、 2 型文洁 、 3 型文法</p><h5 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h5><p>设G=（VN，VT，P，S），如果它的每个产生式α→β是这样一种结构：α∈(VN∪VT)*且至少含有一个非终结符，而β∈(VN∪VT)*，则G是一个0型文法。0型文法也称短语文法。0型文法的能力相当于图灵机(Turing)。或者说，任何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。</p><p>我们发现0型文法是限制最少的一种文法，平时见到的文法几乎都属于0型文法。</p><h5 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h5><p>1型文法也叫上下文有关文法，此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|&gt;=|α|。这里的|β|表示的是β的长度。</p><p>注意：虽然要求|β|&gt;=|α|，但有一特例：α→ε也满足1型文法。</p><p>如有A-&gt;Ba则|β|=2,|α|=1符合1型文法要求。反之,如aA-&gt;a，则不符合1型文法。</p><h5 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h5><p>2型文法也叫上下文无关文法，它对应于下推自动机。2型文法是在1型文法的基础上,再满足：每一个α→β都有α是非终结符。如A-&gt;Ba,符合2型文法要求。</p><p>如Ab-&gt;Bab虽然符合1型文法要求,但不符合2型文法要求，因为其α=Ab，而Ab不是一个非终结符。</p><h5 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h5><p>3型文法也叫正规文法，它对应于有限状态自动机。它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。</p><p>如有：A-&gt;a,A-&gt;aB,B-&gt;a,B-&gt;cB，则符合3型文法的要求。但如果推导为:A-&gt;ab,A-&gt;aB,B-&gt;a,B-&gt;cB或推导为:A-&gt;a,A-&gt;Ba,B-&gt;a,B-&gt;cB则不符合3型方法的要求了。具体的说，例子A-&gt;ab,A-&gt;aB,B-&gt;a,B-&gt;cB中的A-&gt;ab不符合3型文法的定义,如果把后面的ab,改成“一个非终结符＋一个终结符”的形式（即为aB）就对了。例子A-&gt;a,A-&gt;Ba,B-&gt;a,B-&gt;cB中如果把B-&gt;cB改为B-&gt;Bc的形式就对了,因为A→α|αB（右线性）和A→α|Bα（左线性）两套规则不能同时出现在一个语法中,只能完全满足其中的一个,才能算3型文法。</p><h5 id="四种文法判断规则"><a href="#四种文法判断规则" class="headerlink" title="四种文法判断规则"></a>四种文法判断规则</h5><p>首先，应该明确，四种文法，从0型到3型，其规则和约定越来越多，限制条件也越来越多，</p><p>所以我们应该按照3-&gt;2-&gt;1-&gt;0的顺序去判断，一旦满足前面的规则，就不用去判断后面的了。</p><ol><li><p>先来看看3型文法的判断规则<br>①：左边必须只有一个字符，且必须是非终结符；<br>②：其右边最多只能有两个字符，要么是一个非终结符+终结符（终结符+非终结符），要么是一个终结符。<br>③：对于3型文法中的所有产生式，若其右边有两个字符的产生式，这些产生式右边两个字符中终结符和非终结符的相对位置一定要固定，也就是说如果一个产生式右边的两个字符的排列是：终结符＋非终结符，那么所有产生式右边只要有两个字符的，都必须满足终结符+非终结符。反之亦然。</p></li><li><p>再看看2型文法判断规则<br>①：与3型文法的第一点相同，即：左边必须有且仅有一个非终结符。<br>②：2型文法所有产生式的右边可以含有若干个终结符和非终结符（只要是有限的就行，没有个数限制）。</p></li><li><p>最后再看看1型文法判断规则<br>①：1型文法所有产生式左边可以含有一个、两个或两个以上的字符，但其中必须至少有一个非终结符。<br>②：与2型文法第二点相同，但需要满足|α|≤|β|.</p></li></ol><p>0型文法不需要判断了，一般的文法都是0型文法。 O(∩_∩)O</p><h4 id="编译的过程"><a href="#编译的过程" class="headerlink" title="编译的过程"></a>编译的过程</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211101153341946.png" alt="image-20211101153341946"></p><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ol><li>将高级语言的源程序分为一个个的片段(Token)</li><li>建立一张符号表，让后续步骤使用</li></ol><h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><ol><li><p>使用上下文无关语法的理论，根据符号表，建立一棵语法树</p></li><li><p>例如高级语法会被建立成如下语法树：total = salary * 12 + 2*bonus</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211101153757569.png" alt="image-20211101153757569"></p></li></ol><h5 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h5><ol><li>校验标识符的类型、作用域是不是正确</li><li>校验运算是否合法、取值有没有问题</li></ol><h5 id="生成中间代码、代码优化、生成最终代码"><a href="#生成中间代码、代码优化、生成最终代码" class="headerlink" title="生成中间代码、代码优化、生成最终代码"></a>生成中间代码、代码优化、生成最终代码</h5><h3 id="单点登陆SSO"><a href="#单点登陆SSO" class="headerlink" title="单点登陆SSO"></a>单点登陆SSO</h3><h4 id="cookie，session"><a href="#cookie，session" class="headerlink" title="cookie，session"></a>cookie，session</h4><h4 id="CAS-Central-Authentication-Service"><a href="#CAS-Central-Authentication-Service" class="headerlink" title="CAS(Central Authentication Service)"></a>CAS(Central Authentication Service)</h4><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>遇到的问题：</p><p>多个redis机器之间的数据没关系，需要每次存储或者查询要路由到同一台机器。难点在于有可能加集群</p><p>解决方案</p><ol><li>一致性Hash算法。Hash环</li><li>Hash槽</li><li>Redis Cluster</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《码农翻身-用故事给技术加点料》，读后感&amp;amp;摘抄&lt;/p&gt;</summary>
    
    
    
    <category term="技术书籍摘录" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    <category term="框架设计" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="框架设计" scheme="https://morningbells.github.io/tags/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="二次阅读" scheme="https://morningbells.github.io/tags/%E4%BA%8C%E6%AC%A1%E9%98%85%E8%AF%BB/"/>
    
    <category term="《码农翻身-用故事给技术加点料》" scheme="https://morningbells.github.io/tags/%E3%80%8A%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E7%94%A8%E6%95%85%E4%BA%8B%E7%BB%99%E6%8A%80%E6%9C%AF%E5%8A%A0%E7%82%B9%E6%96%99%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>框架结构设计</title>
    <link href="https://morningbells.github.io/2021/10/24/%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://morningbells.github.io/2021/10/24/%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-10-24T11:00:05.000Z</published>
    <updated>2021-11-17T08:31:07.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件框架设计原则"><a href="#软件框架设计原则" class="headerlink" title="软件框架设计原则"></a>软件框架设计原则</h3><h4 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h4><p>功能迭代需要对拓展开放、对修改关闭。意思是需要增加新功能不应该在源代码上去修改，而是增加新的代码，比如新的工厂实现类</p><h4 id="2-依赖倒置原则"><a href="#2-依赖倒置原则" class="headerlink" title="2. 依赖倒置原则"></a>2. 依赖倒置原则</h4><p>设计代码结构时，底层模块应该依赖高层模块。举个例子，应该由各个渠道的实现系统来依赖渠道管理系统(通过dubbo的版本号，或者其他手段)</p><h4 id="3-单一职责原则"><a href="#3-单一职责原则" class="headerlink" title="3. 单一职责原则"></a>3. 单一职责原则</h4><p>一段代码最好只对应一个职责。这样可以避免因为一个职责改动了代码，导致其他职责功能发生故障</p><h4 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h4><p>不要建立一个很庞大臃肿的通用单一接口，这样会导致接口实现类很多方法都是空的，影响阅读。(高内聚，低耦合)</p><h4 id="5-迪米特原则"><a href="#5-迪米特原则" class="headerlink" title="5. 迪米特原则"></a>5. 迪米特原则</h4><p>最少知道原则，尽量降低类与类之间的耦合度，一个对象应该对其他对象保持最少的了解。</p><h4 id="6-里氏替换原则"><a href="#6-里氏替换原则" class="headerlink" title="6. 里氏替换原则"></a>6. 里氏替换原则</h4><p>主要针对父子类。引用父类的地方一定可以换成具体的子类，而且程序逻辑不变。子类可以拓展父类的功能，但是不能改变父类原有的功能</p><h4 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7. 合成复用原则"></a>7. 合成复用原则</h4><p>指尽量使用对象组合(has-a)/聚合(contanis-a)而不是继承关系达到 软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度， 一个类的变化对其他类造成的影响相对较少。</p><p>继承叫作白箱复用，相当于把所有的实现细节暴露给子类。组合/ 聚合称为黑箱复用，我们是无法获取到类以外的对象的实现细节的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;软件框架设计原则&quot;&gt;&lt;a href=&quot;#软件框架设计原则&quot; class=&quot;headerlink&quot; title=&quot;软件框架设计原则&quot;&gt;&lt;/a&gt;软件框架设计原则&lt;/h3&gt;&lt;h4 id=&quot;1-开闭原则&quot;&gt;&lt;a href=&quot;#1-开闭原则&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring技术内幕</title>
    <link href="https://morningbells.github.io/2021/10/22/spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>https://morningbells.github.io/2021/10/22/spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/</id>
    <published>2021-10-22T08:36:46.000Z</published>
    <updated>2021-11-17T08:31:07.693Z</updated>
    
    <content type="html"><![CDATA[<p>Spring技术内幕</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211022162716198.png" alt="image-20211022162716198"></p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>控制反转有两种形式：DI依赖注入和DL依赖查询</p><h4 id="常见的两个IOC容器"><a href="#常见的两个IOC容器" class="headerlink" title="常见的两个IOC容器"></a>常见的两个IOC容器</h4><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>二者主要区别如下：</p><ol><li>如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。</li><li>BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。</li><li>没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能</li></ol><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>BeanFactory是容器类的根本父类，它定义了Ioc容器的基本功能规范。</p><ul><li>getBean方法：取得IOC容器管理的Bean，默认是根据bean的名字查找，也可以指定其他查询策略</li><li>containsBean方法：判断容器中是否有某个bean</li><li>isSingleton：查询指定的Bean 是否是Singleton类型</li><li>isPrototype：查询指定的Bean 是否是prototype类型</li><li>isTypeMatch：查询指定的Bean的Class是否是参数</li><li>getType：查询指定Bean的Class类型</li><li>getAliases：查询Bean的别名</li></ul><p>不同的子类实现其实是为了解析不同的BeanDefination：</p><ul><li><p>XmlBeanFactory：解析XML形式定义 的BeanDefinition。对应解析类是XmlBeanDefinationReader</p></li><li><p>ClassPathXmlApplicationContext: ApplicationContext实现，从classpath获取配置文件</p></li><li><p>FileSystemXmlApplicationContext：ApplicationContext实现，从文件系统获取配置文件</p></li><li><p>ApplicationContext：是BeanFactory的实现，有一些额外的功能：</p><ul><li><p>拓展MessageSource接口：支持国际化</p></li><li><p>继承DefaultResourceLoader：支持ResourceLoader和Resource，访问资源</p></li><li><p>继承接口ApplicationEventPublisher：引入事件机制</p><ul><li><p>ApplicationContext事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。如果容器中有一个ApplicationListener Bean，每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。这种事件机制都必须需要程序显示的触发。其中spring有一些内置的事件，当完成某种操作时会发出某些事件动作。比如监听ContextRefreshedEvent事件，当所有的bean都初始化完成并被成功装载后会触发该事件，实现ApplicationListener&lt; ContextRefreshedEvent&gt;接口可以收到监听动作，然后可以写自己的逻辑。同样事件可以自定义、监听也可以自定义，完全根据自己的业务逻辑来处理。</p></li><li><p>内置事件</p><ul><li><p>ContextRefreshedEvent<br>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext接口中使用 refresh() 方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用</p></li><li><p>ContextStartedEvent<br>当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p></li><li><p>ContextStoppedEvent<br>当使用 ConfigurableApplicationContext 接口中的 stop() 停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</p></li><li><p>ContextClosedEvent<br>当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</p></li><li><p>RequestHandledEvent<br>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件。不管是内置监听还是外部自定义监听一定要把实现ApplicationListener的类定义成一个bean才行，可以是通过注解@Component等也可以通过xml的方式去执行。</p></li></ul></li></ul></li></ul></li></ul><h6 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h6><p>BeanFactory是一个工厂，Ioc的容器</p><p>FactoryBean是一个特殊的Bean，可以用来产生或者修饰其他bean的生成</p><h4 id="BeanDefination各个对象和他们"><a href="#BeanDefination各个对象和他们" class="headerlink" title="BeanDefination各个对象和他们"></a>BeanDefination各个对象和他们</h4><p>BeanDefination用来管理Spring中的各个对象和之间的关系，其中主要包括以下几点：</p><ol><li>全限定类名FQN: 用于定义Bean的实现类</li><li>Bean行为定义: 包含Bean在容器中的行为、作用域、是否惰性初始化等</li><li>Bean创建方式定义：表明是通过构造器还是工厂创建的Bean</li><li>Bean之间关系定义: 即对其他bean的引用，也就是依赖关系定义</li></ol><h4 id="Ioc容器的初始化"><a href="#Ioc容器的初始化" class="headerlink" title="Ioc容器的初始化"></a>Ioc容器的初始化</h4><p>容器初始化可以认为是BeanDefinition的source定位、载入和注册三个部分</p><ul><li>Resource定位；指对BeanDefinition的资源定位过程。通俗地讲，就是找到定义Javabean信息的XML文件，并将其封装成Resource对象。</li><li>BeanDefinition的载入；把用户定义好的Javabean表示为IoC容器内部的数据结构，这个容器内部的数据结构就是BeanDefinition。</li><li>向IoC容器注册这些BeanDefinition</li></ul><h4 id="Ioc容器的依赖注入"><a href="#Ioc容器的依赖注入" class="headerlink" title="Ioc容器的依赖注入"></a>Ioc容器的依赖注入</h4><ul><li>依赖注入可以通过lazy-init来完成对bean的预实例化<ul><li>在finishBeanFactoryInitialization方法中，封装了对lazy-init的实现</li></ul></li><li>depends-on指定bean的初始化以及销毁的顺序。<ul><li>被depends-on的bean需要先被初始化</li><li>被depends-on的bean需要后被销毁</li></ul></li></ul><h4 id="Spring的三级缓存"><a href="#Spring的三级缓存" class="headerlink" title="Spring的三级缓存"></a>Spring的三级缓存</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211022150448788.png" alt="image-20211022150448788"></p><ol><li>单例缓存</li><li>正在创建中的Bena缓存(提前暴露)</li><li>工厂缓存</li></ol><p>三级缓存在DefaultSingletonBeanRegistry类下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>为什么用第三级缓存:<br>正常的类用二级缓存就可以。用三级缓存的原因是如果 bean 是代理类会有问题。A 依赖 B，B 依赖 A。 创建A的时候来创建B会导致 B 依赖的是 原来的 A 而不是 A 的代理对象</p><h4 id="Spring的生命周期"><a href="#Spring的生命周期" class="headerlink" title="Spring的生命周期"></a>Spring的生命周期</h4><ol><li>实例化 Bean: BeanFactory，FactoryBean，ApplicationContext, BeanDefination</li><li>设置对象属性: 依赖注入, BeanWrapper</li><li>Aware 接口：设置不同的 aware</li><li>BeanPostProcessor 前置处理<ul><li>@Resource   CommonAnnotationBeanPostProcessor</li><li>@Autowired  AutowireAnnotationBeanPostProcessor</li></ul></li><li>InitializingBean 的 afterPropertiesSet</li><li>init-method</li><li>BeanPostProcessor 后置处理</li><li>destory</li></ol><h4 id="Spring中的Bean是线程安全的吗"><a href="#Spring中的Bean是线程安全的吗" class="headerlink" title="Spring中的Bean是线程安全的吗"></a>Spring中的Bean是线程安全的吗</h4><p>Spring 中的单例bean不是线程安全的。如果Bean是有状态对象，即Bean有实例对象，那么会出现资源竞争。如果Bean无状态，那么是线程安全的</p><h4 id="Spring中Bean的五种作用域"><a href="#Spring中Bean的五种作用域" class="headerlink" title="Spring中Bean的五种作用域"></a>Spring中Bean的五种作用域</h4><ol><li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。注：spring默认使用单例模式，因为Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。而singleton作用域的Bean实例一旦创建成功，可以重复使用。</li><li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。 注：prototype作用域Bean的创建、销毁代价比较大。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</li><li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li><li>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li><li>global session：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li></ol><h4 id="Spring的动态代理"><a href="#Spring的动态代理" class="headerlink" title="Spring的动态代理"></a>Spring的动态代理</h4><p>cglib、jdk代理</p><h3 id="Spring-AOP面向切面"><a href="#Spring-AOP面向切面" class="headerlink" title="Spring AOP面向切面"></a>Spring AOP面向切面</h3><h4 id="AOP技术"><a href="#AOP技术" class="headerlink" title="AOP技术"></a>AOP技术</h4><p>AspectJ:源代码和字节码级别的编织器，用户需 要使用不同于Java的新语言。</p><p>AspectWerkz:AOP框架，使用字节码动态编织器 和XML配置。</p><p>JBoss-AOP:基于拦截器和元数据的AOP框架，运 行在JBoss应用服务器上。以及在AOP中使用到的一些 相关的技术实现:</p><p>BCEL(Byte-Code Engineering Library):Java字 节码操作类库</p><p>Javassist:Java字节码操作类库，JBoss的一个子项目(Dubbo)</p><h4 id="AOP体系结构"><a href="#AOP体系结构" class="headerlink" title="AOP体系结构"></a>AOP体系结构</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211022155711979.png" alt="image-20211022155711979"></p><h4 id="AOP基本概念"><a href="#AOP基本概念" class="headerlink" title="AOP基本概念"></a>AOP基本概念</h4><ol><li>连接点(Jointpoint),表示AOP”在哪里干”</li><li>切入点(Pointcut),表示AOP”在哪里干的集合”</li><li>通知(Advice)，表示”干什么”</li><li>方面/切面(Aspect)，表示”在哪干和干什么集合”</li><li>引入(inter-type declaration), 表示”干什么和引入什么”</li><li>目标对象(target),表示”对谁干”</li><li>织入(Weaving)，将切面应用到目标对象从而创建出AOP代理对象的过程<h4 id="Spring通知类型"><a href="#Spring通知类型" class="headerlink" title="Spring通知类型"></a>Spring通知类型</h4></li><li>前置通知(before advice)</li><li>后置通知(after advice)<ol><li>后置返回通知</li><li>后置异常通知</li><li>后置最终通知</li></ol></li><li>环绕通知(around advices)<h4 id="建立AopProxy代理对象的步骤"><a href="#建立AopProxy代理对象的步骤" class="headerlink" title="建立AopProxy代理对象的步骤"></a>建立AopProxy代理对象的步骤</h4>aop代理的目的就是将切面织入到目标对象</li></ol><h5 id="使用注解进行配置-AspectJ风格"><a href="#使用注解进行配置-AspectJ风格" class="headerlink" title="使用注解进行配置(@AspectJ风格)"></a>使用注解进行配置(@AspectJ风格)</h5><ol><li>@Aspect声明切面</li><li>@Pointcut声明切入点</li><li>@Before前置通知</li><li>@AfterRunning后置返回通知</li><li>@AfterThrowing后置异常通知</li><li>@After后置最终通知</li><li>@Around环绕通知</li><li>@DeclareParents引入其他切面</li></ol><h5 id="配置ProxyFactoryBean"><a href="#配置ProxyFactoryBean" class="headerlink" title="配置ProxyFactoryBean"></a>配置ProxyFactoryBean</h5><ol><li>定义通知器Advisor</li><li>定义proxyFactoryBean，封装AOP的主要功能</li><li>定义target属性，作为target属性注入的Bean</li></ol><h5 id="ProxyFactoryBean生成AopProxy"><a href="#ProxyFactoryBean生成AopProxy" class="headerlink" title="ProxyFactoryBean生成AopProxy"></a>ProxyFactoryBean生成AopProxy</h5><h5 id="JDK生成AopProxy代理对象"><a href="#JDK生成AopProxy代理对象" class="headerlink" title="JDK生成AopProxy代理对象"></a>JDK生成AopProxy代理对象</h5><h5 id="CGLIB生成AopProxy代理对象"><a href="#CGLIB生成AopProxy代理对象" class="headerlink" title="CGLIB生成AopProxy代理对象"></a>CGLIB生成AopProxy代理对象</h5><h4 id="Spring-AOP拦截器调用的实现"><a href="#Spring-AOP拦截器调用的实现" class="headerlink" title="Spring AOP拦截器调用的实现"></a>Spring AOP拦截器调用的实现</h4><h5 id="JdkDynamicAopProxy的invoke拦截"><a href="#JdkDynamicAopProxy的invoke拦截" class="headerlink" title="JdkDynamicAopProxy的invoke拦截"></a>JdkDynamicAopProxy的invoke拦截</h5><ol><li>JdkDynamicAopProxy实现了 InvocationHandler接口</li><li>当Proxy对象的代理 方法被调用时，JdkDynamicAopProxy的invoke方法作 为Proxy对象的回调函数而被触发，从而通过invoke的 具体实现，来完成对目标对象方法调用的拦截或者说 功能增强的工作</li></ol><h5 id="Cglib2AopProxy的intercept拦截"><a href="#Cglib2AopProxy的intercept拦截" class="headerlink" title="Cglib2AopProxy的intercept拦截"></a>Cglib2AopProxy的intercept拦截</h5><ol><li>cglib通过继承实现拦截</li><li>CglibMethodInvocation</li></ol><h5 id="cglib和jdk动态代理的区别"><a href="#cglib和jdk动态代理的区别" class="headerlink" title="cglib和jdk动态代理的区别"></a>cglib和jdk动态代理的区别</h5><ul><li>jdk动态代理:使用Proxy动态代理实现，即提取目标对象的接口，对接口创建AOP代理</li><li>cglib动态代理：不仅可以代理接口，也能代理类，有以下限制<ul><li>不能代理final方法，因为cglib通过继承实现代理，final不能被覆盖</li><li>会产生两次构造器调用，第一次是目标类的构造器调用，第二次是cglib产生的代理类的构造器调用。如果使用cglib代理方法，保证重复调用构造器不影响使用</li></ul></li><li>spring默认使用jdk代理，如果对象没有实现任何接口会使用cglib，也可以指定强制使用cglib代理</li></ul><h3 id="Spring相关组件"><a href="#Spring相关组件" class="headerlink" title="Spring相关组件"></a>Spring相关组件</h3><h4 id="Spring-Mvc"><a href="#Spring-Mvc" class="headerlink" title="Spring Mvc"></a>Spring Mvc</h4><h4 id="Spring数据库操作，JDBCTemplate，-JPA"><a href="#Spring数据库操作，JDBCTemplate，-JPA" class="headerlink" title="Spring数据库操作，JDBCTemplate， JPA"></a>Spring数据库操作，JDBCTemplate， JPA</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/20211022192259.png"></p><ul><li>support包: 提供一些工具类</li><li>datasource包：简化访问JDBC数据源的工具类，并提供DataSource简单实现类使得DataSource获取的连接可以自动得到Spring事务支持</li><li>core包：提供JDBC模板类，也提供SimplejdbcInsert等简单辅助类</li><li>object包: 提供关系型数据库的对象表现形式，如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类，该包是基于core包的JDBC模板类实现</li></ul><h5 id="JDBC模板类–JdbcTemplate"><a href="#JDBC模板类–JdbcTemplate" class="headerlink" title="JDBC模板类–JdbcTemplate"></a>JDBC模板类–JdbcTemplate</h5><p>JdbcTemplate主要分为五类方法:</p><ol><li>execute方法：用于执行任何sql语句、一般用于执行DDL</li><li>update方法以及batchUpdate方法：update方法用于执行新增、修改、删除等语句; batchUpdate用于批处理</li><li>query方法以及queryForXXX方法：用于查询</li><li>call方法：存储过程、函数相关</li></ol><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><p>可以使用编程式事务或者声明式事务</p><h5 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h5><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><ul><li>未提交读</li><li>提交读</li><li>可重复读</li><li>序列化</li></ul><h5 id="spring实现事务"><a href="#spring实现事务" class="headerlink" title="spring实现事务"></a>spring实现事务</h5><ul><li>策略接口: PlatformTransactionManager</li><li>getTransaction：返回一个已经激活的事务或者创建一个新的事务</li><li>commit：提交TransactionStatus参数代表的事务</li><li>rollback：用于回滚TransactionStatus参数代表的事务</li><li>TransactionDefinition用来定义事务的参数</li></ul><h5 id="内置事务管理器"><a href="#内置事务管理器" class="headerlink" title="内置事务管理器"></a>内置事务管理器</h5><ol><li>DataSourceTransactionManager: 用于Spring JDBC抽象框架、MyBatis框架的事务管理</li><li>JdoTransactionManger：用于集成JDO框架时的事务管理</li><li>JpaTransactionManager:用于集成JPA实现框架的事务管理</li><li>HibernationTransactionManager：集成Hibrenate</li><li>OC4JitaTransactionManager：对OC4J10.1.3+应用服务器事务管理器的适配器</li><li>WebSphereUowTransactionManager:对WebSphere 6.0+应用服务器事务管理器的适配器</li><li>WebLogicJtaTransactionManager:对WebLogic8.1+服务器事务管理器的适配器</li></ol><h4 id="Spring远端调用RMI"><a href="#Spring远端调用RMI" class="headerlink" title="Spring远端调用RMI"></a>Spring远端调用RMI</h4><h4 id="Spring安全框架ACEGI"><a href="#Spring安全框架ACEGI" class="headerlink" title="Spring安全框架ACEGI"></a>Spring安全框架ACEGI</h4><h3 id="Spring-SPEL语法"><a href="#Spring-SPEL语法" class="headerlink" title="Spring-SPEL语法"></a>Spring-SPEL语法</h3><h4 id="SpEL基础"><a href="#SpEL基础" class="headerlink" title="SpEL基础"></a>SpEL基础</h4><p>SpEL功能很强大，表达式中的关键字不区分大小写，它支持如下表达式</p><ol><li>基本表达式:字面量表达式、关系、逻辑与算数运算表达式、字符串连接及截取表达式、三目运算符及Elivis表达式、正则表达式、括号优先级表达式</li><li>类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取、对象方法调用、Bean引用</li><li>集合类表达式：内联list、数组、集合；字典访问；列表、字典、数组修改；集合投影、集合选择；<h4 id="SpEL主要接口"><a href="#SpEL主要接口" class="headerlink" title="SpEL主要接口"></a>SpEL主要接口</h4></li><li>ExpressionPraser接口:表示解析器，一般实现是SpelExpressionParser，parseExpression方法将表达式转化为Expression对象</li><li>EvaluationContext接口:表示上下文环境，一般实现是StandardEvaluationContext，setRootObject方法设置根对象，setVariable注册自定义变量，registerFunction注册自定义函数</li><li>Expression：表示表达式对象，一般指的是SpelExpression，getValue方法获取表达式值，setValue设置对象值<h4 id="SpEL语法"><a href="#SpEL语法" class="headerlink" title="SpEL语法"></a>SpEL语法</h4><h5 id="基本表达式"><a href="#基本表达式" class="headerlink" title="基本表达式"></a>基本表达式</h5></li><li>字面量表达式:SpEL支持的字面量表达式包括:字符串、数字类型(int、long、float、double)、布尔类型、null类型</li><li>算术运算表达式:加减乘除、求余、幂运算</li><li>关系表达式：等于、不等于、大于(等于)、小于(等于)、区间</li><li>逻辑表达式：且、或、非</li><li>字符串连接及截取：”+”做字符串连接，”‘String’[0][index]”做截取</li><li>三目运算符及Elivis运算表达式：<ul><li>三目:表达式1?表达式2:表达式3</li><li>Elivis:表达式1?:表达式2</li></ul></li><li>正则表达式: “str matches regex” 表示</li><li>括号优先级:<h5 id="类相关表达式"><a href="#类相关表达式" class="headerlink" title="类相关表达式"></a>类相关表达式</h5></li><li>类类型表达式：使用类的全限定名表示class实例(java.lang除外)</li><li>类实例化: 类实例化使用关键字”new”，类名需要是全限定名(java.lang除外)</li><li>instanceof表达式: 和java使用相同</li><li>变量定义以及引用: 变量通过EvaluationContext接口的setVariable(name,value)定义，表达式中使用”#name”</li><li>自定义函数: 只支持类静态方法注册为自定义函数; SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数</li><li>赋值表达式</li><li>对象属性存取及安全导航表达式</li><li>对象方法调用</li><li>Bean引用<h5 id="集合相关表达式"><a href="#集合相关表达式" class="headerlink" title="集合相关表达式"></a>集合相关表达式</h5></li><li>内联List: “{1,2,3,4}”</li><li>内联数组: “[]”</li><li>集合</li><li>列表，字典，数组元素</li><li>集合投影: 使用投影表达式进行投影运算</li><li>集合选择: 选择表达式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring技术内幕&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/metabolism/blogimage/raw/master/img/image-20211022162716198.png&quot; alt=&quot;image-202110221627161</summary>
      
    
    
    
    <category term="框架整理" scheme="https://morningbells.github.io/categories/%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/"/>
    
    
    <category term="spring" scheme="https://morningbells.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>股市真规则</title>
    <link href="https://morningbells.github.io/2021/10/18/%E8%82%A1%E5%B8%82%E7%9C%9F%E8%A7%84%E5%88%99/"/>
    <id>https://morningbells.github.io/2021/10/18/%E8%82%A1%E5%B8%82%E7%9C%9F%E8%A7%84%E5%88%99/</id>
    <published>2021-10-18T14:18:04.000Z</published>
    <updated>2021-11-17T08:31:07.696Z</updated>
    
    <content type="html"><![CDATA[<p>股市真规则摘抄</p><span id="more"></span><h4 id="分析公司竞争力"><a href="#分析公司竞争力" class="headerlink" title="分析公司竞争力"></a>分析公司竞争力</h4><ol><li>评估公司历史上的盈利能力。</li><li>评估公司利润的来源，核心竞争力是什么</li><li>公司竞争优势的周期</li><li>分析行业竞争结构。行业内的公司是怎样和其他公司竞争的呢? 还很有竞争活力还是过度竞争了</li></ol><h4 id="评价收益性"><a href="#评价收益性" class="headerlink" title="评价收益性"></a>评价收益性</h4><ol><li>这家公司有自由现金流吗，有多少(根据现金流量表去计算：经营性现金流减去资本支出现金流)</li><li>计算公司的净利润。公司净利润在15%以上就说明它的经营活动是良好的</li><li>计算资产收益率。超过6%~7%说明公司良好</li><li>计算净资产收益率。公司能够持续不断地显示有高于15%的净资产收 益率，通常表明股东的投资正在产生稳定的回报</li></ol><h4 id="行业分析"><a href="#行业分析" class="headerlink" title="行业分析"></a>行业分析</h4><ol><li>产商平均营业毛利率：相当高(高于25%)、相当低(低于15%)</li></ol><h4 id="财务报表"><a href="#财务报表" class="headerlink" title="财务报表"></a>财务报表</h4><p>从年度报告，10-K报告和10-Q报告 这三个报告里找到对应的三张表</p><ol><li>资产负债表。它告诉你一家公司拥 有多少资产、多少负债，资产和负债之差就是所有者权益<ol><li>资产–负债=所有者权益</li></ol></li><li>利润表。看看公司用这些资产和负债是赚钱了还是赔钱了</li><li>现金流量表。反映的是一家公 司在一个会计年度发生的现金是多少，以及现金是由哪些部分组成的</li></ol><h4 id="公司分析"><a href="#公司分析" class="headerlink" title="公司分析"></a>公司分析</h4><ol><li>成长性:一家公司成长得有多快?它成长性的来源是什么?这种成 长具有怎样的持续性?</li><li>收益性:公司的投资产生了怎样的回报?</li><li>财务健康状况:这家公司的财务根基是否牢固?</li><li>风险/负担情况:你投资中的风险是什么?即使最好的企业也有足够 的理由不去投资。确信你已了解企业的全部情况并做了详细调查，其 中的负面因素确实压不过正面因素。</li><li>管理:谁在主持这项业务?他们经营这家公司是为了股东的利益还 是为他们自己?这是一个关键性的问题，我将在第七章用整章的篇幅 来论述。</li></ol><h4 id="公司分析-管理者"><a href="#公司分析-管理者" class="headerlink" title="公司分析-管理者"></a>公司分析-管理者</h4><ol><li>报酬：股东委托书中会详细注明股东的报酬</li><li>绩效奖励。</li></ol><h4 id="财务上的危险信号"><a href="#财务上的危险信号" class="headerlink" title="财务上的危险信号"></a>财务上的危险信号</h4><ul><li>衰退中的现金流</li><li>连续的收购</li><li>没有收到货款的账单</li><li>变更赊销付款条件和应收账款</li><li>首席财务官或审计师离开公司</li><li>连续的非经常性费用</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;股市真规则摘抄&lt;/p&gt;</summary>
    
    
    
    <category term="股票学习" scheme="https://morningbells.github.io/categories/%E8%82%A1%E7%A5%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="投资学习" scheme="https://morningbells.github.io/categories/%E8%82%A1%E7%A5%A8%E5%AD%A6%E4%B9%A0/%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="书籍摘录" scheme="https://morningbells.github.io/tags/%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    <category term="股市真规则" scheme="https://morningbells.github.io/tags/%E8%82%A1%E5%B8%82%E7%9C%9F%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>springboot快速回顾</title>
    <link href="https://morningbells.github.io/2021/10/17/springboot%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"/>
    <id>https://morningbells.github.io/2021/10/17/springboot%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</id>
    <published>2021-10-17T05:43:51.000Z</published>
    <updated>2021-11-17T08:31:07.693Z</updated>
    
    <content type="html"><![CDATA[<p>springboot快速回顾</p><span id="more"></span><h3 id="回顾Spring"><a href="#回顾Spring" class="headerlink" title="回顾Spring"></a>回顾Spring</h3><h4 id="Spring的IOC与DI、DL"><a href="#Spring的IOC与DI、DL" class="headerlink" title="Spring的IOC与DI、DL"></a>Spring的IOC与DI、DL</h4><p>IOC(IOC Container，IOC的容器)指的是Inversion of  Control，他有两种形式：DI和DL</p><p>DI代表的是Dependency Injection(依赖注入)，接受依赖组件被容器的注入。DI就是启动时将服务注入到一级二级三级缓存里。</p><p>DL代表的是Dependency Lookup(依赖查找)，主动去进行查询所依赖的服务。DL其实也很常见:context.getBean()</p><h4 id="常见的springBoot注解"><a href="#常见的springBoot注解" class="headerlink" title="常见的springBoot注解"></a>常见的springBoot注解</h4><ol><li><p>@Configuration</p></li><li><p>@ComponentScan</p></li><li><p>@PropertySource和@PropertySources：此注解用于指定从哪个properties文件中读取配置，代码层需要使用PropertySourcesPlaceholderConfigurer，具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:1.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxConfiguration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Import与@ImportSource：使用此注解将多个分开的配置合到一起</p></li><li><p>@Conditional：基于条件的配置，只有符合某个条件了才会生效，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在存在此配置的时候bean才会创建</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(&quot;spring.application.name&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> xxxxx&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在springboot中存在多个类似的注解：@ConditionalOnClass、@ConditionalOnBean、@ConditionalOnMissingClass、@ConditionalOnMissingBean、@ConditionalOnProperty</p></li></ol><p>6.</p><h3 id="SpringBoot的工作机制"><a href="#SpringBoot的工作机制" class="headerlink" title="SpringBoot的工作机制"></a>SpringBoot的工作机制</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>此注解作为springboot项目启动类包含三个注解：@Configuration、@ComponentScan、@EnableAutoConfuration(SPI获取spring.factories文件的配置，代码层由SpringFactoriesLoader控制)</p><h4 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h4><ol><li>初始化前的准备<ol><li>根据ConfigurableWebApplicationContext决定创建web型/Standalone的Application</li><li>使用SpringFactoriesLoader查找并加载所有的ApplicationContextInitializer</li><li>使用SpringFactoriesLoader查找并加载所有的ApplciationListener</li></ol></li><li>遍历执行所有通过SpringFactoriesLoader加载到的SpringApplicationRunListener，调用他们的started()方法</li><li>创建并配置所需用的Environment(包括PropertySource以及Profile)</li><li>遍历调用SpringApplicationRunListener的environmentPrepared方法</li><li>如果showBanner配置是true，那么打印自定义的banner</li><li>根据配置决定是否添加ShutdownHook，决定是否使用BeanNameGenerator，决定是否使用ResourceLoader</li><li>ApplicationContext创建好了之后，会再次查找所有可用的ApplicationContextInitializer，然后遍历调用ApplicationContextInitializer的initialize方法</li><li>遍历调用SpringApplicationRunListener的contextPrepared()方法</li><li><strong>通过@EnableAutoConfiguration获取的所有配置的IOC容器，并加载到已经准备好的ApplicationContext中</strong></li><li>遍历调用SpringApplicationRunListener的contextLoaded()方法</li><li>调用ApplicationContext方法的refresh方法</li><li>查找当前ApplicationContext里是否注册了CommandLineRunner，并遍历的执行他们</li><li>遍历调用SpringApplicationRunListener的finished()方法</li></ol><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211017131215320.png" alt="image-20211017131215320"></p><h5 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h5><p>SpringApplicationRunListener是springboot在执行main方法过程当中接收不同执行事件通着的监控者</p><h5 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h5><p>用来支持监听者框架的一种实现。在spring启动结束后会去通知监听的所有框架</p><p>自定义Application方法如下：</p><ol><li>SpringApplication.addListeners(…)或者SpringApplication.setListeners</li><li>借助spring.factories机制，在配置文件中加上自己的SPI配置</li></ol><h5 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h5><p>主要在ConfigurableApplicationContext类型的ApplicationContext做refresh前，再做一些初始化的自定义处理</p><p>自定义方法如下：</p><ol><li>借助spring.factories机制，在配置文件中加上自己的SPI配置，走SpringFactoriesLoader进行配置</li><li>通过SpringApplication.addInitializers()设置</li></ol><h5 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h5><ol><li>所有CommandLineRunner的执行点在，所有ApplicationContext完全定义后(可以理解为是main方法的最后一步)</li><li>只要存在项目的CommandLineRunner都会被执行。不管是DI还是DL获取到的</li><li>建议实现@Order注解来定义多个CommandLineRunner 的执行顺序</li></ol><h3 id="SpringBoot的starter结构"><a href="#SpringBoot的starter结构" class="headerlink" title="SpringBoot的starter结构"></a>SpringBoot的starter结构</h3><p>自定义的一些约定大于配置的默认实现方式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;springboot快速回顾&lt;/p&gt;</summary>
    
    
    
    <category term="框架整理" scheme="https://morningbells.github.io/categories/%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/"/>
    
    
    <category term="springboot" scheme="https://morningbells.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>指数基金的基础知识</title>
    <link href="https://morningbells.github.io/2021/10/16/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://morningbells.github.io/2021/10/16/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-16T10:15:47.000Z</published>
    <updated>2021-11-17T08:31:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>投资必备的基础知识，《定投十年财务自由》摘录&amp;读后感</p><span id="more"></span><h4 id="储蓄银行"><a href="#储蓄银行" class="headerlink" title="储蓄银行"></a>储蓄银行</h4><p>活期储蓄，利率为0.35%。</p><p>3个月定期存款，利率为1.1%。</p><p>6个月定期存款，利率为1.3%。</p><p>1年定期存款，利率为1.5%。</p><p>3年定期存款，利率为2.75%。</p><p>不太看好前景，日本的储蓄已经发展到银行机构存钱负利率了，个人存钱活期是0.001%(存10w一年利息是1)</p><h4 id="银行类理财"><a href="#银行类理财" class="headerlink" title="银行类理财"></a>银行类理财</h4><p>银行类理财产品在部分特殊时间收益会变高。季末、年中、年末这些考核点，收益会高一些。</p><p>小银行的收益率比大银行高一些。</p><p>一般银行收益率：国有银行&lt;商业银行&lt;城商行、农商行&lt; 信用社，不过风险也是越来越高。</p><p>鉴别收益率的方法是查看 存款利率高的银行，理财产品收益率也高</p><h4 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h4><h5 id="基金的分类"><a href="#基金的分类" class="headerlink" title="基金的分类"></a>基金的分类</h5><ul><li>按照投资方向，基金可以分为:股票基金、债券基 金、混合基金、货币基金。</li><li>按照投资理念，基金可以分为:主动型基金、被动型 基金。</li><li>按照销售渠道，基金可以分为:场内基金(只能申购赎回)、场外基金(可以申购赎回也可以买入卖出)。</li><li>按照募集对象，基金可以分为:公募基金、私募基金。(私募门槛高100w+，一般都是玩得公募)</li><li>按照基金是否开放，基金可以分为:开放式基金，封闭式基金(封闭式基金指的是不接受申购赎回，基本份额固定)。</li></ul><h5 id="基金交易的方式"><a href="#基金交易的方式" class="headerlink" title="基金交易的方式"></a>基金交易的方式</h5><ul><li>申购赎回：申购会导致基金的总份额数量增多</li><li>买入卖出：买入意思是和其他有基金想卖的人交易，总体的基金份额不会改变</li></ul><h5 id="怎么挑选货币基金"><a href="#怎么挑选货币基金" class="headerlink" title="怎么挑选货币基金"></a>怎么挑选货币基金</h5><p>一般来 说货币市场工具包括期限小于1年的短期国库券、政府公债、大 额可转让定期存单、商业本票、银行承兑汇票等。</p><ul><li>费率越低的货币基金，越划算<ul><li>货币基金有个特点，就是不收取申购赎回费。但需要收取销售服务费、基金管理费和托管费</li><li>总费率最高的货币基金，是0.7%/ 年，而总费用最低的基金，是0.2%~0.25%/年。</li><li>所以挑选总费率低于0.3%以下的货币基金，可以考虑B类货币基金</li></ul></li></ul><h5 id="怎么挑选债券基金"><a href="#怎么挑选债券基金" class="headerlink" title="怎么挑选债券基金"></a>怎么挑选债券基金</h5><p>债券基金是以债券为主要投资对象的基金，它主要投资的 是国债、金融债、企业债等固定收益类金融工具。</p><ul><li>债券的价格和市场的利率是反相关的，如果市场利率下 降，债券的价格会上升，这时债券基金的回报会更好。</li><li>一般来说:加息周期，利率上升，债券基金表现不会太 好;降息周期，利率下降，债券基金则会表现不错。</li><li>可以根据历史利率判断当前，过去十几年，十年期国债利率的中位数是3%~3.5%</li><li>所以当利率高于3.5%时，可以选择扫货长期持有</li></ul><h5 id="怎么挑选股票基金"><a href="#怎么挑选股票基金" class="headerlink" title="怎么挑选股票基金"></a>怎么挑选股票基金</h5><p>比较波动，风险与收益并存。</p><h6 id="什么是指数基金"><a href="#什么是指数基金" class="headerlink" title="什么是指数基金"></a>什么是指数基金</h6><p>被动基金指的是其基金经理不参与选股，而是根据某 一个既定的规则来挑选股票、买入卖出。</p><p>指数基金就是一种被动型基金</p><p>道琼斯指数、纳斯达克指数、沪深300、中证500等等</p><h6 id="国内指数基金介绍"><a href="#国内指数基金介绍" class="headerlink" title="国内指数基金介绍"></a>国内指数基金介绍</h6><ul><li>沪深300：沪深300指数是由中证指数公司开发的，从上海证券交易所 和深圳证券交易所挑选规模最大、流动性最好的300只股票组成 的。</li><li>中证500：中证500指数是由中证指数公司开发的，将沪深300指数的 300家公司排除，再将最近一年日均总市值排名前300名的企业也 排除，然后在剩下的公司中，选择日均总市值排名前500名的企 业组成的。<ul><li>中证500还是一个很特殊的指数:它是最容易获得超 额收益的指数。因为目前国内中小盘股的散户比例比较高，中证 500指数成份股经常出现不理性的涨跌，利用这些不理性的涨 跌，可以获得超额收益。</li></ul></li><li>恒生指数：港股最具有代表性的指数。恒生指数代表的是港股的蓝筹股，由港交所所有上市公司中 的50家规模最大、流动性最好的公司组成，用来反映香港股市的 整体水平，单只成份股的最高比例是15%。(每季度重新选一次)<ul><li>同时，恒生指数是一 个交易指数，围绕它成立了一系列的金融衍生品，所以它也非常 注重流动性。</li><li>盈富基金。香港战胜索罗斯之后(索罗斯做空港币–&gt;香港提高汇率–&gt;股价下跌–&gt;索罗斯空头获利；香港政府的策略：提高汇率，掏钱买股保持股市价格)，手里有很多港股股份，也不能直接卖掉冲击市场。所以创建了盈富基金(福利很多，0.03%的管理费率，赠送股票，一年两次派息)</li></ul></li><li>H型股：H股指的是公司在内地注册，却在香港上市，用港币交易的 股票。</li><li>香港中小指数：港股中小盘股的代表<ul><li>中小指数中会有老千股，专门坑普通投资者</li></ul></li></ul><h6 id="小众但是长期持有可能收益会更好的指数基金"><a href="#小众但是长期持有可能收益会更好的指数基金" class="headerlink" title="小众但是长期持有可能收益会更好的指数基金"></a>小众但是长期持有可能收益会更好的指数基金</h6><ul><li><p>策略加权指数基金：也叫聪明贝塔指数基金</p><ul><li><p>A股，大约有十几种不同类型的策略指数是有对应的基金 产品的。这些指数包括基本面、红利、价值、低波动、央视 50、AH优选、行业龙头等。</p><p>有的指数的策略是公开透明的，例如价值指数，是挑选市 盈率、市净率等最低的一批股票。对应的策略是事先确定好 的。也有一些指数的策略没那么透明。例如央视50，是由央视 联合几个高校的专家挑选出50只股票。</p><p>而在所有的策略指数当中，最有影响力，也是我们最常用 到的，主要是如下四类:红利指数、基本面指数、价值指数、 低波动指数。其中，红利指数的品种数量在全世界范围都是最多的。基 本面指数其次，价值指数和低波动指数的数量也很多。</p></li><li><p>红利指数：持股收息的最优选择</p><ul><li>股票是会发放股息的，也就是现金分红，也叫股息:业绩比较好的公司，会每年从净利润中拿出一部分，以现金分红的形式回馈股东。</li></ul></li><li><p>主要的红利指数</p><ul><li>上证红利指数：上证红利指数是由上海证券交易所过去两年平均现金股息率 最高的50只股票组成的，指数代码为000015。</li><li>中证红利指数：中证红利指数由中证指数公司编制，同时从上海证券交易所 和深圳证券交易所挑选过去两年平均现金股息率最高的100只股 票。代码是000922/399922</li><li>深证红利指数：专门投资深圳证券交易 所的高现金股息率的股票，不过成份股只有40只。399324</li><li>红利机会指数：红利机会是由国际知名的指数开发商标普公司围绕A股开发 的，代码为CSPSADRP</li></ul></li><li><p>红利指数优缺点：</p><ul><li>高股息率，在熊市更有优势。</li><li>红利指数的波动是各个指数中比较低的。</li><li>有些短期发红利的公司也会被纳入到红利指数里，会导致分红不稳定</li></ul></li></ul></li><li><p>长期优秀的行业指数基金：比如消费、医药、IT等行业</p></li></ul><h6 id="基本面指数：从四个维度挑选股票"><a href="#基本面指数：从四个维度挑选股票" class="headerlink" title="基本面指数：从四个维度挑选股票"></a>基本面指数：从四个维度挑选股票</h6><p>基本面一般包含：营业收入、现金流、净资产、分红。</p><p>在基本面指数中，国内最出名的就是中证基本面50指数。这 个指数是按照以上四个基本面指标，挑选出综合排名前50的公 司。具体来说，是从上市公司过去5年的年报数据中，计算四个 基本面指标。</p><p>营业收入:公司过去5年营业收入的平均值。</p><ul><li>现金流:公司过去5年现金流的平均值。</li><li>票股选挑度维个四从:数指面本基</li><li>净资产:公司在定期调整时的净资产。</li><li>分红:公司过去5年分红总额的平均值。</li></ul><h6 id="价值指数：用四个指标挑选成分股"><a href="#价值指数：用四个指标挑选成分股" class="headerlink" title="价值指数：用四个指标挑选成分股"></a>价值指数：用四个指标挑选成分股</h6><p>价值指数用的是四个估值指标来进行筛选:市盈率、市净率、市现率、股息率。沪深300</p><ul><li>市盈率=公司市值/公司盈利。</li><li>市净率=公司市值/公司净资产。</li><li>市现率=公司市值/现金流量。</li><li>股息率=现金分红/公司市值。</li></ul><p>通常对于同一个股票品种来说，市盈率、市净率、市现率越低，股息率越高，这个品种的投资价值也会越高。</p><h6 id="低波动指数：波动率越低的股票，收益越好"><a href="#低波动指数：波动率越低的股票，收益越好" class="headerlink" title="低波动指数：波动率越低的股票，收益越好"></a>低波动指数：波动率越低的股票，收益越好</h6><p>目前市面上低波动指数的代表，是中证500行业中性低波动 指数</p><h4 id="优秀的行业"><a href="#优秀的行业" class="headerlink" title="优秀的行业"></a>优秀的行业</h4><p>天生容易赚钱的行业：消费和医药行业</p><ul><li><p>必须消费行业：最容易出现大牛股的行业之一</p><ul><li><p>必需消费行业也被称为日常消费行业、主要消费行业。必需 消费，主要是维持我们正常生活所需要的各种消费品，例如饮 料、酒、农副食品等。</p></li><li><p>必须消费行业指数：</p><ul><li>上证消费指数:从上海证券交易所挑选必需消费行业公司。</li><li>上证消费80指数:从上海证券交易所挑选80家规模最大的必 需消费行业公司。</li><li>中证消费指数:从中证800指数，即沪深300指数和中证500 指数中挑选必需消费行业公司。</li><li>全指消费指数:从所有上市公司中挑选必需消费行业公司，覆盖范围最广。</li></ul></li><li><p>必需消费行业的主力:食品饮料行业</p><p>白酒公司的占比最高，超过50%。剩下的 主要是乳制品、调味品、肉制品等公司。像我们熟悉的伊利、蒙 牛、双汇、海天味业等，都属于食品饮料行业的公司。</p><p>食品饮料行业指数：中证食品饮料行业指数</p></li></ul></li><li><p>医疗行业：经济危机中的避险板块</p><ul><li>医药行业的两大优点:长牛、避险</li><li>不过，相比必需消费行业，医药行业多了一个风险:政策风险。看病的人多了，政府会限制企业卖的更便宜</li><li>医药行业指数基金有哪些：<ul><li>300医药行业指数:挑选了沪深300指数里的医药行业公 司，主要是大型医药股。</li><li>500医药行业指数:挑选了中证500指数里的医药行业公 司，主要是中盘医药股。</li><li>中证医药行业指数:包含了300医药指数和500医药指数， 基本覆盖了医药行业的大中盘股。</li><li>全指医药行业指数:从整个A股中挑选医药行业公司，它覆 盖的医药公司是最全的。</li><li>中证医药100行业指数:挑选了市值最大的100家公司，等 权重分配，每只股票分配比例都只有1%，定期平衡。</li></ul></li></ul></li><li><p>可选消费行业：升级换代快，有周期性。可选消费指的是有钱的时候才会消费</p><ul><li>需求比必需消费弱，有一定周期性。</li><li>受益于人口红利，特别是<strong>人均消费金额</strong>的提升。</li><li>具有升级换代的特性。食品饮料一般是买旧不买新，手机汽车就是买新不买旧</li></ul></li></ul><h5 id="行业指数基金怎么选择"><a href="#行业指数基金怎么选择" class="headerlink" title="行业指数基金怎么选择"></a>行业指数基金怎么选择</h5><p>从长期收益的角度，消费、医药行业指数基金是高于所有 行业指数基金平均值的</p><p>通常我们定投时，可以以优秀的宽基策略加权指数基金为 主，以优秀行业指数基金为辅。例如以红利、基本面、价值、 低波动四类策略加权指数基金为主，以消费、医药、中概互联 行业指数基金为辅。</p><h4 id="怎么挑选指数基金"><a href="#怎么挑选指数基金" class="headerlink" title="怎么挑选指数基金"></a>怎么挑选指数基金</h4><p>挑选指数基金的时候，通常有三个比较重要的因素，分别 是规模、费用和追踪误差。</p><ul><li>秘诀1：基金规模小于1亿元的不要选，规模太小有可能会清盘</li><li>秘诀2：挑选费用较低的基金。指数基金的费用主要是:申购费、赎回费、管理费、托管费。<ul><li>托管费，一般是1%<del>1.5%，从蚂蚁财富、天天基金，申购费打1折，平均在0.1%</del>0.15%</li><li>赎回费，基金7天内赎回，有1.5%的赎回费。7天之后，0.5%赎回费。很多基金1~2年会免除赎回费</li><li>管理费，平均在0.5%<del>0.8%。最后会在0.1%</del>0.2%</li><li>托管费，一般在0.1%~0.2%</li><li>分红税、印花税和交易佣金，这部分不是透明的，不过收的很低，千分之几</li></ul></li><li>秘诀3：选择追踪误差较小的基金<ul><li>追踪误差主要看两方面：<ul><li>第一，基金份额净值增长率与业绩比较基准收益率的差 值。</li><li>第二，基金份额净值增长率标准差与业绩比较基准收益率 标准差的差值。</li></ul></li></ul></li></ul><h4 id="估值投资"><a href="#估值投资" class="headerlink" title="估值投资"></a>估值投资</h4><p>结合估值投资，避免追涨杀跌</p><h5 id="市盈率"><a href="#市盈率" class="headerlink" title="市盈率"></a>市盈率</h5><h6 id="静态市盈率"><a href="#静态市盈率" class="headerlink" title="静态市盈率"></a>静态市盈率</h6><p>静态市盈率是指，市值/上一年度财报的净利润。比如说在 2019年年中，我们看静态市盈率，就是用市值/2018年财报的净 利润。</p><h6 id="滚动市盈率"><a href="#滚动市盈率" class="headerlink" title="滚动市盈率"></a>滚动市盈率</h6><p>时效性更高的滚动市盈率是指，市值/最近四个季度财报的 净利润。相对来说实效性高一些。一般每个季度更新一次</p><h6 id="动态市盈率"><a href="#动态市盈率" class="headerlink" title="动态市盈率"></a>动态市盈率</h6><p>预测未来的动态市盈率是指，市值/预测未来一年的净利 润。动态市盈率通常是用未来一年的盈利来计算估值，但是这 个未来一年的盈利，是预测的。未来谁也无法准确预测，所以就会有偏差。大多数时候， 我们都不用动态市盈率。</p><h6 id="中位数市盈率"><a href="#中位数市盈率" class="headerlink" title="中位数市盈率"></a>中位数市盈率</h6><p>中位数市盈率，是指数中才有的一个估值指标，个股中反 而没有。</p><p>所谓的中位数市盈率，就是将一个指数的成份股，按照市 盈率从高到低排序，取排在中间的。</p><p>比如说上证50指数有50只成份股，市盈率中位数就是排中 间位置的第25位股票的市盈率数值。</p><p>如果指数成份股的平均市值规模差别比较大，那这样的指 数，可以辅助参考一下中位数市盈率。</p><p>例如牛市的时候，如果中位数市盈率先进入了高估区域， 那说明这个指数其实大部分股票都涨了比较多，可能有风险 了。</p><h5 id="市净率"><a href="#市净率" class="headerlink" title="市净率"></a>市净率</h5><p>市净率是指每股股价与每股净资产的比率，也就是我们说 的账面价值。</p><p>净资产这个财务指标比盈利更加稳定。而且，大多数公司 的净资产都是稳定增加的，可以计算出市净率。</p><h5 id="股息率"><a href="#股息率" class="headerlink" title="股息率"></a>股息率</h5><p>股息率是指，现金分红/市值。</p><p>股息，是投资者在不减少所持有的股权资产的前提下，仍 然可以直接分享企业业绩增长的最佳方式</p><h6 id="什么是分红比例"><a href="#什么是分红比例" class="headerlink" title="什么是分红比例"></a>什么是分红比例</h6><p>简单来说，股息率，是企业过去一年的现金派息额除以公 司的总市值。</p><p>分红率(分红比例)，则是企业过去一年的现金派息额除以公 司的总净利润。</p><h5 id="得出的结论"><a href="#得出的结论" class="headerlink" title="得出的结论"></a>得出的结论</h5><ol><li>盈利保持不变，看现金流收益率高低</li><li>盈利稳定增长时，使用盈利收益率法<ol><li>当指数基金的盈利收益率大于10%且大于国债收益率两倍以 上的时候投资。</li><li>当盈利收益率小于债券基金预期收益率(目前为6.4%)的 时候卖出。</li></ol></li><li>盈利快速增长：博格公式法<ol><li>•长期盈利增长速度大幅高于10%的品种，适合使用博格公 式法。</li><li>PEG反映了市盈率波动区间和长期平均盈利增长速度之间 的关系，PEG通常在1~2。如果市盈率长期保持很高的数值，那 么对这类品种要谨慎，因为很少有品种能长期保持较高盈利增 长速度。</li><li>在这个基础上，结合指数的历史市盈率，看看当前市盈率 所处历史市盈率的位置。如果市盈率同时也处于低位，那这个 品种大概率就是处于低估区域的，可以考虑买入。</li><li>如果市盈率处于高位，或者PEG也大于2，那这个品种大概 率就是处于高估区域，这时就要谨慎一些。</li></ol></li></ol><h4 id="什么时候卖出"><a href="#什么时候卖出" class="headerlink" title="什么时候卖出"></a>什么时候卖出</h4><p>止盈有三种策略</p><h5 id="从收益率角度来考虑止盈"><a href="#从收益率角度来考虑止盈" class="headerlink" title="从收益率角度来考虑止盈"></a>从收益率角度来考虑止盈</h5><p>这种思路很简单，就是坚持定投指数基金，当看到自己持 有的某只基金的收益率达到了设定的收益率，就可以开始卖出 止盈。</p><p>设定止盈收益率时，有一个比较常用的数字:30%</p><h5 id="按照估值来止盈"><a href="#按照估值来止盈" class="headerlink" title="按照估值来止盈"></a>按照估值来止盈</h5><h5 id="不止盈，长期持有吃分红"><a href="#不止盈，长期持有吃分红" class="headerlink" title="不止盈，长期持有吃分红"></a>不止盈，长期持有吃分红</h5><h5 id="动态止盈法"><a href="#动态止盈法" class="headerlink" title="动态止盈法"></a>动态止盈法</h5><p>没有理由卖掉一直正在上涨的股票，但是怎么能判断出股票下跌的时候是调整还是回落呢。可以设置一个动态的值，比如说跌了收益的10%，就卖出去了</p><h4 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h4><ol><li><p>指数基金的ABC类，有什么区别</p><p>一般基金后面的ABC，说的是收费的方式。A代表前端收费，收取申购赎回费。B代表后端收费，申购的时候不收费，但是赎回的时候收费。C代表不收取申购赎回费，但是收取销售服务费，按照持有时间长短来收取。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;投资必备的基础知识，《定投十年财务自由》摘录&amp;amp;读后感&lt;/p&gt;</summary>
    
    
    
    <category term="投资学习" scheme="https://morningbells.github.io/categories/%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="指数基金" scheme="https://morningbells.github.io/categories/%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"/>
    
    
    <category term="二次阅读" scheme="https://morningbells.github.io/tags/%E4%BA%8C%E6%AC%A1%E9%98%85%E8%AF%BB/"/>
    
    <category term="定投十年财务自由" scheme="https://morningbells.github.io/tags/%E5%AE%9A%E6%8A%95%E5%8D%81%E5%B9%B4%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>怎么寻找成长股 摘录</title>
    <link href="https://morningbells.github.io/2021/10/14/%E6%80%8E%E4%B9%88%E5%AF%BB%E6%89%BE%E6%88%90%E9%95%BF%E8%82%A1/"/>
    <id>https://morningbells.github.io/2021/10/14/%E6%80%8E%E4%B9%88%E5%AF%BB%E6%89%BE%E6%88%90%E9%95%BF%E8%82%A1/</id>
    <published>2021-10-14T09:10:53.000Z</published>
    <updated>2021-11-17T08:31:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>《怎么寻找成长股》摘录</p><span id="more"></span><p>怎么寻找成长股</p><h4 id="怎么寻找优良普通股"><a href="#怎么寻找优良普通股" class="headerlink" title="怎么寻找优良普通股"></a>怎么寻找优良普通股</h4><ol><li>这家公司的产品或服务有没有充分的市场潜力，至少几 年内营业额能否大幅成长?</li><li>为了进一步提高总体梢售水平，发现新的产品增长 点，管理层是不是决心继续有些公司因为目前的产品线有新需求，未来几年的成长展望很好，但依公司的政策和经营计划，产品线不再进 一步开发，优握的利润是否可能昙花一现？</li><li>和公司的规模相比，这家公司的研究发展努力，有多大 的效果?(研究和开发占公司营业额的百分比)</li><li>这家公司有没有高人一等的销售组织?</li><li>这家公司的利润率高不高?</li><li>这家公司做了什么事，以维持或改善利润率?</li><li>这家公司的劳资和人事关系是不是很好?</li><li>这家公司的高级主管关系很好吗?</li><li>公司管理阶层的深度够吗?</li><li>这家公司的成本分析和会计记录做得如何?</li><li>是不是在所处领域有独到之处?它可以为投资者提供 重要线索，以了解此公司相对于竞争者，是不是很突出?</li><li>这家公司有没有短期或长期的盈余展望?</li><li>在可预见的将来，这家公司是否会大量发行股票，获 取足够的资金，以利公司发展，现有持股人的利益是否因预期中的成 长而大幅受损?</li><li>管理阶层是不是只向投资人报喜不报忧?诸事顺畅时 唾沫横飞，有问题或叫人失望的事情发生时，则“三缄其又”?</li><li>这家公司管理阶层的诚信正直态度是否无庸置疑?</li></ol><h4 id="投资人”五不”"><a href="#投资人”五不”" class="headerlink" title="投资人”五不”"></a>投资人”五不”</h4><ol><li>不买处于创业阶段的公司。</li><li>不要因为一支好股票在“店头市场”交易，就弃之不顾。</li><li>不要因为你喜欢某公司年报的“格调”, 就去买该公司的股票。</li><li>不要以为一公司的本益比高，便表示未来的盈余成长已大致反 映在价格上。</li><li>不要锱铢必较。</li></ol><h4 id="投资人另外”五不”"><a href="#投资人另外”五不”" class="headerlink" title="投资人另外”五不”"></a>投资人另外”五不”</h4><ol><li>不要过度强调分散投资。</li><li>不要担心在战争阴影笼罩下买进股票。</li><li>不要忘了你的吉尔伯特和沙利文。</li><li>买进真正优秀的成长股时，除了考虑价格，不要忘了时机因 素。</li><li>不要随波逐流。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《怎么寻找成长股》摘录&lt;/p&gt;</summary>
    
    
    
    <category term="股票学习" scheme="https://morningbells.github.io/categories/%E8%82%A1%E7%A5%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="《怎么寻找成长股》" scheme="https://morningbells.github.io/tags/%E3%80%8A%E6%80%8E%E4%B9%88%E5%AF%BB%E6%89%BE%E6%88%90%E9%95%BF%E8%82%A1%E3%80%8B/"/>
    
    <category term="书籍摘录" scheme="https://morningbells.github.io/tags/%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据一致性协议-paxos</title>
    <link href="https://morningbells.github.io/2021/10/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-paxos/"/>
    <id>https://morningbells.github.io/2021/10/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-paxos/</id>
    <published>2021-10-14T06:52:48.000Z</published>
    <updated>2021-11-17T08:31:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>分布式数据一致性协议</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>分布式架构中，数据一致性一直是痛点。现在也有很多解决方案：paxos、zab、raft、gossip等等，其他协议之前分析过了，今天主要聊一下paxos。</p><h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><p>在分布式系统中，根据CAP定理，往往会在可用性与数据一致性之间进行反复的权衡，因而产生一系列一致性协议。</p><p>一致性协议并不止通知确认成功，还有分布式事务的一致性协议。介绍一下常见的分布式事务一致性协议，基础的ACID概念就不再赘述了。</p><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>2PC也叫二批次提交，正如其名，2PC指的是分两个阶段完成分布式事务。目前大部分关系型数据库保证分布式事务都是采用的二阶段提交，统一决定事物的提交或回滚。</p><p>二阶段提交是一种强一致性设计，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。</p><h5 id="2PC原理"><a href="#2PC原理" class="headerlink" title="2PC原理"></a>2PC原理</h5><h6 id="阶段1：提交事务请求-Propose阶段"><a href="#阶段1：提交事务请求-Propose阶段" class="headerlink" title="阶段1：提交事务请求(Propose阶段)"></a>阶段1：提交事务请求(Propose阶段)</h6><ol><li>事务询问：事务协调者发起propose给各个需要事务的角色</li><li>执行事务：各个节点执行各自的操作，比如mysql会记录Undo和Redo日志记录下来</li><li>反馈事务响应：将第二步的结果返回给事务协调者</li></ol><h6 id="阶段2：执行事务提交"><a href="#阶段2：执行事务提交" class="headerlink" title="阶段2：执行事务提交"></a>阶段2：执行事务提交</h6><ol><li>发送提交请求：如果第一阶段的结果都是成功，事务协调者向所有参与者发起commit</li><li>事务提交：正式提交所有的事务</li><li>反馈事务提交结果：将提交结果返回给协调者</li></ol><h5 id="2PC的优缺点"><a href="#2PC的优缺点" class="headerlink" title="2PC的优缺点"></a>2PC的优缺点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>原理简单、实现方便</p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>如果阶段2事务协调者提交事务后宕机了，并且也有一部分参与者也宕机了。成功的那一部分会卡住不知道是否事务成功了。</li><li>如果阶段2事务提交之前，协调者就宕机了。所有参与者都还会保留着事务待提交的状态，造成资源阻塞。</li></ul><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><p>根据2PC的问题可以看出，在2PC第二阶段如果协调者宕机会无法完成同步。</p><p>3PC引入了一个新的阶段，并且加入了超时机制。</p><h5 id="3PC原理"><a href="#3PC原理" class="headerlink" title="3PC原理"></a>3PC原理</h5><h6 id="阶段1：CanCommit"><a href="#阶段1：CanCommit" class="headerlink" title="阶段1：CanCommit"></a>阶段1：CanCommit</h6><ol><li>事务询问：协调者发送一个包含事务内容的canCommit的请求，询问各个参与者是否可以执行事务操作</li><li>反馈cancommit结果：</li></ol><h6 id="阶段2：PreCommit"><a href="#阶段2：PreCommit" class="headerlink" title="阶段2：PreCommit"></a>阶段2：PreCommit</h6><p>如果阶段1所有参与者都可以执行事务：</p><ol><li>发送预提交precommit请求，<strong>协调者状态变为prepared</strong></li><li>事务预提交：各个节点完成预提交动作(2PC第一阶段做的事情)，比如mysql会记录Undo和Redo日志记录下来</li><li>反馈precommit结</li></ol><p>如果阶段2存在参与者不可以执行，事务中断</p><ol><li>发送中断请求：由协调者发送</li><li>事务中断：节点收到请求进行中断，如果由于波动未收到请求，会根据超时时间自动中断</li></ol><h6 id="阶段3：doCommit"><a href="#阶段3：doCommit" class="headerlink" title="阶段3：doCommit"></a>阶段3：doCommit</h6><p>执行提交，如果阶段2所有参与者节点都执行成功：</p><ol><li>发送提交请求：向所有参与者发送doCommit请求，<strong>协调者状态变为commit</strong></li><li>事务提交：各个参与者节点收到doCommit请求之后会正式开始处理提交操作，提交完成之后释放所有在事务执行期间占用的事务资源</li><li>反馈事务提交结果</li><li>完成事务</li></ol><p>如果阶段2存在任何节点失败，事务中断：</p><ol><li>发送中断请求</li><li>事务回滚：所有节点进行回滚</li><li>反馈回滚结果</li><li>事务中断</li></ol><h5 id="3PC的个人总结"><a href="#3PC的个人总结" class="headerlink" title="3PC的个人总结"></a>3PC的个人总结</h5><p>3PC可以理解为2PC的加强版，加了预提交阶段和超时机制，我理解3PC很依赖协调者的状态，所有节点根据协调者的状态判断现在是哪一步，阶段2超时的话，节点自动回滚。阶段3，节点超时的话需要重试去docommit。</p><p>不过如果依赖协调者宕机，数据不一致的情况还是会出现。</p><h4 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h4><p>Paxos是Lamport提出的一种高度容错性的一致性算法(共识算法)。</p><p>Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><h6 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h6><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p><p>系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。</p><p>由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。</p><p>假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。</p></blockquote><h6 id="兼职议会"><a href="#兼职议会" class="headerlink" title="兼职议会"></a>兼职议会</h6><blockquote><p>假想了一个叫做Paxos的希腊城邦进行选举的情景，这个算法也是因此而得名。在他的假想中，这个城邦要采用民主提议和投票的方式选出一个最终的决议，但由于城邦的居民没有人愿意把全部时间和精力放在这种事情上，所以他们只能不定时的来参加提议，不定时来了解提议、投票进展，不定时的表达自己的投票意见。Paxos算法的目标就是让他们按照少数服从多数的方式，最终达成一致意见。</p></blockquote><h5 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h5><ul><li>角色：消费者、提议者、投票并接受者、Learner学习者(参考Quorum 议会机制，某个value需求获得了一半以上的accepeter批准后才能通过)</li><li>步骤：<ol><li>准备阶段：提议者提出一个提案，提案有唯一的编号，这个编号比所有之前的提案要大</li><li>选举阶段：投票并接受者校验这个提案编号，比自己之前遇到的编号都大则接受</li><li>提案者发送accept阶段：如果多数投票接受者都接受了，提议者会发起第二步骤accept</li><li>应答accept阶段：如果投票接受者这段时间没有接收到比此提案编号更高的提案，则接受。否则忽略</li></ol></li><li>简单来说，第一阶段确认编号可用，第二阶段写入此提案。Paxos通过两轮交互，牺牲时间和性能弥补一致性的问题</li><li>活锁问题：(因为存在多个提议者)第一个提案确认了编号之后，第二个编号也被确认了，导致第一个提案不会被正式执行。第二个提案确认了之后，又来了第三个提案被确认，导致系统一直在确认而没有在写入。解决方法：在第一阶段发现编号被更新，提议者睡眠随机时间</li></ul><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/1634183710176.jpeg" alt="1634183710176"></p><h5 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h5><ul><li>Basic Paxos存在一些问题：难实现、效率低（2 轮 rpc）、活锁。因此引入Multi Paxos，最大的变动是保留唯一一个提议者。也就是Leader概念</li><li>整合了Basic Paxos的步骤，因为只有一个leader，所以完全信任他的提案编号。所以不需要二段提交了。投票接受者收到提案和自己最大的提案编号比较，进行接受和忽略</li><li>引入的leader带来了新问题：怎么进行选举</li></ul><h4 id="Paxos的工程实践"><a href="#Paxos的工程实践" class="headerlink" title="Paxos的工程实践"></a>Paxos的工程实践</h4><h5 id="Google-Chubby分布式锁服务"><a href="#Google-Chubby分布式锁服务" class="headerlink" title="Google Chubby分布式锁服务"></a>Google Chubby分布式锁服务</h5><p>Chubby是一个面向松耦合分布式系统的锁服务。GFS(谷歌文件系统)和Big Table(谷歌开发的一种结构化数据存储与管理的大型分布式存储系统)都使用它来解决分布式协作，元数据存储和Master选举等功能。</p><p>找到了谷歌发表的chubby相关论文:<a href="http://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf">《The Chubby lock service for loosely-coupled distributed systems》</a>，大致将其翻译出来</p><h6 id="Chubby的设计目标"><a href="#Chubby的设计目标" class="headerlink" title="Chubby的设计目标"></a>Chubby的设计目标</h6><p>可靠性(reliability)、可用性(availability)、易于理解(easy-to-understand)、一致性(consistency)</p><p>选择使用锁服务而不是一致性库或者一致性服务的原因是：</p><ul><li>用户系统可能并不会在开发初期考虑高可用，而锁服务使得这些系统在后期需要一致性保证的时候能够以最小的代价接入；</li><li>分布式系统在选主的同时需要存储少量数据供集群其他节点读取，而锁服务本身就可以很好的提供这个功能；</li><li>开发者更熟悉锁接口的使用；</li><li>锁服务使得需要一致性或互斥的应用节点数不受quorum数的限制。</li></ul><h6 id="Chubby的组成部分"><a href="#Chubby的组成部分" class="headerlink" title="Chubby的组成部分"></a>Chubby的组成部分</h6><p>Chubby的结构如下图：</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211014142113634.png" alt="image-20211014142113634"></p><p>Chubby包括客户端和服务端两个部分；</p><ul><li>客户端通过一个Chubby Library同服务端进行交互；</li><li>服务端由多个节点组成集群的方式提供高可用的服务。</li></ul><h6 id="Chubby的设计"><a href="#Chubby的设计" class="headerlink" title="Chubby的设计"></a>Chubby的设计</h6><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211014142223498.png" alt="image-20211014142223498"></p><p>我们<a href="http://baotiao.github.io/2017/09/12/distributed-lock/">认为</a>分布式锁的问题其实包含三个部分，分别是一致性协议、分布式锁的实现、分布式锁的使用。三个部分自下而上完成了在分布式环境中对锁需求，下面我们就将从这三个方面介绍Chubby的设计。</p><h6 id="一致性协议-1"><a href="#一致性协议-1" class="headerlink" title="一致性协议"></a><strong>一致性协议</strong></h6><p>一致性协议其实并不是锁需求直接相关的，假设我们有一个永不宕机的节点和永不中断的网络，那么一个单点的存储即可支撑上层的锁的实现及使用。但这种假设在互联网环境中是不现实的，所以才引入了一致性协议，来保证我们可以通过副本的方式来容忍节点或网络的异常，同时又不引起正确性的风险，作为一个整体对上层提供高可用的服务。</p><p>Chubby采用的是一个有强主的Multi-Paxos，其概要实现如下：</p><ul><li>多个副本组成一个集群，副本通过一致性协议选出一个Master，集群在一个确定的租约时间内保证这个Master的领导地位；</li><li>Master周期性的向所有副本刷新延长自己的租约时间；</li><li>每个副本通过一致性协议维护一份数据的备份，而只有Master可以发起读写操作；</li><li>Master挂掉或脱离集群后，其他副本发起选主，得到一个新的Master；</li></ul><p>具体的Paxos实现可以参考论文<a href="http://140.123.102.14:8080/reportSys/file/paper/lei/lei_5_paper.pdf">Paxos Made Simple</a>，在这里我们只需要把它近似看做一个不会宕机不会断网的节点，能保证所有成功写入的操作都能被后续成功的读取读到。</p><h6 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a><strong>分布式锁的实现</strong></h6><p>这部分是Chubby实现的重点，为了更好的梳理这部分的脉络，我们先看看Chubby提供的API以及给Client的使用机制，他们一起组成了Chubby对外的<strong>接口</strong>；之后介绍锁的<strong>实现</strong>；最后结合Chubby对读写请求比例，可用性，Corase-Lock等定位引出的Cache，Session及故障恢复等<strong>内部机制</strong>。</p><p><strong>接口</strong></p><p>Chubby的对外接口是外部使用者直接面对的使用Chubby的方式，是连接分布式锁的实现及使用之间的桥梁：</p><ul><li>Chubby提供类似UNIX文件系统的数据组织方式，包括<strong>Files</strong>和<strong>Directory</strong>来存储数据或维护层级关系，统称<strong>Node</strong>；提供跟Client同生命周期的<strong>Ephemeral</strong>类型Node来方便实现节点存活监控；通过类似于UNIX文件描述符的<strong>Handle</strong>方便对Node的访问；Node除记录数据内容外还维护如ACL、版本号及Checksum等<strong>元信息</strong>。</li><li>提供众多方便使用的<strong>API</strong>，包括获取及关闭Handle的Open及Close接口；获取释放锁的Aquire，Release接口；读取和修改Node内容的GetContentAndStat，SetContent，Delete接口；以及其他访问元信息、Sequencer，ACL的相关接口。</li><li>提供<strong>Event</strong>的事件通知机制来避免客户端轮训的检查数据或Lock的变化。包括Node内容变化的事件；子Node增删改的事件；Chubby服务端发生故障恢复的事件；Handle失效事件。客户端收到事件应该做出对应的响应。</li></ul><p><strong>锁实现</strong></p><p>每一个File或者Directory都可以作为读写锁使用，接受用户的Aquire，Release等请求。锁依赖下层的一致性服务来保证其操作顺序。Chubby提供的是<strong>Advisory Lock</strong>的实现，相对于<strong>Mandatory Lock</strong>，由于可以访问加锁Node的数据而方便数据共享及管理调试。分布式锁面对的最大挑战来自于客户端节点和网络的不可靠，Chubby提供了两种锁实现的方式：</p><p><strong>1)，完美实现：</strong></p><ul><li>Aquire Lock的同时，Master生成一个包含Lock版本号和锁类型的Sequencer；</li><li>Chubby Server在Lock相关节点的元信息中记录这个版本号，Lock版本号会在每次被成功Aquire时加一；</li><li>成功Aquire Lock的Handle中也会记录这个Sequencer；</li><li>该Handle的后续操作都可以通过比较元信息中的Lock版本号和Sequencer判断锁是否有效，从而接受或拒绝；</li><li>用户直接调用Release或Handle由于所属Client Session过期而失效时，锁被释放并修改对应的元信息。</li></ul><p><strong>2)，简易实现：</strong></p><ul><li>Handle Aquire Lock的同时指定一个叫做lock-delay的时长；</li><li>获得Lock的Handle可以安全的使用锁功能，而不需要获得Sequencer；</li><li>获得Lock的Handle失效后，Server会在lock-delay的时间内拒绝其他加锁操作。</li><li>而正常的Release操作释放的锁可以立刻被再次获取；</li><li>注意，用户需要保证在指定的lock-delay时间后不会再有依赖锁保护的操作；</li></ul><p>对比两种实现方式，简易版本可以使用在无法检查Sequencer的场景从而更一般化，但也因为lock-delay的设置牺牲了一定的可用性，同时需要用户在业务层面保证lock-delay之后不会再有依赖锁保护的操作。</p><p><strong>Cache</strong></p><p>从这里开始要提到的Chubby的机制是对Client透明的了。Chubby对自己的定位是需要支持大量的Client，并且读请求远大于写请求的场景，因此引入一个对读请求友好的Client端Cache，来减少大量读请求对Chubby Master的压力便十分自然，客户端可以完全不感知这个Cache的存在。Cache对读请求的极度友好体现在它牺牲写性能实现了一个一致语义的Cache：</p><ul><li>Cache可以缓存几乎所有的信息，包括数据，数据元信息，Handle信息及Lock；</li><li>Master收到写请求时，会先阻塞写请求，通过返回所有客户端的KeepAlive来通知客户端Invalid自己的Cache；</li><li>Client直接将自己的Cache清空并标记为Invalid，并发送KeepAlive向Master确认；</li><li>Master收到所有Client确认或等到超时后再执行写请求。</li></ul><p><strong>Session and KeepAlive</strong></p><p>Session可以看做是Client在Master上的一个投影，Master通过Session来掌握并维护Client：</p><ul><li>每个Session包括一个租约时间，在租约时间内Client是有效的，Session的租约时间在Master视角和Client视角由于网络传输时延及两端的时钟差异可能略有不同；</li><li>Master和Client之间通过KeepAlive进行通信，Client发起KeepAlive，会被Master阻塞在本地，直到Session租约临近过期，此时Master会延长租约时间，并返回阻塞的KeepAlive通知Client。除此之外，Master还可能在Cache失效或Event发生时返回KeepAlive；</li><li>Master除了正常的在创建连接及租约临近过期时延长租约时间外，故障恢复也会延长Session的租约；</li><li>Client的租约过期会先阻塞本地的所有请求，进入jeopardy状态，等待额外的45s，以期待与Master的通信恢复。如果事与愿违，则返回用户失败。</li></ul><p>Session及KeepAlive给了Chubby Server感知和掌握Client存活的能力，这对锁的实现也是非常重要的，因为这给了Master一个判断是否要释放失效Lock的时机。最后总结下，这些机制之间的关系，如下图：</p><p><img src="http://catkang.github.io/assets/img/chubby/mechansim.png" alt="Chubby Mechansim"></p><p><strong>故障恢复</strong></p><p>Master发生故障或脱离集群后，它锁维护的Session信息会被集群不可见，一致性协议会选举新的Master。由于Chubby对自己Corase Lock的定位，使用锁的服务在锁的所有权迁移后会有较大的恢复开销，这也就要求新Master启动后需要恢复必要的信息，并尽量减少集群停止服务过程的影响：</p><ul><li>选择新的epoch；</li><li>根据持久化的副本内容恢复Session及Lock信息，并重置Session租约到一个保守估计的时长；</li><li>接受并处理Client的KeepAlive请求，第一个KeepAlive会由于epoch错误而被Maser拒绝，Client也因此获得了最新的epoch；之后第二个KeepAlive直接返回以通知Client设置本地的Session租约时间；接着Master Block第三个KeepAlive，恢复正常的通信模式。</li><li>从新请求中发现老Master创建的Handle时，新Master也需要重建，一段时间后，删除没有Handle的临时节点。</li></ul><p><img src="http://catkang.github.io/assets/img/chubby/failover.png" alt="Failed Over"></p><h6 id="分布式锁的使用"><a href="#分布式锁的使用" class="headerlink" title="分布式锁的使用"></a><strong>分布式锁的使用</strong></h6><p>锁的使用跟上面提到的锁的实现是紧密相关的，由于客户端节点及网络的不可靠，即使Chubby提供了直观如Aquire，Realease这样的锁操作，使用者仍然需要做出更多的努力来配合完成锁的语义，Chubby论文中以一个选主场景对如何使用锁给出了详细的说明，以完美方案为例：</p><ul><li>所有Primary的竞争者，<strong>Open</strong>同一个Node，之后用得到的Handle调用<strong>Aquire</strong>来获取锁；</li><li>只有一个成功获得锁，成为Primary，其他竞争者称为Replicas；</li><li>Primary将自己的标识通过<strong>SetContent</strong>写入Node；</li><li>Replicas调用<strong>GetContentsAndStat</strong>获得当前的Primary标识，并注册该Node的内容修改Event，以便发现锁的Release或Primary的改变；</li><li>Primary调用<strong>GetSequencer</strong>从当前的Handle中获得sequencer，并将其传递给所有需要锁保护的操作的Server；</li><li>Server通过<strong>CheckSequencer</strong>检查其sequencer的合法性，拒绝旧的Primary的请求。</li></ul><p>如果是简单方案，则不需要Sequencer，但需要在<strong>Aquire</strong>操作时指定lock-delay，并保证所有需要锁保护的操作会在最后一次Session刷新后的lock-delay时间内完成。</p><h6 id="Chubby带来的启发"><a href="#Chubby带来的启发" class="headerlink" title="Chubby带来的启发"></a>Chubby带来的启发</h6><p>暂且抛开Chubby对分布式锁的实现，本质上Chubby是一个在分布式环境中提供服务的系统。其在复杂性控制，可用性，可靠性，可扩展性等方面作出的努力和思考对我们其他系统的设计开发也是很有指导和借鉴意义的，下面列举一些进行说明。</p><p><strong>1，责任分散</strong></p><p>分布式系统中，通常都会有多个角色进行协作共同完成某个目标，有时候合理的将某些功能的责任分散到不同角色上去，分散到不同时间去，会起到降低复杂度，减少关键节点压力的效果。比如Chubby中发生写事件需要更新Client Cache时，Master并没有尝试自己去更新所有的Client，而是简单的Invalid所有Client的Cache，这样就将更新所有Client Cache这项任务分散到所有的客户端上，分散到后边一次次的请求时机中去。这种推变拉的做法也是Zeppelin中大量使用的。</p><p><strong>2，考虑可扩展时，减少通信次数有时候比优化单次请求处理速度更有效</strong></p><p>Chubby作为一个为大量Client提供服务的中心节点，并没有花过多的精力在优化单条请求路径上，而是努力地寻找可以减少Client与Master通信的机制：</p><ul><li><p>分散多个Cell负责不同地域的Client；</p></li><li><p>负载较重时，Master可以将Session的租约从12s最多延长到60s来减少通信频次；</p></li><li><p>通过Client的Cache缓存几乎所有需要的信息；</p></li><li><p>进一步的采用Proxy或Partition的方式。</p></li></ul><p><strong>3，限制资源的的线性增长</strong></p><p>论文中提到对Chubby使用资源情况的检查，包括RPC频率、磁盘空间、打开文件数等。任何可能随着用户数量或数据量的增加而线性增加的资源都应该有机制通过降级操作限制在一个合理的范围内，从而提供更加健壮的服务。负载较重时延长Session租约时间及存储配额的设置应该就是这方面的努力。</p><blockquote><p>Any linear growth must be mitigated by a compensating parameter that can be adjusted to reduce the load on Chubby to reasonable bounds</p></blockquote><p><strong>4，故障恢复时的数据恢复</strong></p><p>为了性能或负载，Master不可能将所有需要的信息全部通过一致性协议同步到所有副本。其内存维护的部分会在故障发生时丢失，新的Master必须能尽可能的恢复这些数据来让外部使用者尽量少的感知到故障的发生。恢复的数据来源方面，Chubby做了一个很好的范例：</p><ul><li>部分来源于持久化的一致性数据部分，这也是最主要的；</li><li>部分来源于客户端，如Handle会记录一些信息供新主读取并重新创建。论文中也提到在Chubby的进化中，这种方式也变得越来越重要；</li><li>部分来源于保守估计，如Session的Timeout。</li></ul><h5 id="Hypertable"><a href="#Hypertable" class="headerlink" title="Hypertable"></a>Hypertable</h5><p>Hypertable是一个开源的、高性能、可伸缩的数据库，采用和HBase非常相似的分布式模型，其目的是要构建一个针对分布式海量数据的高并发数据库</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211014144243838.png" alt="image-20211014144243838"></p><h6 id="Hypertable结构"><a href="#Hypertable结构" class="headerlink" title="Hypertable结构"></a>Hypertable结构</h6><p>Hypertable包括四部分核心组件：</p><ul><li><p>Hyperspace</p><p>最核心的组件，提供分布式锁服务的支持和元数据处理，是保证hypertable数据一致性的核心组件之一。另外还提供了高效的，可靠性的主机选举服务；</p></li><li><p>Range server</p><p>负责对外提供服务的组件单元，负责数据的读取与写入。将每个表按照主键进行切分，形成多个Ranger(类似关系型数据库中的分表)，每个Range由一个RangeServer（RangeServer调用DFS Broker来进行数据的读写）负责管理。在Hypertable中通常会部署多个RangeServer，每个RnageServer负责管理部分数据，由Master来负责RangeServer的集群管理；</p></li><li><p>Master</p><p>元数据管理中心，创建/删除表，或者其他表空间表更的所有的数据操作，同时负责RangeServer工作状态监测，一旦监测到其中某一个RangeServer被宕机或者服务出现了故障，Master会自动进行Range的重新分配，从而实现RangeServer的集群和RangeServer的负载均衡；</p></li><li><p>DFS broker</p><p>底层分布式文件系统的抽象层，起到一个承上启下的作用。上层Hypertable和底层文件存储。所有的对文件系统的对写操作，都是通过DFS Broker来完成的；</p></li></ul><h6 id="Hypertable集群选举策略"><a href="#Hypertable集群选举策略" class="headerlink" title="Hypertable集群选举策略"></a>Hypertable集群选举策略</h6><p>当Hyperspace集群中的active Server由于故障中断后，Hyperspace集群会进行重新的active选举。选举的策略是看BDB中记录的最新的一条事务日志，来保证Hyperspace服务是最新的一台Server，当选举出MasterServer之后，其他的Server会同步Master Server中的数据和状态，这样Hperspace重新进入正常的状态。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式数据一致性协议&lt;/p&gt;</summary>
    
    
    
    <category term="分布式框架" scheme="https://morningbells.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="paxos" scheme="https://morningbells.github.io/tags/paxos/"/>
    
    <category term="2PC" scheme="https://morningbells.github.io/tags/2PC/"/>
    
    <category term="3PC" scheme="https://morningbells.github.io/tags/3PC/"/>
    
    <category term="Chubby" scheme="https://morningbells.github.io/tags/Chubby/"/>
    
    <category term="Hypertable" scheme="https://morningbells.github.io/tags/Hypertable/"/>
    
  </entry>
  
  <entry>
    <title>Consul理解与总结</title>
    <link href="https://morningbells.github.io/2021/10/13/Consul%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://morningbells.github.io/2021/10/13/Consul%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-13T06:32:45.000Z</published>
    <updated>2021-11-17T08:31:07.691Z</updated>
    
    <content type="html"><![CDATA[<p>Consul理解总结</p><span id="more"></span><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>公司使用Consul作为服务发现与注册中心，所以对Consul进行一些总结。</p><p>Consul 是一种分布式、高可用性和数据中心感知解决方案，用于跨动态分布式基础架构连接和配置应用程序。和市面上其他框架相比Consul有这样几个特性。</p><ul><li><strong>服务发现</strong>- Consul 使服务可以简单地注册自己并通过 DNS 或 HTTP 接口发现其他服务。也可以注册 SaaS 提供商等外部服务。</li><li><strong>服务网格/服务分段</strong>- Consul Connect 通过自动 TLS 加密和基于身份的授权实现安全的服务到服务通信。应用程序可以在服务网格配置中使用 sidecar 代理来为入站和出站连接建立 TLS 连接，而完全不知道 Connect。</li><li><strong>健康检查</strong>- 健康检查使 Consul 能够快速提醒操作员有关集群中的任何问题。与服务发现的集成可防止将流量路由到不健康的主机并启用服务级别断路器。比如指定某个服务是否返回200 OK状态码，或者内存使用是否大于90%。</li><li><strong>键/值存储</strong>- 灵活的键/值存储可以存储动态配置、功能标记、协调、领导者选举等。简单的 HTTP API 使其易于在任何地方使用。</li><li><strong>多数据中心</strong>- Consul 构建为具有数据中心意识，无需复杂配置即可支持任意数量的区域。</li></ul><p>在一个完整调用过程中，consul起到的作用如下图：</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211013102058431.png" alt="image-20211013102058431"></p><h4 id="Consul的结构"><a href="#Consul的结构" class="headerlink" title="Consul的结构"></a>Consul的结构</h4><p>下面是consul官网给出来的一张架构图，我们先来理解一下：</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211013101941563.png" alt="image-20211013101941563"></p><p>从图片可知因为consul支持多数据中心，所以datacenter分为上下两个部分。两个部分通过集群的跟随者之间的WAN GOSSIP一致性协议和TCP/UDP传输协议进行同步。</p><p>再看上面部分的datacenter，存在server和client两种节点(因为所有节点都必须运行代理，所以他们统称代理节点)，Server节点负责保存数据，client节点负责健康检查和转发请求到Server。</p><p>集群内部的节点之间通过gossip协议（流言协议/传染病协议）维护成员关系。</p><p>集群内数据的读写请求可以发给client也可以发给server，不过最后都会到server的leader节点。如果不用强制保证读到的数据为最新数据，读请求也可以在server的普通跟随者节点读取。</p><h5 id="client客户端"><a href="#client客户端" class="headerlink" title="client客户端"></a>client客户端</h5><p>客户端的职责是将RPC请求传递给server服务端，客户端也负责集群的健康检查</p><h5 id="server服务端"><a href="#server服务端" class="headerlink" title="server服务端"></a>server服务端</h5><p>服务端包含一个Leader节点和若干个普通节点，Leader节点负责写入并同步数据给其他节点，其他节点支持读取功能(可能会有时延性)。Server的数量推荐是3个或者5个，在Leader挂掉的时候会启动选举机制产生一个新的Leader，选举机制使用的是Raft协议，参与选举的没有client节点。</p><p>server也会进行健康检查。</p><h5 id="dataCenter数据中心"><a href="#dataCenter数据中心" class="headerlink" title="dataCenter数据中心"></a>dataCenter数据中心</h5><p>个人理解一个主从集群可以认为是一个数据中心</p><h5 id="LAN-Gossip"><a href="#LAN-Gossip" class="headerlink" title="LAN Gossip"></a>LAN Gossip</h5><p>包含所有位于同一个局域网或者数据中心的所有节点</p><h5 id="WAN-Gossip"><a href="#WAN-Gossip" class="headerlink" title="WAN Gossip"></a>WAN Gossip</h5><p>只包含 Server。这些 server 指的是分布在不同的数据中心并且通常通过因特网或者广域网通信的server。</p><h5 id="Log-Replication"><a href="#Log-Replication" class="headerlink" title="Log Replication"></a>Log Replication</h5><p>上图会发现Leader节点会Replication其他普通节点，这样的用意是每个请求(写，读不确定)，不论是发到了client还是普通server最后都会同步给Leader节点，具体的步骤如下：</p><ol><li>每个客户端的请求都会被重定向给 leader，每一条请求都包含一条需要被复制状态机（replicated state machine）执行的命令。</li><li>leader 把这条命令加入到新的 log 条目中，同时向其他服务器发起 AppendEntries RPC ，要求其他 follower 同步这条 log。</li><li>follower 同步成功后返回给 leader 一条消息，如果 leader 收到超过 quorum 的 follower 的同步成功消息，leader 将会将这条 log 输入到状态机中，然后响应 client 成功。</li><li>如果 follower 宕机或是网络中断，leader 会无限重发 AppendEntries RPC（甚至在它向 client响应之后），直到所有的 follower 最终同步了 log。leader 通过强制 followers 复制它的 log 来处理不一致问题，follower 上的不一致的 log 会被 leader 的 log 所覆盖。</li></ol><h5 id="Raft选举协议"><a href="#Raft选举协议" class="headerlink" title="Raft选举协议"></a>Raft选举协议</h5><p>consul使用raft协议进行选举，Raft协议通过超时的概念来实现自动选举流程，每个普通的server都有心跳过期时间，如果Leader超出这个时间没发来心跳，此普通节点会将自己升级为候选者并尝试链接其他普通节点让他们选自己作为Leader</p><h5 id="Gossip一致性协议"><a href="#Gossip一致性协议" class="headerlink" title="Gossip一致性协议"></a>Gossip一致性协议</h5><p>传染病协议，正如其名，同步信息的做法是随机选择周围的几个节点散播消息，收到消息的节点也会这样继续散播下去，直到网络中所有的节点都同步完消息。</p><h6 id="Gossip在Consul中的应用"><a href="#Gossip在Consul中的应用" class="headerlink" title="Gossip在Consul中的应用"></a>Gossip在Consul中的应用</h6><ol><li><p>同一个dataCenter中，也叫做LAN GOSSIP：健康检查</p><p>所有的代理节点(client和server节点)都会参与，发现某个节点down掉后就会将其从集群剔除</p></li><li><p>不同的dataCenter中，也叫做WAN GOSSIP：信息同步</p><p>只有server节点参与(且是配置了网络通信能力的)，当一个数据中心变动了数据，会通过server传递给另外一个数据中心的server，随后由第二个datacenter的Leader去处理</p></li></ol><h6 id="Gossip的优点"><a href="#Gossip的优点" class="headerlink" title="Gossip的优点"></a>Gossip的优点</h6><ul><li>可以随意增加或者减少节点，有很强的拓展性</li><li>任意节点宕机或者重启都不会影响消息的传播</li><li>去中心化，所有节点都是平等的</li><li>速度快，一传十，十传百指数级别的增长</li></ul><h6 id="Gossip的缺点"><a href="#Gossip的缺点" class="headerlink" title="Gossip的缺点"></a>Gossip的缺点</h6><ul><li>消息延迟：Gossip是分多轮进行通知的，因此会不可避免的造成消息延迟</li><li>消息冗余：Gossip随机选择节点通知，因此不可避免会有重复通知的现象，导致冗余</li></ul><h4 id="Consul服务注册与服务发现"><a href="#Consul服务注册与服务发现" class="headerlink" title="Consul服务注册与服务发现"></a>Consul服务注册与服务发现</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211013140754347.png" alt="image-20211013140754347"></p><p>如上图是一个正常的 Consul 集群，在服务器 A、B、C上分别部署了Consul Server，并且选举了服务器 A上的 Consul Server 节点为 Leader，则服务注册与发现的步骤如下：</p><h5 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h5><p>Service A、B 分别在 服务器D 和 服务器E 上通过Consul Client 注册，服务注册到 Consul 可以通过 HTTP API（8500端口）的方式，也可以通过Consul 配置文件的方式。Consul Client 将注册信息通过 RPC 转发到Consul Server，由server的Leader转发，将服务信息保存在 Server 的各个节点中，并通过 Raft 实现强一致性</p><h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5><p>服务器F 中 Service C 需要访问Service A，这时 Service C 首先访问本机Consul Client 提供的 HTTP API（如果服务发现采用的是DNS方式，则Service C 直接使用 Service A 的服务发现域名，域名解析请求首先到达本机DNS代理，然后转发到本机 Consul Client），Consul Client 会将请求转发到 Consul Server。Consul Server 查询到 Service A 当前的信息返回，最终 Service C 拿到了Service A 所有实例部署的IP和端口，之后就可以选择向 Service A的一个实例发起请求了</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>consul的整个架构还是蛮好理解的，比较重要的是Gossip协议和Raft协议。</p><p>市面上也有一些其他的注册发现框架，比如说zk或者eureka，可以查阅这篇文章：<a href="https://morningbells.github.io/2021/10/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80-%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/#more">微服务分布式架构基础 摘录&amp;总结</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Consul理解总结&lt;/p&gt;</summary>
    
    
    
    <category term="分布式框架" scheme="https://morningbells.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="consul" scheme="https://morningbells.github.io/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>《SpringCloud微服务实战》摘录&amp;总结</title>
    <link href="https://morningbells.github.io/2021/10/13/%E3%80%8ASpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E3%80%8B%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/"/>
    <id>https://morningbells.github.io/2021/10/13/%E3%80%8ASpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E3%80%8B%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-12T16:03:03.000Z</published>
    <updated>2021-11-17T08:31:07.693Z</updated>
    
    <content type="html"><![CDATA[<p>《SpringCloud微服务实战》，读后感&amp;摘抄</p><span id="more"></span><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>会以<a href="https://morningbells.github.io/2021/10/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80-%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/">《微服务分布式架构基础 摘录&amp;总结》</a>为基础的去扩展学习本书</p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><table><thead><tr><th>组件名</th><th>组件作用</th></tr></thead><tbody><tr><td>Spring-cloud-Feign</td><td>声明式服务调用</td></tr><tr><td>Spring-cloud-Bus</td><td>消息总线</td></tr></tbody></table><p>此外也可以从其他公司开源的优秀框架中选型</p><ul><li>服务治理：阿里的Dubbo、Netflix的Eureka、Apache的Consul</li><li>分布式配置管理：百度的Disconf、Netflix的Archaius、360的 QConf、Spring Cloud的Config、淘宝的Diamond等</li><li>批量任务：当当网的Elastic-Job、LinkedIn的Azkaban、Spring Cloud的Task、xuxueli的xxl-job等</li><li>服务跟踪: 京东的Hydra、Spring Cloud的Sleuth、Twitter的 Zipkin等</li></ul><h4 id="springboot监控组件"><a href="#springboot监控组件" class="headerlink" title="springboot监控组件"></a>springboot监控组件</h4><h5 id="1-可以使用spring-boot-starter-actuator模块来做对应的监控"><a href="#1-可以使用spring-boot-starter-actuator模块来做对应的监控" class="headerlink" title="1. 可以使用spring-boot-starter-actuator模块来做对应的监控"></a>1. 可以使用spring-boot-starter-actuator模块来做对应的监控</h5><p>添加spring-boot-starter-actuator依赖，然后正常启动应用程序，Actuator会把它能收集到的所有信息都暴露给JMX。此外，Actuator还可以通过URL<code>/actuator/</code>挂载一些监控点。</p><p>Actuator默认把所有访问点暴露给JMX，但处于安全原因，只有<code>health</code>和<code>info</code>会暴露给Web。Actuator提供的所有访问点均在官方文档列出，要暴露更多的访问点给Web，需要在<code>application.yml</code>中加上配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: info, health, beans, env, metrics</span><br></pre></td></tr></table></figure><p>要特别注意暴露的URL的安全性，例如，<code>/actuator/env</code>可以获取当前机器的所有环境变量，不可暴露给公网。</p><p>有一些度量指标可以配合可视化框架直观观看</p><h4 id="Spring-cloud-Feign-声明式服务调用"><a href="#Spring-cloud-Feign-声明式服务调用" class="headerlink" title="Spring-cloud-Feign 声明式服务调用"></a>Spring-cloud-Feign 声明式服务调用</h4><p>整合了Ribbon和Hystrix，客户端通过调用接口的形式进行rpc调用</p><h5 id="Feign设置Ribbon负载均衡"><a href="#Feign设置Ribbon负载均衡" class="headerlink" title="Feign设置Ribbon负载均衡"></a>Feign设置Ribbon负载均衡</h5><ul><li><p>全局的负载均衡通过配置文件设置，和单独使用ribbon一样</p></li><li><p>针对接口个性化设置，通过@FeignClient注解中的name或value属性值来设置对应的Ribbon参数：</p><p>HELLO-SERVICE.ribbon.ConnectTimeout=500</p><p>HELLO-SERVICE.ribbon.ReadTimeout=2000</p><p>HELLOSERVICE.ribbon.MaxAutoRetries=1</p></li></ul><h5 id="Feign设置Hystix"><a href="#Feign设置Hystix" class="headerlink" title="Feign设置Hystix"></a>Feign设置Hystix</h5><ul><li>全局的熔断配置和单独使用Hystix一样</li><li>关闭熔断：feign.hystrix.enabled=false</li></ul><h4 id="Spring-Cloud-Ribbon负载均衡"><a href="#Spring-Cloud-Ribbon负载均衡" class="headerlink" title="Spring-Cloud Ribbon负载均衡"></a>Spring-Cloud Ribbon负载均衡</h4><h5 id="负载均衡常用算法"><a href="#负载均衡常用算法" class="headerlink" title="负载均衡常用算法"></a>负载均衡常用算法</h5><ol><li>随机算法：dubbo的负载均衡会加入权重概念</li><li>轮询算法：dubbo、Nginx的负载均衡会加入权重概念</li><li>最少连接数算法：所有机器一样的连接数，性能好的消费快</li><li>服务调用时延算法：根据平均响应时间计算所有服务的权重，响应时间越快的服务权重越大被选中的概率越大。刚启动时如果统计信息不足，可使用轮询策略，等统计信息足够，再切换到此算法</li><li>源 IP哈希算法：根据哈希环，尽量让同一个ip的请求发到同一台机器(复用缓存)</li></ol><h5 id="Ribbon源码结构"><a href="#Ribbon源码结构" class="headerlink" title="Ribbon源码结构"></a>Ribbon源码结构</h5><ul><li>BaseLoadBalancer：最基本的实现类，包含负载均衡的核心功能</li><li>IRule：负载均衡策略</li><li>IPing：判断服务是否还存活</li><li>LoadBalancerStats：记录负载均衡的实时运行信息</li><li>@LoadBalanced：修饰RestTemplate，实现负载均衡能力</li><li>LoadBalancerAutoConfiguration：LoadBalancer 的 自动配置类。在该类中，维护了一个被@LoadBalanced修饰的 RestTemplate对象的列表，在初始化的过程中，对目标 RestTemplate 增加拦截器 LoadBalancerlnterceptor</li></ul><h4 id="Spring-Cloud-Bus-消息总线"><a href="#Spring-Cloud-Bus-消息总线" class="headerlink" title="Spring-Cloud-Bus 消息总线"></a>Spring-Cloud-Bus 消息总线</h4><p>主要用来动态获取Spring-cloud-config的修改。如果没有消息总线，改了spring-cloud-config需要重启应用配置才会生效</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>spring-cloud-bus支持消息代理：rabbitMq和Kafka</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>和 《微服务分布式架构基础 摘录&amp;总结》大同小异，增加了Spring-cloud-Feign和Spring-Cloud-Bus相关的知识</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《SpringCloud微服务实战》，读后感&amp;amp;摘抄&lt;/p&gt;</summary>
    
    
    
    <category term="技术书籍摘录" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    <category term="分布式框架" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="微服务架构" scheme="https://morningbells.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    <category term="《SpringCloud微服务实战》" scheme="https://morningbells.github.io/tags/%E3%80%8ASpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>微服务分布式架构基础 摘录&amp;总结</title>
    <link href="https://morningbells.github.io/2021/10/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80-%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/"/>
    <id>https://morningbells.github.io/2021/10/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80-%E6%91%98%E5%BD%95-%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-12T09:19:38.000Z</published>
    <updated>2021-11-17T08:31:07.694Z</updated>
    
    <content type="html"><![CDATA[<p>《微服务分布式架构基础》，读后感&amp;摘抄</p><span id="more"></span><h2 id="《微服务分布式架构基础》摘录-amp-总结"><a href="#《微服务分布式架构基础》摘录-amp-总结" class="headerlink" title="《微服务分布式架构基础》摘录&amp;总结"></a>《微服务分布式架构基础》摘录&amp;总结</h2><h4 id="微服务架构体系"><a href="#微服务架构体系" class="headerlink" title="微服务架构体系"></a>微服务架构体系</h4><table><thead><tr><th>Spring-cloud-eureka(consul)</th><th>服务治理与发现</th></tr></thead><tbody><tr><td>Spring-cloud-Ribbon</td><td>loadBalance负载均衡</td></tr><tr><td>Spring-cloud-Hystrix</td><td>服务容错与熔断</td></tr><tr><td>Spring-cloud-Zuul</td><td>服务网关</td></tr><tr><td>Spring-Cloud-Config</td><td>服务配置中心</td></tr><tr><td>Spring-Cloud-Stream</td><td>事件驱动(消息中间件)</td></tr><tr><td>Spring-Cloud-Security</td><td>服务安全</td></tr><tr><td>Spring-Cloud-Sleuth</td><td>服务监控</td></tr><tr><td>Spring-Test</td><td>服务测试</td></tr><tr><td>Docker</td><td>服务部署</td></tr></tbody></table><h4 id="springboot监控组件"><a href="#springboot监控组件" class="headerlink" title="springboot监控组件"></a>springboot监控组件</h4><h5 id="1-基于springboot监控组件拓展"><a href="#1-基于springboot监控组件拓展" class="headerlink" title="1. 基于springboot监控组件拓展"></a>1. 基于springboot监控组件拓展</h5><p>“/health”是springboot自带的相关监控信息。可以通过实现Healthlndicator接口来重写”/health”所返回的结果。</p><h5 id="2-自定义SpringBoot监控端点"><a href="#2-自定义SpringBoot监控端点" class="headerlink" title="2. 自定义SpringBoot监控端点"></a>2. 自定义SpringBoot监控端点</h5><p>不想用默认监控端口，可以自定义端口，实现AbstractEndpoint即可</p><h4 id="Spring-Boot的-SpringBootApplication含义"><a href="#Spring-Boot的-SpringBootApplication含义" class="headerlink" title="Spring Boot的@SpringBootApplication含义"></a>Spring Boot的@SpringBootApplication含义</h4><p>由3个注解组成：</p><ul><li>@Configuration：代表启动类也是一个配置类</li><li>@ComponentScan：加载bean到容器里，默认是扫描启动类所在的包</li><li>@EnableAutoConfiguration：SpringFactoriesLoader通过SPI机制，去查找所有META-INF/spring.factories文件中的配置文件</li></ul><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011171940961.png" alt="image-20211011171940961"></p><h4 id="Spring-Cloud-Eureka实现服务发现与管理"><a href="#Spring-Cloud-Eureka实现服务发现与管理" class="headerlink" title="Spring-Cloud Eureka实现服务发现与管理"></a>Spring-Cloud Eureka实现服务发现与管理</h4><h5 id="Eureka和zookeeper和Consul的区别"><a href="#Eureka和zookeeper和Consul的区别" class="headerlink" title="Eureka和zookeeper和Consul的区别"></a>Eureka和zookeeper和Consul的区别</h5><table><thead><tr><th>区别点</th><th>Zookeeper</th><th>Eureka</th><th>Consul</th></tr></thead><tbody><tr><td>CAP指标</td><td>CP：一致性协议Paxos</td><td>AP: 高可用</td><td>CP：一致性协议raft</td></tr><tr><td>健康检查</td><td>定期发送连接心跳保持会话Session，Session有TTL</td><td>定期发送renew心跳，支持自定义HealthCheck，检测出不健康时自动更新状态，数据本身有TTL</td><td>Agent定期对服务进行HealthCheck, 支持HTTP/TCP/Docker，服务主动向Agent更新TTL</td></tr><tr><td>kv存储</td><td>支持，节点存储</td><td>不支持</td><td>支持，后台存储</td></tr><tr><td>watch机制</td><td>服务端推送给客户端。</td><td>客户端主动查询。支持使用long polling</td><td>客户端主动查询。支持使用long polling</td></tr><tr><td>自身监控</td><td>-</td><td>metrics</td><td>metrics</td></tr><tr><td>安全性</td><td>acl</td><td>-</td><td>acl /https</td></tr></tbody></table><ul><li>Paxos和Raft协议的区别(共识算法)：<ul><li>Basic Paxos：<ul><li>角色：消费者、提议者、投票并接受者</li><li>步骤：<ol><li>提议者提出一个提案，提案有唯一的编号，这个编号比所有之前的提案要大</li><li>投票并接受者校验这个提案编号，比自己之前遇到的编号都大则接受</li><li>如果多数投票接受者都接受了，提议者会发起第二步骤accept</li><li>如果投票接受者这段时间没有接收到比此提案编号更高的提案，则接受。否则忽略</li></ol></li><li>简单来说，第一阶段确认编号可用，第二阶段写入此提案。Paxos通过两轮交互，牺牲时间和性能弥补一致性的问题</li><li>活锁问题：(因为存在多个提议者)第一个提案确认了编号之后，第二个编号也被确认了，导致第一个提案不会被正式执行。第二个提案确认了之后，又来了第三个提案被确认，导致系统一直在确认而没有在写入。解决方法：在第一阶段发现编号被更新，提议者睡眠随机时间</li></ul></li><li>Multi Paxos：<ul><li>Basic Paxos存在一些问题：难实现、效率低（2 轮 rpc）、活锁。因此引入Multi Paxos，最大的变动是保留唯一一个提议者。也就是Leader概念</li><li>整合了Basic Paxos的步骤，因为只有一个leader，所以完全信任他的提案编号。所以不需要二段提交了。投票接受者收到提案和自己最大的提案编号比较，进行接受和忽略</li><li>引入的leader带来了新问题：怎么进行选举</li></ul></li><li>Raft：<ul><li>三个角色：跟随者、候选人、领导者</li><li>大致流程是：<ul><li>领导挂了(过了心跳超时时间)，会有一个跟随者变成候选者，然后发起选举投票，大部分机器同意后它会变成新的领导和集群同步心跳</li><li>如果同时有两个跟随者变成候选者，并且投票的时候拿到了相同票数(或者说都没过半的票数)，那么这两者会退回跟随者(并设置不同的超时时间)，所有机器再次刷新心跳时间转化为候选者</li><li>日志同步：客户端发起改动到leader，leader会在心跳的时候发给其他跟随者，大部分跟随者修改成功后leader会返回客户端成功</li><li>脑裂问题：如果出现两个leader，有少部分追随者的leader更改日志的时候会失败因为没有那么多追随者，大部分追随者的leader会成功(虽然少部分还是失败的)。如果这个时候两个leader回到一个集群，小部分的leader会比较提案编号自动回退成跟随者(少部分集群包括leader和跟随者会回滚未更改的日志)</li></ul></li></ul></li><li>ZAB和Raft的异同：<ul><li>相同点：<ul><li>都采用心跳检测存活性，都使用timeout来重新选择leader.</li><li>采用quorum来确定整个系统的一致性(也就是对某一个值的认可),这个quorum一般实现是集群中半数以上的服务器,zookeeper里还提供了带权重的quorum实现。需要在某个轮次内达成过半投票来结束选举过程</li><li>都由leader来发起写操作.</li><li>zookeeper的zab实现里选主要求选出来的主拥有quorum里最新的历史，而raft的follower的选主投票根据term的大小+日志完成度来选择投票给谁，这点上来看是比较类似的。</li><li>对分区都可以容忍，策略是对半即可。不过小部分没办法提供服务，即连接小部分集群的，都无法执行相关请求</li></ul></li><li>不同点：<ul><li>老leader掉线后重新上线：raft根据提案编号认定新leader，zab会重新进行一轮选举(有可能老leader带着大部分机器掉线后强势回归)</li><li>选举投票效率(方案)：<ul><li>raft每轮只投一次票，谁先通知自己就投谁，会导致出现几个候选者票数都没过半，解决方案是随机给超时时间然后再次等待超时</li><li>zk每轮可以投很多票，只要遇到更大zxid的就更新票数，zxid相同就比较配置的myid</li></ul></li><li>处理上一轮的残留数据<ul><li>Raft：对于之前term的过半或未过半复制的日志采取的是保守的策略，全部判定为未提交，只有当当前term的日志过半了，才会顺便将之前term的日志进行提交。 Raft看重强一致性</li><li>ZooKeeper：采取激进的策略，对于所有过半还是未过半的日志都判定为提交，都将其应用到状态机中。zk顺序一致性，最终一致性</li></ul></li></ul></li></ul></li></ul></li><li>健康检查做法<ul><li>zk：zab协议决定了cp，出现超时会无法和集群同步消息，网络恢复后会重新进行日志同步</li><li>consul：Raft协议-cp，网络恢复后会将历史的日志也补充同步到新节点</li><li>eureka：ap，出现网络波动各个机器仍可以继续服务，并不再尝试维护服务注册表中的数据(Eureka认为坏数据比没数据好，机器可能暂时不可用，但是尝试可能会成功)</li></ul></li><li>三者watcher机制的详细区别：<ul><li>zookeeper使用服务端推送给客户端的做法：会导致有一定的时延，zk的解决机制是保证时序性：客户端收到watcher通知之后才能看到最新的数据。<ul><li>zk的watcher是一次性触发的，改动了一次通知watcher之后再有改动就不会再通知</li><li>zk的watcher是服务端异步推送，而且具有延时性并且是一次性的，所以有可能数据变动了两次客户端才收到watcher，导致收到watcher再设置监听的时候出现消息丢失</li><li>因为是服务端推送，有可能会因为客户端消费不过来，导致服务端的消息堆积</li><li>优点是服务端与客户端建立长链接，有改动就推送。客户端只需要接受就好。而且虽然是有一定时延也是比较及时的(相对于客户端来查询)</li></ul></li><li>Eureka和Consul<ul><li>客户端主动的查询。查询到的是最新结果，正常的查询很不及时，所以采用长轮训查询</li><li>long polling：长轮训查询指的是如果服务端的数据没有变化会一直hold住，直到有变化了或者超时。返回之后客户端会立即发起第二次长轮训查询。</li><li>因为是客户端可控的主动查询最新结果。所以不存在服务端消息积压的情况</li><li>缺点是客户端需要处理查询和重发的逻辑</li></ul></li></ul></li><li>metrics：用来做应用级别的监控，获取到一些数据并支持将度量数据发送给Ganglia和Graphite以提供图形化的监控。</li><li>acl的区别：<ul><li>zk的acl维度<ul><li>权限模式: 所有人、ip区分、auth认证区分、用户名密码区分</li><li>授权对象：比如ip或者机器</li><li>权限（Permission）：CREATE、DELETE、READ、WRITE、ADMIN</li></ul></li><li>consul的acl维度(使用token)<ul><li>Agent的访问控制</li><li>Service服务注册/发现访问控制</li><li>KV访问控制</li></ul></li></ul></li></ul><h4 id="Spring-Cloud-Ribbon负载均衡"><a href="#Spring-Cloud-Ribbon负载均衡" class="headerlink" title="Spring-Cloud Ribbon负载均衡"></a>Spring-Cloud Ribbon负载均衡</h4><h5 id="负载均衡常用算法"><a href="#负载均衡常用算法" class="headerlink" title="负载均衡常用算法"></a>负载均衡常用算法</h5><ol><li>随机算法：dubbo的负载均衡会加入权重概念</li><li>轮询算法：dubbo、Nginx的负载均衡会加入权重概念</li><li>最少连接数算法：所有机器一样的连接数，性能好的消费快</li><li>服务调用时延算法：根据平均响应时间计算所有服务的权重，响应时间越快的服务权重越大被选中的概率越大。刚启动时如果统计信息不足，可使用轮询策略，等统计信息足够，再切换到此算法</li><li>源 IP哈希算法：根据哈希环，尽量让同一个ip的请求发到同一台机器(复用缓存)</li></ol><h5 id="Ribbon源码结构"><a href="#Ribbon源码结构" class="headerlink" title="Ribbon源码结构"></a>Ribbon源码结构</h5><ul><li>BaseLoadBalancer：最基本的实现类，包含负载均衡的核心功能</li><li>IRule：负载均衡策略</li><li>IPing：判断服务是否还存活</li><li>LoadBalancerStats：记录负载均衡的实时运行信息</li><li>@LoadBalanced：修饰RestTemplate，实现负载均衡能力</li><li>LoadBalancerAutoConfiguration：LoadBalancer 的 自动配置类。在该类中，维护了一个被@LoadBalanced修饰的 RestTemplate对象的列表，在初始化的过程中，对目标 RestTemplate 增加拦截器 LoadBalancerlnterceptor</li></ul><h4 id="Spring-Cloud-Hystrix-服务隔离与熔断与回退"><a href="#Spring-Cloud-Hystrix-服务隔离与熔断与回退" class="headerlink" title="Spring-Cloud-Hystrix 服务隔离与熔断与回退"></a>Spring-Cloud-Hystrix 服务隔离与熔断与回退</h4><p>服务熔断器会把所有的调用结果都记录下来，如果发生异常的调用次数达到一定的阔值，那 么服务熔断机制才会被触发，快速失败就会生效 ; 反之将按照正常的流程执行远程调用。</p><h5 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h5><p>服务隔离本质上是对服务系统或资源进行分割，从而实现当系统发生故障时能够限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，而保证其他服务仍然可用 。</p><p>Hystrix的服务隔离可以采用：线程池隔离和信号量隔离(HystrixThreadPoolProperties、HystrixCommand、HystrixCommandGroupKey)</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211012164128827.png" alt="image-20211012164128827"></p><h5 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h5><p>微服务架构中服务熔断器的用法：当某个异常条件被触发，直接熔断整个服务，而不是一直等到该服务超时。(HystrixCircuitBreaker、HystrixCommand)</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211012164258473.png" alt="image-20211012164258473"></p><h6 id="熔断器状态"><a href="#熔断器状态" class="headerlink" title="熔断器状态"></a>熔断器状态</h6><ul><li>Closed：熔断器关闭状态，不对服务调用进行限制，但会对调用失败次数进行积累，到达一定阔值或比例时会启动熔断机制</li><li>Open：熔断器打开状态，此时对服务的调用将直接返回错误，不执行真正的网络调用 。 同时，熔 断器设计了一个时钟选项，当时钟达到了一定时间(这个时间一般设置成平均故障处理时间， 也就是 MTTR )时会进入半熔断状态 。</li><li>Half- Open：半熔断状态，允许一定量的服务请求，如果调用都成功或达到一定比例则认为调用链路已 恢复 ，关闭熔断器;否则认为调用链路仍然存在问题，又回到熔断器打开状态 。</li></ul><h5 id="服务回退"><a href="#服务回退" class="headerlink" title="服务回退"></a>服务回退</h5><p>当 远程调用发生异常肘，服务回退不是直接抛出该异常，而是产生另外的处理机制来应对该异常，配合调用方的特殊逻辑完成回滚。</p><h4 id="Spring-Cloud-Zuul网关"><a href="#Spring-Cloud-Zuul网关" class="headerlink" title="Spring-Cloud-Zuul网关"></a>Spring-Cloud-Zuul网关</h4><h5 id="网关主要功能"><a href="#网关主要功能" class="headerlink" title="网关主要功能"></a>网关主要功能</h5><ul><li>业务路由支持</li><li>报文格式转换(统一响应码)</li><li>安全性控制</li><li>访问控制</li></ul><h5 id="Zuul的相关逻辑"><a href="#Zuul的相关逻辑" class="headerlink" title="Zuul的相关逻辑"></a>Zuul的相关逻辑</h5><ul><li>@EnableZuulProxy：嵌 入该注解的 Bootstrap类将自动成为 Zuul服务器的入口。是@ Enable ZuulServer的加强版</li><li>ZuulFilter：过滤器组</li><li>ProxyRequestHelper：准备服务调用参数工具类</li></ul><h4 id="Spring-Cloud-Config-配置中心"><a href="#Spring-Cloud-Config-配置中心" class="headerlink" title="Spring-Cloud-Config 配置中心"></a>Spring-Cloud-Config 配置中心</h4><p>将一些参数放在微服务中心进行管理，配合中央仓库(gitlab)使用</p><h5 id="Spring-Cloud-Config可以保护敏感信息"><a href="#Spring-Cloud-Config可以保护敏感信息" class="headerlink" title="Spring-Cloud-Config可以保护敏感信息"></a>Spring-Cloud-Config可以保护敏感信息</h5><p>Config服务器的加解密机制依赖于 JCE ( Java Cryptography Extension )组件</p><h4 id="Spring-Cloud-Stream与事件驱动"><a href="#Spring-Cloud-Stream与事件驱动" class="headerlink" title="Spring-Cloud-Stream与事件驱动"></a>Spring-Cloud-Stream与事件驱动</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211012165407877.png" alt="image-20211012165407877"></p><p>理解下来是解决异步的一种方案，可以使用mq代替。暂时不深入理解，后续了解响应式编程 spring Reactor时再做打算</p><h4 id="Spring-Cloud-Sleuth与服务监控"><a href="#Spring-Cloud-Sleuth与服务监控" class="headerlink" title="Spring-Cloud-Sleuth与服务监控"></a>Spring-Cloud-Sleuth与服务监控</h4><p>也可以使用jaeger或者skywalking做链路追踪</p><h5 id="分布式服务追踪-链路追踪"><a href="#分布式服务追踪-链路追踪" class="headerlink" title="分布式服务追踪(链路追踪)"></a>分布式服务追踪(链路追踪)</h5><ul><li>TraceId：跟踪id，通过这个id可以串起整个调用链</li><li>SpanId：跨度id，当请求到达各个服务组件 时，通过SpanId来标识它的开始、 具体执行过程和结束。 对于每个Span而言，它必须有开始 和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳统计该 Span 的时间延迟 。</li></ul><p>Sleuth需要和Zipkin配合使用</p><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><h5 id="测试dao层可以使用-DataJpaTest"><a href="#测试dao层可以使用-DataJpaTest" class="headerlink" title="测试dao层可以使用@DataJpaTest"></a>测试dao层可以使用@DataJpaTest</h5><h5 id="契约测试：消费者驱动的契约测试"><a href="#契约测试：消费者驱动的契约测试" class="headerlink" title="契约测试：消费者驱动的契约测试"></a>契约测试：消费者驱动的契约测试</h5><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人理解这本书主要解决的是高可用：</p><ul><li>某些节点down了不能影响其他节点(注册中心)</li><li>某些分支功能有问题不能影响其他功能(mq解耦)</li><li>为了性能放弃一些边缘功能(熔断)</li></ul><p>也包含了现实遇到的一些运维问题：链路追踪，分布式配置中心，监控等等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《微服务分布式架构基础》，读后感&amp;amp;摘抄&lt;/p&gt;</summary>
    
    
    
    <category term="技术书籍摘录" scheme="https://morningbells.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    
    <category term="微服务架构" scheme="https://morningbells.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    <category term="《微服务分布式架构基础》" scheme="https://morningbells.github.io/tags/%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴架构分析</title>
    <link href="https://morningbells.github.io/2021/10/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://morningbells.github.io/2021/10/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</id>
    <published>2021-10-08T09:44:35.000Z</published>
    <updated>2021-11-17T08:31:07.696Z</updated>
    
    <content type="html"><![CDATA[<p>分析阿里巴巴的架构，与后台的概念</p><span id="more"></span><h2 id="阿里巴巴架构分析"><a href="#阿里巴巴架构分析" class="headerlink" title="阿里巴巴架构分析"></a>阿里巴巴架构分析</h2><h4 id="SOA本质"><a href="#SOA本质" class="headerlink" title="SOA本质"></a>SOA本质</h4><p>SOA指的是面向服务架构，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</p><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><h6 id="阿里巴巴集团业务"><a href="#阿里巴巴集团业务" class="headerlink" title="阿里巴巴集团业务"></a>阿里巴巴集团业务</h6><ul><li>1688</li><li>淘宝</li><li>天猫</li><li>聚划算</li><li>等等</li></ul><h6 id="共享事务业务部-大中台"><a href="#共享事务业务部-大中台" class="headerlink" title="共享事务业务部(大中台)"></a>共享事务业务部(大中台)</h6><ul><li>用户中心</li><li>商品中心</li><li>交易中心</li><li>评价中心</li><li>店铺中心</li><li>搜索中心</li><li>数据服务中心</li><li>营销中心</li></ul><h6 id="分布式应用服务平台"><a href="#分布式应用服务平台" class="headerlink" title="分布式应用服务平台"></a>分布式应用服务平台</h6><ul><li>集群部署</li><li>分布式应用服务平台</li><li>弹性计算服务ECS</li><li>关系型数据库服务</li><li>开放存储服务OSS</li><li>消息服务MQ</li><li>开放缓存服务</li><li>开放数据处理服务</li><li>分布式文件系统</li><li>任务调度</li><li>远程过程调用</li><li>安全管理</li><li>分布式协同服务</li><li>资源管理</li><li>集群监控</li></ul><h6 id="运维保障部"><a href="#运维保障部" class="headerlink" title="运维保障部"></a>运维保障部</h6><ul><li>监控报警</li><li>故障处理</li><li>系统升级</li><li>应用发布</li><li>安全防控</li><li>业务监控</li></ul><h4 id="海量日志分布式处理平台-可以使用Disputor框架-ElasticSearch"><a href="#海量日志分布式处理平台-可以使用Disputor框架-ElasticSearch" class="headerlink" title="海量日志分布式处理平台(可以使用Disputor框架+ElasticSearch)"></a>海量日志分布式处理平台(可以使用Disputor框架+ElasticSearch)</h4><h4 id="监控平台"><a href="#监控平台" class="headerlink" title="监控平台"></a>监控平台</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;分析阿里巴巴的架构，与后台的概念&lt;/p&gt;</summary>
    
    
    
    <category term="架构分析" scheme="https://morningbells.github.io/categories/%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    
    
    <category term="中台" scheme="https://morningbells.github.io/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>日本蜡烛图-读后感&amp;摘录</title>
    <link href="https://morningbells.github.io/2021/10/08/%E6%97%A5%E6%9C%AC%E8%9C%A1%E7%83%9B%E5%9B%BE-%E8%AF%BB%E5%90%8E%E6%84%9F-%E6%91%98%E5%BD%95/"/>
    <id>https://morningbells.github.io/2021/10/08/%E6%97%A5%E6%9C%AC%E8%9C%A1%E7%83%9B%E5%9B%BE-%E8%AF%BB%E5%90%8E%E6%84%9F-%E6%91%98%E5%BD%95/</id>
    <published>2021-10-08T07:41:38.000Z</published>
    <updated>2021-11-17T08:31:07.696Z</updated>
    
    <content type="html"><![CDATA[<p>《日本蜡烛图技术新解》摘录</p><span id="more"></span><h2 id="蜡烛图的结构"><a href="#蜡烛图的结构" class="headerlink" title="蜡烛图的结构"></a>蜡烛图的结构</h2><p>蜡烛图一般由七个部分组成：开盘价、收盘价、最低价、最高价、上影线、下影线、实体。</p><p>收盘价低于开盘价时，说明跌了，蜡烛图为黑色(国内为绿色)。</p><p>收盘价高于开盘价时，说明涨了。蜡烛图为白色(国内为红色)。</p><p>![image-20211007103317578](/Users/wangyi/Library/Application Support/typora-user-images/image-20211007103317578.png)</p><p>![image-20211007103353617](/Users/wangyi/Library/Application Support/typora-user-images/image-20211007103353617.png)</p><h4 id="长白实体"><a href="#长白实体" class="headerlink" title="长白实体"></a>长白实体</h4><p>指的是收盘价明显高于开盘价的图，一般长度是前一天的3倍可以称为长白实体。</p><h6 id="低价区的长白实体"><a href="#低价区的长白实体" class="headerlink" title="低价区的长白实体"></a>低价区的长白实体</h6><p>低价出现的长白实体，可能是多头强势的信号。不过如果空头依然强势，可能会再出现一条长黑实体来抗衡。</p><h6 id="强势的长白实体"><a href="#强势的长白实体" class="headerlink" title="强势的长白实体"></a>强势的长白实体</h6><p>以最低价开盘，以最高价收盘(也就是说，也就是说没有上下影线)。表明了多头强势和空头疲弱</p><h6 id="长白实体的支撑"><a href="#长白实体的支撑" class="headerlink" title="长白实体的支撑"></a>长白实体的支撑</h6><p>比较玄学的会觉得，长白实体有支撑作用。跌到长白实体的50%位置和底部位置，一般会反弹。长白实体顶部也可以看做是支撑。</p><h6 id="怎么利用长白实体买入"><a href="#怎么利用长白实体买入" class="headerlink" title="怎么利用长白实体买入"></a>怎么利用长白实体买入</h6><p>一般来说，出现长白实体之后因为超卖现象会被市场打压，出现修正的情况。所以可以将长白实体的最顶部，50%和最底部最为三个买入的支撑点，分次建仓。(至于具体以哪几个值作为支撑点可以再去统计。因为存在下影线)</p><p>如果价格不是很低的时候(甚至是在抬升阶段)，不能把它作为一个买入的入场时机。因为有可能会存在乌云盖顶的场景</p><h4 id="长黑实体"><a href="#长黑实体" class="headerlink" title="长黑实体"></a>长黑实体</h4><p>和长白实体相反，不过出现长黑实体就表明空头力量强势，需要认真考虑怎么出局了</p><h6 id="高价区的长黑实体"><a href="#高价区的长黑实体" class="headerlink" title="高价区的长黑实体"></a>高价区的长黑实体</h6><p>高价区如果出现长黑实体有可能是顶部的信号(长黑实体只要明显高于此前的几根实体，就需要留意它是不是要转折了)。需要考虑出手卖出了，可以选择动态止盈法，或者先收回自己的成本</p><h6 id="长黑实体的阻力-压力"><a href="#长黑实体的阻力-压力" class="headerlink" title="长黑实体的阻力(压力)"></a>长黑实体的阻力(压力)</h6><p>一般来说，出现长黑实体，说明多头大规模撤出了。出现了长黑实体后，如果上涨也不太会突破长黑实体的高度</p><h4 id="开盘价的作用-比较激进做短线的时候，可以参考"><a href="#开盘价的作用-比较激进做短线的时候，可以参考" class="headerlink" title="开盘价的作用(比较激进做短线的时候，可以参考)"></a>开盘价的作用(比较激进做短线的时候，可以参考)</h4><p>开盘价在前一根白线的一半以下，呈现空头趋势。</p><p>开盘价在前一根黑线的一半以上，呈现多头趋势。</p><h4 id="纺锤体"><a href="#纺锤体" class="headerlink" title="纺锤体"></a>纺锤体</h4><p>实体很小的蜡烛图也叫纺锤体，代表盘势上下两难，市场喘息困难。(不管上下影线长不长)</p><p>出现纺锤体代表：市场正在丧失动能。</p><p>如果纺锤体出现在新高点，代表的是多头的上升力量难以维持，可能会反转</p><h4 id="筹码集聚与派发-蜡烛图配合成交量"><a href="#筹码集聚与派发-蜡烛图配合成交量" class="headerlink" title="筹码集聚与派发(蜡烛图配合成交量)"></a>筹码集聚与派发(蜡烛图配合成交量)</h4><h6 id="筹码聚集"><a href="#筹码聚集" class="headerlink" title="筹码聚集:"></a>筹码聚集:</h6><p>低价区：成交量放大而价格呆滞。多头低价扫货，空头停止打压</p><h6 id="地价："><a href="#地价：" class="headerlink" title="地价："></a>地价：</h6><p>低价区，成交量很少，价格也很呆滞。说明筹码都在多头手里，在等待时机。地量见地价</p><h6 id="筹码派发"><a href="#筹码派发" class="headerlink" title="筹码派发"></a>筹码派发</h6><p>高价区：成交量大而价格呆滞。主力出货，接盘侠站岗。天量见天价</p><h4 id="十字星"><a href="#十字星" class="headerlink" title="十字星"></a>十字星</h4><p>开盘价和收盘价几乎相等，但是上影线和下影线很长。</p><p>代表了空头和多头厮杀的厉害，市场举棋不定。不过如果发生在成熟的阶段，可以看成是一个变盘的征兆。</p><h4 id="上下影线"><a href="#上下影线" class="headerlink" title="上下影线"></a>上下影线</h4><p>长长的上影线代表了，高位买入的盘不断”蒸发”，可能是主力在出货了</p><p>长长的下影线代表了，不断有人抄底买入，多头没有力量控盘了</p><h6 id="高浪线"><a href="#高浪线" class="headerlink" title="高浪线"></a>高浪线</h6><p>上影线和下影线都很长的蜡烛图叫做高浪线。</p><p>高浪线代表了多头和空头在对峙，可以看成是要转折了的征兆。</p><h2 id="蜡烛图的组合形态"><a href="#蜡烛图的组合形态" class="headerlink" title="蜡烛图的组合形态"></a>蜡烛图的组合形态</h2><h3 id="单根蜡烛图"><a href="#单根蜡烛图" class="headerlink" title="单根蜡烛图"></a>单根蜡烛图</h3><h4 id="锤子线"><a href="#锤子线" class="headerlink" title="锤子线"></a>锤子线</h4><p>锤子线指的是大幅下跌场景下，下影线很长，收盘价位于或者接近高点。利多</p><p>锤子线代表空头后劲不足，很大可能发生反转。</p><p>锤子线的50%点和最底部可以看做是支撑点</p><h4 id="流星线"><a href="#流星线" class="headerlink" title="流星线"></a>流星线</h4><p>流星线指的是在大幅上涨的场景下，上影线很长。利空，和锤子线刚好相反。</p><h4 id="吊颈线"><a href="#吊颈线" class="headerlink" title="吊颈线"></a>吊颈线</h4><p>吊颈线指的是不在上升或者下降走势下，下影线很长，上影线基本上不存在。实体可能是白的，可能是黑的。</p><p>我理解下来没什么意义，不能代表空还是多</p><h3 id="双蜡烛线所构成的形态"><a href="#双蜡烛线所构成的形态" class="headerlink" title="双蜡烛线所构成的形态"></a>双蜡烛线所构成的形态</h3><p>如果看的k线不只是一天的，那么需要考虑到多天之间蜡烛图的合成，要具体场景下去分析。</p><p>日k可以用来判断大趋势是怎么样的，分时线可以用来做短线，判断短期趋势。</p><h4 id="乌云盖顶"><a href="#乌云盖顶" class="headerlink" title="乌云盖顶"></a>乌云盖顶</h4><p>第一天一根长白实体，但第二个交易日高开低走，跌破长白实体的收盘价(或者中线)，两天的蜡烛图合到一起会形成一个上影线很长的流星线。</p><p>乌云盖顶表示卖压超过买盘的力量。要跌了</p><h4 id="穿刺形态"><a href="#穿刺形态" class="headerlink" title="穿刺形态"></a>穿刺形态</h4><p>穿刺形态和乌云盖顶相反。指的是第二个交易日低开高走，突破第一天长黑实体的收盘价或者中线，两天的蜡烛图合道一起会形成一个下影线很长的锤子线。</p><p>如果在低价区，显示了市场下行能量耗尽。</p><p>第二根白线开盘越低，但切入第一根越深，信号越积极。</p><h3 id="窗口-也称：脱节蜡烛线"><a href="#窗口-也称：脱节蜡烛线" class="headerlink" title="窗口(也称：脱节蜡烛线)"></a>窗口(也称：脱节蜡烛线)</h3><p>上升窗口：今天蜡烛线低点比前一天的最高点还高。</p><p>下降窗口：今天蜡烛线高点比前一天的最低点还低。</p><p>窗口代表行情会继续。上升窗口代表多头持续，下降窗口代表空头持续</p><h6 id="双黑跳空"><a href="#双黑跳空" class="headerlink" title="双黑跳空"></a>双黑跳空</h6><p>比较容易理解，下降窗口后面跟着两个黑色实体，表示”多头陷入溃败”</p><h3 id="三根或者三根以上蜡烛线构成的形态"><a href="#三根或者三根以上蜡烛线构成的形态" class="headerlink" title="三根或者三根以上蜡烛线构成的形态"></a>三根或者三根以上蜡烛线构成的形态</h3><h4 id="黄昏星"><a href="#黄昏星" class="headerlink" title="黄昏星"></a>黄昏星</h4><p>黄昏星由三个蜡烛图组成，第一根蜡烛图是长白实体，第二根可白可黑但是不能触及第一根的实体，第三根是黑的不能触及第二天的实体但是要切入第一天的实体。如下图所示，三天的蜡烛图合在一起是一个上影线很长的流星线。</p><p>如果第二天是十字星，那么三天合起来叫做黄昏十字星。</p><p>黄昏星或者黄昏十字星，代表了空头占领大局，要跌了。</p><p>第三天之后还有可能会回调，黄昏星可以参考第二天实体的最高点作为卖出的阻力值。</p><p>![image-20211008142637760](/Users/wangyi/Library/Application Support/typora-user-images/image-20211008142637760.png)</p><h4 id="启明星"><a href="#启明星" class="headerlink" title="启明星"></a>启明星</h4><p>启明星和黄昏星有点相反的感觉。</p><p>启明星也由三个蜡烛图组成，第一根蜡烛图是长黑实体，第二根可白可黑但是不能触及第一根的实体，第三根是白的不能触及第二天的实体但是要切入第一天的实体。如下图所示，三天的蜡烛图合在一起是一个下影线很长的锤子线。</p><p>如果第二天是十字星，那么三天合起来叫做启明十字星。</p><p>启明星或者启明十字星，代表了多头占领大局，要涨了。</p><p>第三天之后还有可能会回调，启明星可以参考第二天实体的最低点作为买入的阻力值。</p><p>![image-20211008143642402](/Users/wangyi/Library/Application Support/typora-user-images/image-20211008143642402.png)</p><h4 id="迭创新高-低"><a href="#迭创新高-低" class="headerlink" title="迭创新高(低)"></a>迭创新高(低)</h4><p>迭创新高(低)需要看多根蜡烛，数十根。</p><p>在行情上行时，如果出现了8<del>10根新高蜡烛线，需要暂停买入考虑卖出。这8</del>10根蜡烛线需要有一定连续性的，不一定要每根之间连续，一般两个新高之间不应该超过两根到三根蜡烛线，并且不应该出现很强劲的下行长黑体。</p><p>在行情下行时，出现了8~10根新低蜡烛线，需要考虑进货。</p><h2 id="股市中的策略"><a href="#股市中的策略" class="headerlink" title="股市中的策略"></a>股市中的策略</h2><h3 id="止损"><a href="#止损" class="headerlink" title="止损"></a>止损</h3><p>设定一个兜底的点，承认自己判断失败，这个位置就是自己的止损点，到了这个点就出手</p><h3 id="风险与收益的权衡"><a href="#风险与收益的权衡" class="headerlink" title="风险与收益的权衡"></a>风险与收益的权衡</h3><p>设置目标价位，根据一些支撑点、日均平均点之类的指标左侧出售，或者根据动态止盈法右侧出售</p><h2 id="移动平均线"><a href="#移动平均线" class="headerlink" title="移动平均线"></a>移动平均线</h2><p>平均线可以帮助找出支撑点。</p><h4 id="黄金交叉与死亡交叉"><a href="#黄金交叉与死亡交叉" class="headerlink" title="黄金交叉与死亡交叉"></a>黄金交叉与死亡交叉</h4><p>以13周平均线和26周平均线为例(做长线，做短线喜欢用5天或者9天或者25天的平均线)。</p><p>看法很简单：</p><p>死亡交叉：如果13周曲线向下而26周的平均线曲线向上，代表了最近13周卖的比例很高，构成了空头信号。要考虑出手了。</p><p>黄金交叉：如果13周曲线向上而26周的平均线向下，代表了最近13周买入的比例很高，构成多头信号。要考虑上车了</p><h4 id="差异指数，差异比率"><a href="#差异指数，差异比率" class="headerlink" title="差异指数，差异比率"></a>差异指数，差异比率</h4><p>算法：(收盘价-移动平均值)/移动平均值</p><h4 id="偏离指数"><a href="#偏离指数" class="headerlink" title="偏离指数"></a>偏离指数</h4><h2 id="三线反向突破图"><a href="#三线反向突破图" class="headerlink" title="三线反向突破图"></a>三线反向突破图</h2><h2 id="砖形图"><a href="#砖形图" class="headerlink" title="砖形图"></a>砖形图</h2><h2 id="钥匙图"><a href="#钥匙图" class="headerlink" title="钥匙图"></a>钥匙图</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;《日本蜡烛图技术新解》摘录&lt;/p&gt;</summary>
    
    
    
    <category term="股票学习" scheme="https://morningbells.github.io/categories/%E8%82%A1%E7%A5%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="投资学习" scheme="https://morningbells.github.io/categories/%E8%82%A1%E7%A5%A8%E5%AD%A6%E4%B9%A0/%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="书籍摘录" scheme="https://morningbells.github.io/tags/%E4%B9%A6%E7%B1%8D%E6%91%98%E5%BD%95/"/>
    
    <category term="《日本蜡烛图技术新解》" scheme="https://morningbells.github.io/tags/%E3%80%8A%E6%97%A5%E6%9C%AC%E8%9C%A1%E7%83%9B%E5%9B%BE%E6%8A%80%E6%9C%AF%E6%96%B0%E8%A7%A3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper总结整理</title>
    <link href="https://morningbells.github.io/2021/10/08/zookeeper%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86/"/>
    <id>https://morningbells.github.io/2021/10/08/zookeeper%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86/</id>
    <published>2021-10-08T02:50:03.000Z</published>
    <updated>2021-11-17T08:31:07.693Z</updated>
    
    <content type="html"><![CDATA[<p>总结zookeeper框架相关概念，《从Paxos到Zookeeper》的读书笔记</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Zookeeper是一个开源的分布式协调服务，是Google的Chubby的开源实现。</p><p>Zookeeper的设计目标是将复杂且容易出错的分布式一致性服务封装起来，并以一系列简单易用的接口提供给用户使用。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h4><ul><li>Leader：为客户端提供读和写功能</li><li>Follower：提供读功能，参与Leader选举，参与写操作的过半成功策略</li><li>Observer：提供读功能，不参与Leader选举，不参与写操作的过半成功策略</li></ul><h4 id="会话Session"><a href="#会话Session" class="headerlink" title="会话Session"></a>会话Session</h4><p>Session指的是客户端会话，客户端连接上zk集群后会建立一个TCP长链接。通过这个长链接，客户端可以接收到集群的心跳检查。</p><p>Session可以定义Sessiontimeout时间，如果网络波动在超时时间内重连上，会话仍然有效。否则会话会失效–&gt;会导致临时节点被自动删除</p><h4 id="数据节点：Znode"><a href="#数据节点：Znode" class="headerlink" title="数据节点：Znode"></a>数据节点：Znode</h4><p>数据节点分为持久节点和临时节点</p><p>持久节点除非被主动移除会一直存在的</p><p>临时节点和会话绑定，会话结束会自动被清理掉</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>每个节点Znode会存储版本数据存储在stat数据结构里，分别是version(znode版本)，cversion(子znode版本)，aversion(znode的acl版本)</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>监听机制。客户端监听感兴趣的节点，特定事件发生后触发</p><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>权限控制。</p><ul><li>CREATE，创建子节点</li><li>READ，读取当前节点数据和子节点列表</li><li>WRITE，更新节点数据</li><li>DELETE，删除子节点</li><li>ADMIN，全部权限</li></ul><h4 id="其他基本概念"><a href="#其他基本概念" class="headerlink" title="其他基本概念"></a>其他基本概念</h4><ul><li>集群leader选举</li><li>zab协议</li><li>脑裂现象</li><li>Paxo算法协议机制</li><li>数据发布/订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调、通知</li><li>集群管理</li><li>分布式锁</li><li>分布式队列</li><li>顺序访问(zxid)</li></ul><h3 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h3><p>ZAB协议包含两个基本模式：消息广播和奔溃恢复。</p><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>zk集群是cp的，需要有个中心化的节点来和其他节点进行同步，zk里称其为Leader节点。</p><p>Leader要做的事情很简单：</p><ol><li>来消息时和所有跟随节点同步</li><li>超过一半的节点没有确认消息时将确认的那一小部分回滚掉</li></ol><p>理解下来就是一个分布式事务，要么都成功要么失败都回滚。zk的做法也很简单，类似于2pc的二阶段提交，leader同步数据的时候第一步发送给各个follower，各个follower以事务日志的形式写入到本地磁盘，并给leader ack响应，第二阶段leader进行同步或者回滚。</p><p>此外，ZAB协议需要保证事务的有序性。所有抽出来一个zxid的概念，zxid64位分成两半，前32位代表重新选举的轮次，后32位代表的就是同步消息的轮次。zxid是全局单调递增的。</p><h4 id="奔溃恢复"><a href="#奔溃恢复" class="headerlink" title="奔溃恢复"></a>奔溃恢复</h4><p>当leader宕机或者网络波动导致心跳超时导致和一半以上的follower断联了，那么就会进入崩溃恢复阶段，重新进行leader选举。leader选举有两个要解决的问题。</p><ol><li>需要确保已经被任意节点确认的消息最终被所有节点接受</li><li>旧leader还没发出来确认的消息全部需要回滚掉</li></ol><p>其实难点就是需要在所有节点中找到一个消息最新的节点并任命它为新领导，新领导上任先把上一届有构思但是没付诸行动的事件忽略掉。zk天生是有序的，所以这两个问题可以根据zxid去解决，根据zxid选举出新领导，然后zxid前32位+1，后32位清零。</p><h4 id="ZAB的脑裂"><a href="#ZAB的脑裂" class="headerlink" title="ZAB的脑裂"></a>ZAB的脑裂</h4><h5 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h5><p>当一个集群的不同部分在同一时间都认为自己是活动的时候，我们就可以将这个现象称为脑裂症状。通俗的说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p><p>UserA和UserB分别将自己的信息注册在RouterA和RouterB中。RouterA和RouterB使用数据同步（2PC），来同步信息。那么当UserA想要向UserB发送一个消息的时候，需要现在RouterA中查询出UserA到UserB的消息路由路径，然后再交付给相应的路径进行路由。</p><p>当脑裂发生的时候，相当RouterA和RouterB直接的联系丢失了，RouterA认为整个系统中只有它一个Router，RouterB也是这样认为的。那么相当于RouterA中没有UserB的信息，RouterB中没有UserA的信息了，此时UserA再发送消息给UserB的时候，RouterA会认为UserB已经离线了，然后将该信息进行离线持久化，这样整个网络的路由是不是就乱掉了。</p><p>对于Zookeeper来说有一个很重要的问题，就是到底是根据一个什么样的情况来判断一个节点死亡down掉了。 在分布式系统中这些都是有监控者来判断的，但是监控者也很难判定其他的节点的状态，唯一一个可靠的途径就是心跳，Zookeeper也是使用心跳来判断客户端是否仍然活着，但是使用心跳机制来判断节点的存活状态也带来了假死问题。</p><h5 id="假死"><a href="#假死" class="headerlink" title="假死"></a>假死</h5><p>ZooKeeper每个节点都尝试注册一个象征master的临时节点，其他没有注册成功的则成为slaver，并且通过watch机制监控着master所创建的临时节点，Zookeeper通过内部心跳机制来确定master的状态，一旦master出现意外Zookeeper能很快获悉并且通知其他的slaver，其他slaver在之后作出相关反应。这样就完成了一个切换。</p><p>这种模式也是比较通用的模式，基本大部分都是这样实现的，但是这里面有个很严重的问题，如果注意不到会导致短暂的时间内系统出现脑裂，因为心跳出现超时可能是master挂了，但是也可能是master，zookeeper之间网络出现了问题，也同样可能导致。这种情况就是假死，master并未死掉，但是与ZooKeeper之间的网络出现问题导致Zookeeper认为其挂掉了然后通知其他节点进行切换，这样slaver中就有一个成为了master，但是原本的master并未死掉，这时候client也获得master切换的消息，但是仍然会有一些延时，zookeeper需要通讯需要一个一个通知，这时候整个系统就很混乱可能有一部分client已经通知到了连接到新的master上去了，有的client仍然连接在老的master上如果同时有两个client需要对master的同一个数据更新并且刚好这两个client此刻分别连接在新老的master上，就会出现很严重问题。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>总结一下脑裂和假死</p><p>假死：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着。<br>脑裂：由于假死会发起新的master选举，选举出一个新的master，但旧的master网络又通了，导致出现了两个master ，有的客户端连接到老的master 有的客户端链接到新的master。</p><p>想要解决脑裂问题，一般会有两种方法</p><ol><li>Quorums（ˈkwôrəm 法定人数） ：比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的</li><li>Redundant communications：冗余通信的方式，集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。<br>Fencing, 共享资源的方式：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中。</li></ol><p>ZooKeeper默认采用了Quorums这种方式，即只有集群中超过半数节点投票才能选举出Leader。这样的方式可以确保leader的唯一性,要么选出唯一的一个leader,要么选举失败。在ZooKeeper中Quorums有2个作用：</p><ul><li>集群中最少的节点数用来选举Leader保证集群可用：通知客户端数据已经安全保存前集群中最少数量的节点数已经保存了该数据。一旦这些节点保存了该数据，客户端将被通知已经安全保存了，可以继续其他任务。而集群中剩余的节点将会最终也保存了该数据。<br>假设某个leader假死，其余的followers选举出了一个新的leader。这时，旧的leader复活并且仍然认为自己是leader，这个时候它向其他followers发出写请求也是会被拒绝的。因为每当新leader产生时，会生成一个epoch，这个epoch是递增的，followers如果确认了新的leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。那有没有follower不知道新的leader存在呢，有可能，但肯定不是大多数，否则新leader无法产生。</li><li>Zookeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是leader，依然没有什么作用。</li></ul><p>总结一下就是，通过Quorums机制来防止脑裂和假死，当leader挂掉之后，可以重新选举出新的leader节点使整个集群达成一致；当出现假死现象时，通过epoch大小来拒绝旧的leader发起的请求，在前面也已经讲到过，这个时候，重新恢复通信的老的leader节点会进入恢复模式，与新的leader节点做数据同步，perfect。</p><h4 id="ZAB和Paxos算法的联系与区别"><a href="#ZAB和Paxos算法的联系与区别" class="headerlink" title="ZAB和Paxos算法的联系与区别"></a>ZAB和Paxos算法的联系与区别</h4><p>zab协议是对Multi Paxos算法的改进，二者有很多类似 的地方</p><ul><li>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行</li><li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交</li><li>在ZAB协议中，每个Proposal中都包含一个epoch值，用来代表当前Leader周期，在Paxos算法中，同样类似标识Ballot</li></ul><h4 id="Paxo算法协议机制"><a href="#Paxo算法协议机制" class="headerlink" title="Paxo算法协议机制"></a>Paxo算法协议机制</h4><h6 id="prepare阶段"><a href="#prepare阶段" class="headerlink" title="prepare阶段"></a>prepare阶段</h6><ol><li><p>每个server向proposer发送消息，表示自己要当leader，假设proposer收到消息的时间不一样，顺序是： <code>proposer2 -&gt; proposer1 -&gt; proposer3</code>，消息编号依次为1、2、3。</p></li><li><p>proposer将消息发给acceptor中超过半数的子成员(这里选择两个)：</p><ul><li><p>proposer2向acceptor2和acceptor3发送编号为1的消息。</p></li><li><p>proposer1向acceptor1和accepto2发送编号为2的消息。</p></li><li><p>proposer3向acceptor2和acceptor3发送编号为3的消息。</p></li></ul></li></ol><ol start="3"><li><p>假设这时proposer1发送的消息先到达acceptor1和acceptor2，它们都没有接收过请求，所以接收该请求并返回【pok，null，null】给proposer1，同时acceptor1和acceptor2承诺不再接受编号小于2的请求；</p><ul><li>proposer2的消息到达acceptor2和acceptor3，acceptor3没有接受过请求，所以返回proposer2 【pok，null，null】，acceptor3并承诺不再接受编号小于1的消息。而acceptor2已经接受proposer1的请求并承诺不再接收编号小于2的请求，所以acceptor2拒绝proposer2的请求；</li></ul></li></ol><blockquote><p>最后，proposer3的消息到达acceptor2和acceptor3，它们都接受过提议，但编号3的消息大于acceptor2已接受的2和acceptor3已接受的1，所以他们都接受该提议，并返回proposer3 【pok，null，null】；</p></blockquote><blockquote><p>此时，proposer2没有收到过半的回复，所以重新取得编号4，并发送给acceptor2和acceptor3，此时编号4大于它们已接受的提案编号3，所以接受该提案，并返回proposer2 【pok，null，null】。</p></blockquote><h6 id="accept阶段"><a href="#accept阶段" class="headerlink" title="accept阶段"></a>accept阶段</h6><p>Proposer3收到半数以上（两个）的回复，并且返回的value为null，proposer3提交了【3，server3】的提案。<br>Proposer1也收到过半回复，返回的value为null，所以proposer1提交了【2，server1】的提案。</p><p>Proposer2也收到过半回复，返回的value为null，所以proposer2提交了【4，server2】的提案。</p><p>Acceptor1和acceptor2接收到proposer1的提案【2，server1】，acceptor1通过该请求，acceptor2承诺不再接受编号小于4的提案，所以拒绝；<br>Acceptor2和acceptor3接收到proposer2的提案【4，server2】，都通过该提案；<br>Acceptor2和acceptor3接收到proposer3的提案【3，server3】，它们都承诺不再接受编号小于4的提案，所以都拒绝。</p><blockquote><p>所以proposer1和proposer3会再次进入第一阶段，但这时候 Acceptor2和acceptor3已经通过了提案（AcceptN = 4，AcceptV=server2），并达成了多数，所以proposer会递增提案编号，并最终改变其值为server2。最后所有的proposer都肯定会达成一致，这就迅速的达成了一致。</p></blockquote><p>过半的acceptor（acceptor2和acceptor3）都接受了提案【4，server2】，learner感知到提案的通过，learner开始学习提案，所以server2成为最终的leader。</p><h3 id="Zookeeper技术内幕"><a href="#Zookeeper技术内幕" class="headerlink" title="Zookeeper技术内幕"></a>Zookeeper技术内幕</h3><h4 id="序列化与协议"><a href="#序列化与协议" class="headerlink" title="序列化与协议"></a>序列化与协议</h4><p>Zookeeper的客户端和服务端之间会进行一系列的网络通信以实现数据的传输。所以需要解决的就是对数据的序列化和反序列化处理。</p><p>在Zookeeper中，使用Jute这一序列化组件来进行数据的序列化和反序列化操作。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端主要由以下的几个核心组件组成。</p><ul><li>Zookeeper实例：客户端的入口</li><li>ClientWatchManager：客户端Watcher管理器</li><li>HostProvider：客户端地址列表管理器</li><li>ClientCnxn：客户端核心线程，其内部又包含了两个线程，即sendThread和EventThread。前者是一个I/O线程，主要负责Zookeeper客户端和服务端的网络I/O通信；后者是一个事件线程，主要负责对服务端事件进行处理</li></ul><h5 id="一次会话的创建过程"><a href="#一次会话的创建过程" class="headerlink" title="一次会话的创建过程"></a>一次会话的创建过程</h5><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><ol><li>初始化zk对象：通过调用Zookeeper对象的构造方法实例化对象，初始化过程会创建一个客户端的Watcher管理器：ClientWatchManager</li><li>设置会话默认Watcher：如果在构造方法中传入一个Watcher对象，会将这个对象作为默认Watcher保存在ClientWatchManger</li><li>构造Zookeeper服务器地址列表管理器HostProvider：对于构造方法中传入的服务器地址，客户端会将其放到服务器地址管理器HostProvider中</li><li>创建并初始化客户端网络连接器ClientCnxn：zk客户端会先创建一个网络连接器ClientCnxn，用来管理网络交互。另外，客户端在创建ClientCnxn时，还会初始化两个核心队列：outgoingQueue和pendingQueue。分别作为客户端的请求发送队列和服务端响应的等待队列。ClinentCnxn连接器的底层I/O处理器是ClientCnxnSocket，所以这一步也再创建ClientCncnSocket.</li><li>初始化SendThread和EventThread：客户端会创建两个核心网络线程SendThread和EventThread。同时，客户端还会将ClientCnxnSocket分配给SendThread作为底层网络I/O处理器，并初始化EventThread的待处理时间队列waitingEvents，用于存放所有等待被客户端处理的事件</li></ol><h6 id="会话创建阶段"><a href="#会话创建阶段" class="headerlink" title="会话创建阶段"></a>会话创建阶段</h6><ol><li>启动SendThread和EventThread：SendThread首先会判断当前客户端的状态，进行一系列请理性工作，为客户端发送“会话创建”请求做准备。</li><li>获取一个服务器地址。在开始创建TCP之前，SendThread首先需要获取一个Zookeeper服务器的目标地址， 这通常是从HostProvider中随机获取出一个地址，然后委托给ClientCnxnSocket去创建与Zookeeper服务器之间的TCP连接。</li><li>创建TCP连接。获取一个服务器地址后，ClientCnxnSocket负责和服务器创建一个TCP长连接。</li><li>构造ConnectRequest请求。</li><li>在TCP连接创建完毕后，可能有的读者会认为，这样是否就说明已经和Zookeeper服务器完成连接了呢？其实不然，上面的步骤只是纯粹地从网络TCP层完成了客户端与服务端之间的Socket连接，但远未完成Zookeeper客户端的会话创建。</li><li>SendThread会负责根据当前客户端的实际设置，构造出一个ConnectRequest请求，该请求代表了客户端试图与服务端创建一个会话。同时，Zookeeper客户端还会进一步将该请求包装成网络I/O层的Packet对象，放入发送队列outgoingQueue中去。</li><li>发送请求。当客户端请求准备完毕后，就可以开始向服务端发送请求了。ClientCnxnSocket负责从outgoingQueue中取出一个待发送的Packet对象，将其序列化成ByteBuffer后，向服务端进行发送。</li></ol><h6 id="响应处理阶段"><a href="#响应处理阶段" class="headerlink" title="响应处理阶段"></a>响应处理阶段</h6><ol><li>接受服务器端响应。ClientCnxnSocket接受到服务端响应后，会首先判断当前的客户端状态是否是“已初始化”，如果尚未完成初始化，那么就认为该响应一定是会话创建请求的响应，直接交由readConnectResult方法来处理该响应。</li><li>处理Response。ClientCnxnSocket会对接受到的服务端响应进行反序列化，得到ConnectResponse对象，并从中获取到Zookeeper服务端分配的会话SessionId。</li><li>连接成功。连接成功后，一方面需要通知SendThread线程，进一步对客户端进行会话参数的设置，包括readTimeout和connectTimeout等，并更新客户端状态，另一方面，需要通知地址管理器HostProvider当前成功连接的服务器地址。</li><li>生成时间:SyncConnected-None。为了能够让上层应用感知到会话的成功创建，SendThread会生成一个事件SyncConnected-None，代表客户端与服务器会话创建成功，并将该事件传递给EventThread线程。</li><li>查询Watcher。EventThread线程收到事件后，会从ClientWatchManager管理器中查询出对应的Watcher，针对SyncConnected-None事件，那么就直接找出存储的默认Watcher,然后将其放到EventThread的watingEvents队列中去。</li><li>处理事件。EventThread不断的从watingEvents队列中取出待处理的Watcher对象，然后直接调用该对象的process接口方法，以达到触发Watcher的目的。</li></ol><h5 id="ClientCnxn：网络I-O"><a href="#ClientCnxn：网络I-O" class="headerlink" title="ClientCnxn：网络I/O"></a>ClientCnxn：网络I/O</h5><p>ClientCnxn是zk客户端的核心工作类，负责维护客户端和服务端之间的网络连接并进行一系列网络通信。</p><h6 id="Packet"><a href="#Packet" class="headerlink" title="Packet"></a>Packet</h6><p>Packet是ClientCnxn定义的一个封装类，里面包含了一些请求头和体、响应头和体、节点路径和注册的Watcher</p><h6 id="outgoingQueue和pendingQueue"><a href="#outgoingQueue和pendingQueue" class="headerlink" title="outgoingQueue和pendingQueue"></a>outgoingQueue和pendingQueue</h6><p>outgoingQueue</p><ul><li>代表了客户端的请求发送队列</li><li>此队列是一个请求发送的队列，专门用于存储哪些需要发送到服务端的Packet集合</li></ul><p>pendingQueue</p><ul><li>代表了服务端响应的等待队列</li><li>次队列是为了存储已经从客户端发送到服务端的，需要等待服务端响应的Packet集合</li></ul><h6 id="底层的Socket通信层"><a href="#底层的Socket通信层" class="headerlink" title="底层的Socket通信层"></a>底层的Socket通信层</h6><ul><li>请求发送<ul><li>从outgoingQueue队列中提取可发送的Packet对象(因为zk消息是有顺序的，所以如果客户端和服务端之间正在处理SASL权限的话，他是一个可发送的Packet)</li><li>发送完成后，会立即将该Packet保存到pendingQueue队列中</li></ul></li><li>响应接受</li></ul><h6 id="SendThread"><a href="#SendThread" class="headerlink" title="SendThread"></a>SendThread</h6><p>SendThread是ClientCnxn内部的一个核心I/o调度线程，用于管理客户端和服务端之间的网络I/O。此线程有三个职责</p><ol><li>定时发送心跳包</li><li>发送客户端消息，返回同步调用的响应和异步调用的回调</li><li>将服务端的事件传递给EventThread</li></ol><h6 id="EventThread"><a href="#EventThread" class="headerlink" title="EventThread"></a>EventThread</h6><p>EventThread是另一个核心，负责客户端事件处理，和触发客户端注册的Watcher监听。</p><p>EventThread中有一个waitingEvents队列，存放需要被触发的事件</p><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>会话是zookeeper中非常重要的角色。</p><p>简单来说，zookeeper的连接与会话就是客户端通过实例化zookeeper对象来实现客户端与服务端创建并保持TCP连接的过程</p><h5 id="会话状态"><a href="#会话状态" class="headerlink" title="会话状态"></a>会话状态</h5><p>一般有CONNECTING、CONNECTED、RECONNECTING、RECONNECTED和CLOSE等</p><h5 id="会话创建"><a href="#会话创建" class="headerlink" title="会话创建"></a>会话创建</h5><h6 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h6><p>Session是zk中的会话实体、代表了一个客户端会话</p><h6 id="SessionId"><a href="#SessionId" class="headerlink" title="SessionId"></a>SessionId</h6><p>会话ID，用来唯一标识某个会话，全局唯一。那么zk是怎么保证sessionid全局唯一的呢。一般由两个部分组成：时间毫秒、机器标识码。</p><p>其中机器标识码是每台机器特有配置的，配置在myid文件</p><h5 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h5><h6 id="分桶策略"><a href="#分桶策略" class="headerlink" title="分桶策略"></a>分桶策略</h6><p>zk的会话管理主要是由SessionTracker负责的，采用了”分桶策略”。将类似的会话放到一个区块中进行管理。</p><h6 id="会话激活"><a href="#会话激活" class="headerlink" title="会话激活"></a>会话激活</h6><p>在收到心跳的时候，需要更新session的过期时间</p><h4 id="zookeeper的服务端架构"><a href="#zookeeper的服务端架构" class="headerlink" title="zookeeper的服务端架构"></a>zookeeper的服务端架构</h4><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211015225007575.png" alt="image-20211015225007575"></p><h5 id="单机版-不需要选举leader"><a href="#单机版-不需要选举leader" class="headerlink" title="单机版(不需要选举leader)"></a>单机版(不需要选举leader)</h5><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211015225041612.png" alt="image-20211015225041612"></p><h5 id="集群版"><a href="#集群版" class="headerlink" title="集群版"></a>集群版</h5><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211015225112275.png" alt="image-20211015225112275"></p><h4 id="客户端的请求流"><a href="#客户端的请求流" class="headerlink" title="客户端的请求流"></a>客户端的请求流</h4><h5 id="会话创建请求"><a href="#会话创建请求" class="headerlink" title="会话创建请求"></a>会话创建请求</h5><p>会话创建总的来说可以分成六部分：请求接受、会话创建、预处理、事务处理、事务应用和会话响应</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211015225458723.png"></p><h5 id="setData请求"><a href="#setData请求" class="headerlink" title="setData请求"></a>setData请求</h5><p>setData请求大致分为四大步骤。分别是请求的预处理、事务处理、事务应用和请求响应</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211015225707602.png" alt="image-20211015225707602"></p><h5 id="事务请求转发"><a href="#事务请求转发" class="headerlink" title="事务请求转发"></a>事务请求转发</h5><h5 id="getData请求"><a href="#getData请求" class="headerlink" title="getData请求"></a>getData请求</h5><p>getData请求大体可以分为三类，请求的预处理、非事务处理和请求响应</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211015230323805.png" alt="image-20211015230323805"></p><h4 id="Zookeeper的存储数据结构"><a href="#Zookeeper的存储数据结构" class="headerlink" title="Zookeeper的存储数据结构"></a>Zookeeper的存储数据结构</h4><p>Zk数据存储分为两部分：内存部分和磁盘持久化部分</p><h5 id="内存数据"><a href="#内存数据" class="headerlink" title="内存数据"></a>内存数据</h5><p>zk在内存中的结构类似于一棵树，每个节点有对应的属性和子节点</p><h6 id="dataTree"><a href="#dataTree" class="headerlink" title="dataTree"></a>dataTree</h6><p>DataTree是zk内存数据模型的核心，其中使用ConcurrentHashMap&lt;String, DataNode&gt;维护了所有的信息</p><h6 id="dataNode"><a href="#dataNode" class="headerlink" title="dataNode"></a>dataNode</h6><p>DataNode是数据存储中的最小单元</p><h6 id="ZKDatabase"><a href="#ZKDatabase" class="headerlink" title="ZKDatabase"></a>ZKDatabase</h6><p>zk的内存数据库，负责管理zk的所有会话、DataTree存储和事务日志</p><h5 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h5><p>在部署zk集群的时候需要指定一个目录，这个目录下面会记录日志文件(FileTxnLog)。</p><h5 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h5><p>快照用来记录zk服务器上某一个时刻的全量内存数据内容，并持久化到本地磁盘</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结zookeeper框架相关概念，《从Paxos到Zookeeper》的读书笔记&lt;/p&gt;</summary>
    
    
    
    <category term="框架整理" scheme="https://morningbells.github.io/categories/%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/"/>
    
    
    <category term="二次阅读" scheme="https://morningbells.github.io/tags/%E4%BA%8C%E6%AC%A1%E9%98%85%E8%AF%BB/"/>
    
    <category term="zookeeper" scheme="https://morningbells.github.io/tags/zookeeper/"/>
    
    <category term="从Paxos到Zookeeper" scheme="https://morningbells.github.io/tags/%E4%BB%8EPaxos%E5%88%B0Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>摘录-人人都是产品经理-支付相关</title>
    <link href="https://morningbells.github.io/2021/10/06/%E6%91%98%E5%BD%95-%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86-%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3/"/>
    <id>https://morningbells.github.io/2021/10/06/%E6%91%98%E5%BD%95-%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86-%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-06T15:24:31.000Z</published>
    <updated>2021-11-17T08:31:07.695Z</updated>
    
    <content type="html"><![CDATA[<p>人人都是产品经理，读后感&amp;摘抄</p><span id="more"></span><p>支付系统结构</p><p>![image-20211002162303507](/Users/wangyi/Library/Application Support/typora-user-images/image-20211002162303507.png)</p><ol><li>支付sdk适配</li><li>下单API</li><li>订单查询</li><li>token认证</li><li>支付回调</li><li>二维码生成</li><li>appid分配</li><li>redis存储</li><li>支付回调</li><li>sdk对外</li><li>第三方支付</li></ol><h1 id="云栖大会"><a href="#云栖大会" class="headerlink" title="云栖大会"></a>云栖大会</h1><h2 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h2><p><img src="http://image.woshipm.com/wp-files/2020/04/YjXUMKJHQs9RSL8nCz7W.png" alt="中台之我不是药神"></p><p><img src="http://image.woshipm.com/wp-files/2020/04/ddf6XCeKMcG59ggBtw50.png" alt="中台之我不是药神"></p><p><img src="http://image.woshipm.com/wp-files/2020/04/QlJcAVsEsBNlna3lGft2.png" alt="中台之我不是药神"></p><p><img src="http://image.woshipm.com/wp-files/2020/04/QC8eN75jQ71WLEQgg8dP.png" alt="中台之我不是药神"></p><h2 id="优惠券系统"><a href="#优惠券系统" class="headerlink" title="优惠券系统"></a>优惠券系统</h2><p><img src="http://image.woshipm.com/wp-files/2018/06/hOH93IneKMqw8uZJlaP4.png" alt="img"></p><h2 id="一、创建优惠券"><a href="#一、创建优惠券" class="headerlink" title="一、创建优惠券"></a>一、创建优惠券</h2><p>优惠券是一套规则的组合，创建优惠券是优惠券系统设计的第一步，主要有以下几部分组成：基本信息、优惠类型、使用范围、有效期等。</p><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h3><p>包括优惠券名称、发放数量、优惠券是否可叠加、每人限领张数、是否和其他促销同时使用（优惠优先级）、使用规则等。</p><h3 id="2-优惠类型"><a href="#2-优惠类型" class="headerlink" title="2. 优惠类型"></a>2. 优惠类型</h3><p>优惠类型要根据公司实际情况和用户群体去设计，主要有满减、立减、折扣券或优惠码。满减、立减、折扣券属于私有券，只能个人账号使用；优惠码属于共有券，给有兑换码并且兑换的用户使用。</p><h3 id="3-使用范围"><a href="#3-使用范围" class="headerlink" title="3. 使用范围"></a>3. 使用范围</h3><p>使用优惠券的用户类型、使用优惠券的商品类型、订单类型。用户类型一般指是否区分新老用户、不同的等级用户；商品类型指哪些区域、哪些品类的商品可使用；订单类型指订单满多少元可使用、满多少件可使用。</p><h3 id="4-有效期"><a href="#4-有效期" class="headerlink" title="4. 有效期"></a>4. 有效期</h3><p>有效期一般有两种：</p><ul><li>一种是固定的有效期，设定一个时间段；</li><li>另一种是设定一个有效数，比如：30天，一般是从领取之日起30天内有效。</li></ul><p>多数情况下都会选择第二种，增加紧迫感，促进用户下单。优惠券因涉及金额，通常需要财务审批，财务审批后优惠券ID生成。到此，优惠券的基本规则大概梳理完毕。当然这些只是最基本的规则，具体的还要和实际业务相结合。</p><p><strong>实例设计：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/iFWER8yldgEzBpMfLc8v.png" alt="img"></p><p>△这是最基本的优惠券新增，具体要视业务而定</p><h2 id="二、创建活动"><a href="#二、创建活动" class="headerlink" title="二、创建活动"></a><strong>二、创建活动</strong></h2><p>创建的优惠券只是一系列规则的组合，通常还需要一个活动页。活动页上可放一张优惠券，也可放多张，具体看业务需求。</p><p><img src="http://image.woshipm.com/wp-files/2018/06/EhBVvhLmfQmMOn2zcRGx.png" alt="img"></p><p>活动通常包括活动基本信息和分享设置等。</p><h3 id="1-基本信息-1"><a href="#1-基本信息-1" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h3><p>包括活动名称、活动时间、活动图片、活动状态和活动规则等。</p><p>活动页需要上传的图片和设计者的设计强相关，若活动页是使用者百分百自定义，则需要开发一个自定义配置页面；若只有活动头图和活动规则部分自定义，则需要上传活动头图和活动规则图片（通常由UI设计好）。</p><p>优惠券区域因涉及“立即使用”的链接跳转（来自创建优惠券时的URL跳转路径），样式通常在开发环境写好，但可修改上面的文案、字体、颜色等。若优惠券需用户点击“领取”，则还需要领取成功的页面。</p><p>活动状态可分为未开始、进行中、已结束。列表页的活动状态和新增页不同，列表页的状态是由新增页的“在线”或“下线”和活动时间共同决定。</p><p>需要注意的是：已经发出去的优惠券，即使对应的活动已结束，但只要还在优惠券有效期内，是可以正常使用的。</p><p><strong>实例设计：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/nHWLKWW1e0Q7VsQfHp6H.png" alt="img"></p><p>△这是最基本的活动页新增，具体要视业务而定</p><p>活动创建后到活动列表页，同时生成一个活动链接，接下来就是为这个活动关联之前生成的优惠券。</p><p><strong>实例设计：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/gEYk7OyOvHLX71NsYXId.png" alt="img"></p><p>△这是最基本的活动列表页，具体要视业务而定</p><p>点击卡券配置为活动添加优惠券。</p><p><strong>实例设计：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/udMgm3ZpPk4wl2xla8K8.png" alt="img"></p><p>△这是最基本的添加优惠券页面，具体要视业务而定</p><p>到此，活动关联优惠券完成，接下来讲优惠券投放和用户使用等环节。</p><h2 id="三、优惠券投放"><a href="#三、优惠券投放" class="headerlink" title="三、优惠券投放"></a><strong>三、优惠券投放</strong></h2><p>用户获得优惠券的渠道有很多种，主要有以下几种：</p><ol><li>新手注册：在很多应用上，用户新注册会得到一张券，用于促进新用户的下单转化。</li><li>会员领取：类似饿了吗，成为会员每月享有20元无门槛红包。</li><li>邀请送券：邀请好友可得价值多少的优惠券。</li><li>活动送券：法定节假日或特定节日，比如双十一的促销节，以活动页的形式向用户发券（本人负责的优惠券需求采用此形式发券）。</li><li>分享发券：类似饿了吗，用户下完单后将优惠券分享在朋友圈或微信好友，其他用户点击领取。</li><li>主动触发：通过短信告知用户有优惠券送达，短信中可附上优惠的商品链接，有助于转化，或者使用push的方式去提醒用户。注意这种方式发券会对用户造成打扰，因此注意发券的频率和时间。主动触发多用于刺激留存用户、唤醒沉睡用户。</li></ol><h2 id="四、用户领取"><a href="#四、用户领取" class="headerlink" title="四、用户领取"></a>四、用户领取</h2><p>用户领取有两种方式：直领和点击领取。</p><ul><li>直领指不需要用户点击“领取”按钮，进到优惠券页面，优惠券自动落到个人账户，即系统自动发放，常见于活动页或新打开应用的场景下。</li><li>点击领取顾名思义就是需要用户点击一下“领取”按钮，优惠券才会落入个人账户。</li></ul><p>领取通常伴随着消息通知，如：短信、微信公众号，因此通知系统和营销系统也要打通。</p><p><img src="http://image.woshipm.com/wp-files/2018/06/ENoaaTZRZEqMINolPIRF.png" alt="img"></p><p>△用户领取优惠券流程图</p><h2 id="五、用户使用"><a href="#五、用户使用" class="headerlink" title="五、用户使用"></a><strong>五、用户使用</strong></h2><p>在订单填写页，系统会默认给出面额最大的优惠券，金额相同优先使用先过期的券。用户也可自己选择是否使用优惠券或其他可用优惠券。需要注意的是：在优惠券列表页，达到当前订单总价的优惠券才能使用，其他不可使用优惠券置灰不可选，靠后展示。</p><p><strong>实例设计：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/rVAz7MMh3wtyHXHCyjRf.png" alt="img"></p><p>△优惠券原型图</p><p><img src="http://image.woshipm.com/wp-files/2018/06/aaAPffohFStW3Ciql3G1.png" alt="img"></p><p>△用户使用优惠券流程图</p><h2 id="六、优惠券退还"><a href="#六、优惠券退还" class="headerlink" title="六、优惠券退还"></a><strong>六、优惠券退还</strong></h2><p>优惠券退还要看具体的场景，一般有以下几种：</p><ol><li>用户下单未支付，取消订单，优惠券可退还；</li><li>商家在订单未完成的情况下，发起退款操作，优惠券可退还；</li><li>用户下单支付后，申请退款，优惠券不退还。</li></ol><h2 id="七、数据分析"><a href="#七、数据分析" class="headerlink" title="七、数据分析"></a><strong>七、数据分析</strong></h2><p>数据分析是对用户领取、使用优惠券进行数据统计，从而查看活动效果。投入多大成本，带来多大转化率。</p><p>以下提供几个统计维度，仅供参考：</p><ul><li>领取率：优惠券领取总量/优惠券发放总量；</li><li>使用率：优惠券已使用总量/优惠券已领取总量；</li><li>优惠总金额：使用该优惠券优惠的总金额；</li><li>用券总成交额：使用该优惠券的订单付款总金额；</li><li>优惠总金额：使用该优惠券的付款订单总数；</li><li>费效比：优惠总金额/用券总成交额；</li><li>用券笔单价：用券总成交额 / 使用该优惠券的付款订单总数；</li><li>拉新数：领取过优惠券的用户中，标记为新用户的数量/总用户数。</li></ul><p>优惠券状态可分为：待使用、已使用、已过期，已取消。</p><ol><li>用户领取优惠券后，优惠券处于待使用状态；</li><li>成功使用优惠券后状态变为已使用；</li><li>未在有效期内使用的优惠券状态变为已过期；</li><li>退款的优惠券状态为已取消。</li></ol><p><strong>实例设计：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/c0i36pRXLCg608RAxL5U.png" alt="img"></p><p>△这是最基本的数据分析页面，具体要视业务而定</p><p>大家可以看到，我在每个原型图下都提到具体要视业务而定。因为任何产品设计的出发点，都是业务，都是在解决业务。虽然业务和业务之间有共同点，但脱离业务的设计没有任何意义。</p><p>所以这篇文章中的所有原型图都只能做参考而不能直接使用，具体要看公司的业务。</p><h2 id="拼团活动"><a href="#拼团活动" class="headerlink" title="拼团活动"></a>拼团活动</h2><p>营销手段除了优惠券，还有拼团这种常见模式。提起拼团，大家自然而然地想到拼多多，在流量红利已经触底的情况下，以拼团这种新模式杀出一条血路。</p><p>传闻今年3月份，拼多多月GMV已经达到400亿的规模，交易额超过京东的1/3（京东月GMV约1100亿）。</p><p>页面上的“发起拼团”或“去拼团”按钮大家都看的到，但是否真正思考过其背后的逻辑。</p><p>接下来我将结合最近两周做的拼团活动，细说拼团背后的逻辑，按拼团的整个流程来讲解。</p><h2 id="一、创建拼团活动"><a href="#一、创建拼团活动" class="headerlink" title="一、创建拼团活动"></a><strong>一、创建拼团活动</strong></h2><p>拼多多的所有商品都有拼团模式，淘宝、京东或其他平台只有部分商品有拼团模式，两种后台设计肯定不同。因本人此次负责的项目是后者，故以此种类型谈如何创建拼团活动。</p><p><strong>实例设计</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/YDM8wGDRdVGp8u2UgzgR.png" alt="img"></p><p>△创建拼团活动页</p><p>创建拼团活动的过程中，至少包含以下元素：拼团活动时间、成团有效时间、成团人数、每人限购、可开团商品和拼团活动状态。</p><h3 id="1-拼团活动时间"><a href="#1-拼团活动时间" class="headerlink" title="1. 拼团活动时间"></a><strong>1. 拼团活动时间</strong></h3><p>可开团商品的拼团活动时长，如一个商品的拼团活动时间为6月28日00:00:00至7月3日00:00:00，这个时间段内，该商品可开团，用户进入商品详情页可发起拼团或参与拼团。</p><h3 id="2-成团有效时间"><a href="#2-成团有效时间" class="headerlink" title="2. 成团有效时间"></a><strong>2. 成团有效时间</strong></h3><p>用户开团后与其他人组团的时间，该时间内没有组团成功将拼团失败，系统自动退款。特别注意的是：因为引入了这个字段，会有某用户对某商品的实际拼团结束时间。</p><p><strong>实际拼团结束时间=发起拼团时间+成团有效时间****（发起拼团时间=发起拼团人的支付时间）</strong></p><p>什么意思呢？</p><p>举个例子来讲：若该商品的拼团活动时间为6月28日00:00:00-7月3日00:00:00，成团有效时间为24小时，则7月3日0点以后，该商品不可再开团，但已开的团用户还可以参团，即该活动实际在7月4日00:00:00结束拼团促销。</p><h3 id="3-成团人数"><a href="#3-成团人数" class="headerlink" title="3. 成团人数"></a><strong>3. 成团人数</strong></h3><p>凑够多少人满足拼团条件，限制条件为至少2人。</p><h3 id="4-每人限购"><a href="#4-每人限购" class="headerlink" title="4. 每人限购"></a><strong>4. 每人限购</strong></h3><p>每人最多购买多少件，拼团商品因价格较便宜，根据预算看是否需要配置该字段。</p><h3 id="5-关联商品"><a href="#5-关联商品" class="headerlink" title="5. 关联商品"></a><strong>5. 关联商品</strong></h3><p>前面四个字段都属于拼团活动的基本属性字段，我们要把这些字段关联到具体某一个商品上或多个商品上，并设置拼团价。</p><p>拼团活动商品创建成功后，商品就被分为普通商品和拼团商品（在商品表里也会有一个字段来标记和区分），拼团活动列表新增一条记录。</p><p><strong>实例设计</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/KHndPUTlthXUcRx3XTES.png" alt="img"></p><p>△拼团管理列表页</p><h3 id="6-拼团活动状态"><a href="#6-拼团活动状态" class="headerlink" title="6. 拼团活动状态"></a><strong>6. 拼团活动状态</strong></h3><ul><li><strong>未开始</strong>：拼团活动开始时间&gt;当前时间；</li><li><strong>活动中</strong>：拼团活动开始时间&lt;当前时间且拼团活动结束时间&gt;当前时间；</li><li><strong>已结束</strong>：拼团活动结束时间&lt;当前时间；</li><li><strong>已失效</strong>：“活动中”状态的活动商品手动点击“已失效”按钮，变为已失效，活动提前结束。</li></ul><p>“未开始”状态的活动商品可全部字段编辑，“活动中”状态的活动商品只能延长拼团活动结束时间。</p><p><strong>值得注意的是：</strong>已结束与已失效的区别在于：已结束是活动到期后自然结束的，已失效是指商家主动提前结束。已结束和已失效的活动商品需要再次发起活动，重新新增一次。</p><p>在C端怎样展示就看具体的产品设计，在自己负责的项目中，拼团商品我给了2个入口：拼团专场和全部商品列表，是拼团商品的有拼团标签。</p><p><strong>实例设计</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/k7xfomOimSgsXuGI81rG.png" alt="img"></p><p>△拼团入口</p><h2 id="二、用户发起拼团"><a href="#二、用户发起拼团" class="headerlink" title="二、用户发起拼团"></a><strong>二、用户发起拼团</strong></h2><p>用户在拼团商品详情页发起拼团活动，生成一条团单记录和订单记录，后台分别对应团单列表和订单列表。</p><p><img src="http://image.woshipm.com/wp-files/2018/06/0ExWBSgFvmjOPpyLeV6j.png" alt="img"></p><p>△商品详情页、订单填写页</p><p><img src="http://image.woshipm.com/wp-files/2018/06/TZiogiDzwqslxYwW6KPz.png" alt="img"></p><p>△订单详情页</p><h3 id="1-团单列表"><a href="#1-团单列表" class="headerlink" title="1. 团单列表"></a><strong>1. 团单列表</strong></h3><p>不同的拼团状态，订单ID个数和已参团人数不同，假设成团人数为3人。</p><ul><li><strong>待成团</strong>：发起者发起拼团但未支付，订单ID有该用户的下单数据，发起拼团时间和拼团结束时间为空（此团未开成功，自然不存在发起拼团时间和拼团结束时间之说，发起者支付成功才意味着开团成功），已参团人数为0。</li><li><strong>拼团中</strong>：发起者支付成功，开团成功，已参团人数为1。“拼团中”状态的订单不可取消，需拼团成功后才可取消。</li><li><strong>拼团成功</strong>：成团人满且都支付成功，此时一个团购ID对应三个订单ID。</li><li><strong>拼团失败</strong>：成团有效时间内，成团人数未满，拼团失败，系统自动退款。</li></ul><p>特别说明的是，C端拼团商品详情页【和其他人拼团】的数据取自团单数据，不是订单数据。</p><p><strong>实例设计</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/06/mObN2DnAgsvxUOHZSkqD.png" alt="img"></p><p>△团单列表</p><h3 id="2-拼团订单列表"><a href="#2-拼团订单列表" class="headerlink" title="2. 拼团订单列表"></a><strong>2. 拼团订单列表</strong></h3><p>拼团商品的订单可合并在普通订单列表，增加一个“订单类型”字段用于区分，拼团订单列表有“查看同团订单”跳转链接。</p><p><img src="http://image.woshipm.com/wp-files/2018/06/OqP6xBrJAuSrsgCxKh84.png" alt="img"></p><p>△订单列表</p><h2 id="三、拼团页分享"><a href="#三、拼团页分享" class="headerlink" title="三、拼团页分享"></a><strong>三、拼团页分享</strong></h2><p>拼团的一个显著特点是通过分享进行老带新，更多利用社交关系促进订单转化。这个环节要考虑的是，分享出来的这个拼团活动状态不同，用户看到的页面也不同。</p><p>“拼团失败”和“拼团成功”分别对应活动已结束（不是商品的拼团活动结束时间，是发起人创建的这个拼团活动的结束时间）和人数已满两种情况。</p><p>大概流程如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/06/pgZs9gqu5k8a55ojYOSr.png" alt="img"></p><p>△用户进入拼团分享页逻辑</p><p>到此，一个完整的拼团活动差不多结束了。文中所有的原型图仅供参看，具体视业务而定。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h2><p>看过一句话：</p><ul><li>开发的工作迭代是：接需求—&gt;Coding—&gt;再接需求—&gt;再Coding……</li><li>产品的工作迭代是：实践—&gt;总结—&gt;再实践—&gt;再总结……</li></ul><p>所以本文的最后部分还是总结，每项需求、每周周报都要复盘与总结，现在尽量做到日日总结。</p><h3 id="1-无论C端、B端，场景要尽可能穷尽，逻辑要尽可能严谨"><a href="#1-无论C端、B端，场景要尽可能穷尽，逻辑要尽可能严谨" class="headerlink" title="1. 无论C端、B端，场景要尽可能穷尽，逻辑要尽可能严谨"></a><strong>1. 无论C端、B端，场景要尽可能穷尽，逻辑要尽可能严谨</strong></h3><p>需求不是做完一遍就结束，通常这样只能解决表层问题，场景完善、异常情况多思考、反复问自己才能想到。场景通常越挖越深，越深越宽，呈倒三角模式。</p><p>比如：在拼团活动商品的下单支付处，要增加该团是否已结束和拼团人数是否已满两个逻辑。这种场景在将一个拼团活动分享到一个微信好友群很常见，多个用户会同时进到该团并下单支付，这和普通商品不同。</p><p>这点是自己在反复回顾整个拼团流程中领悟到的。</p><h3 id="2-学会及时地决断"><a href="#2-学会及时地决断" class="headerlink" title="2. 学会及时地决断"></a><strong>2. 学会及时地决断</strong></h3><p>我们通常会遇到这样的场景：技术觉得这个功能做着没啥大用，而且实现又麻烦，或者是因为某些原因被迫砍掉一部分需求；或者技术的看法和你的看法不一样；或者在开发的过程中，技术提出了另外一种更好的方案，之前是你没想到的，这时该怎么办？</p><p>这么多的变化，不可能事事去请教导师或领导，对方会觉得你没有主见，自己必须要学会及时地决断。</p><p>比如：在做需求时，我将发起人创建拼团活动的支付时间，作为这个活动发起拼团时间，技术说用下单时间就好。当时觉得下单时间和支付时间并无区别，便说可以。</p><p>后来细细想，如果是下单但未支付成功的团单，都没有开团成功之说，何来发起拼团时间呢。便又去找技术说明这点。</p><p>最后，说一下自己近期对产品的领悟：做产品最核心的竞争力是产品思维和项目跟进能力，不是会画原型、写文档（想起自己刚做产品时，整天沉浸在画原型中无法自拔，觉得自己画的好看）。产品教给我们的一直都是解决问题的能力，这种做事思路与方法可以解决很多实际的生活问题。</p><p>我很喜欢苏杰的一句话，他说：</p><blockquote><p>我做的互联网产品是我的产品，我写的书是我的产品，我发起的一个线下组织也是我的产品。产品其实没有具体的形象，只要满足某种需求，提升用户体验，就是一个产品，这就是一种产品的思维。</p></blockquote><h2 id="信贷业务的账户设计"><a href="#信贷业务的账户设计" class="headerlink" title="信贷业务的账户设计"></a>信贷业务的账户设计</h2><p>溢缴款</p><p>公司主业务是：面向用户提供分期电商、现金贷和大额贷的金融服务平台。通过给用户授信额度，用户可以在平台上进行一定额度的贷款——先消费，后还款。</p><p>与普通电商平台不同的是：订单生成的同时，也会生成相应的账单。账单是很重要的一个模块，用户还款率直接关系公司营收。</p><p>根据客服反馈以及业务发展，去年11月对账单进行了一次改版，现已开发上线。</p><ul><li>分期电商：购买商品付首付，每月还月供；</li><li>现金贷：短期借款，一笔还清；</li><li>大额贷：长期借款，分期还清。</li></ul><p>改版前后账单对比：</p><p><img src="http://image.woshipm.com/wp-files/2019/02/Ol8ciFnzKbfDvBYtur43.jpeg" alt="复盘|向你讲解账单啦"></p><p>和国内如招行等信用卡，或花呗不同的是：这些产品的账单只有一种分期业务，而在我们产品中，既有分期、还有现金贷和大额贷，三者数据结构均不同。</p><p><img src="http://image.woshipm.com/wp-files/2019/02/ka3kVkqWbhjqIyBsrRAe.jpeg" alt="复盘|向你讲解账单啦"></p><p>为了方便讲述，我把账单分成了上一期、当前和下一期三种类型。</p><p>“上一期”叫<strong>历史账单</strong>、“当前”叫<strong>当前账单</strong>、“下一期”叫<strong>待出账单</strong>。</p><p>每个账单里包含的字段有：</p><ol><li>账单开始时间</li><li>账单结束时间（账单开始时间和结束时间组成账单周期）</li><li>账单出账日</li><li>账单还款日</li><li>账单当期金额</li><li>账单逾期金额</li><li>账单逾期天数</li></ol><p><img src="http://image.woshipm.com/wp-files/2019/02/0hPkwYCC6NDwx78sL3va.jpeg" alt="复盘|向你讲解账单啦"></p><h2 id="一、改版了账单模块"><a href="#一、改版了账单模块" class="headerlink" title="一、改版了账单模块"></a>一、改版了账单模块</h2><h3 id="1-下一期账单出账时间改变"><a href="#1-下一期账单出账时间改变" class="headerlink" title="1. 下一期账单出账时间改变"></a>1. 下一期账单出账时间改变</h3><p>由当前账单还款日后一天凌晨，变成了下期账单结束时间后一天凌晨。</p><p>每种业务类型都有明确的出账日和还款日，以数据为例来讲解：</p><ul><li>当前账单开始时间1/11。</li><li>当前账单结束时间2/10。</li><li>当前账单还款日2/25。</li><li>当前账单周期为1/11-2/10。</li><li>下期账单开始时间2/11。</li><li>下期账单结束时间3/10。</li><li>下期账单还款日3/25。</li><li>下期账单周期为2/11-3/10。</li></ul><p>改版前，下期账单会在2/26日凌晨刷新，当前账单数据变成当前账单——即2/26日凌晨为下期账单出账日；改版后，下期账单在3/11凌晨刷新，当前账单数据变成当前账单——即3/11凌晨为下期账单出账日。</p><p>带来的影响是：</p><ul><li>下期账单推后15天出账（出账日由2/26推迟到3/11）。</li><li>改版前2/26出下一期账单时，下一期账单还没有结束（3/10日结束），那么，2/26-3/10期间的订单仍被归为下一期账单当期金额中，随着用户消费，这个值会不断增大；改版后3/11出下一期账单，2/26-3/10期间的订单本来就被归为下一期账单当期金额中，这个值不会变化。</li></ul><p>解决了用户的疑惑：当前账单金额为什么会一直变化？</p><h3 id="2-账单结构由【当前】变成了【当前-待出】"><a href="#2-账单结构由【当前】变成了【当前-待出】" class="headerlink" title="2. 账单结构由【当前】变成了【当前+待出】"></a>2. 账单结构由【当前】变成了【当前+待出】</h3><p>接着以上面的数据为例讲解：</p><p>改版前3/10-3/25期间，用户消费的订单没法查看；改版后在待出账单模块可查看。</p><p>解决了：用户看不到消费的订单金额问题。</p><p>需要注意的点：</p><ul><li>当期账单过了还款日且用户还清，当期账单模块是否应该展示。</li><li>为保持一致性，无论用户是否还清，当期账单均在下期账单出账后消失，变成历史账单；若用户还清，文案展示“本期账单已还清”。</li><li>待出账单一旦生成，无论待还金额是否为0，该模块始终展示（不会随着用户还款是否还清而有时展示，比如待还金额为0，不展示；待还金额不为0，展示）；若用户还清，文案展示“暂无待还账单”。</li></ul><p><img src="http://image.woshipm.com/wp-files/2019/02/UnUj8B0snWQDdg5ZMqB5.jpeg" alt="复盘|向你讲解账单啦"></p><h2 id="二、增加了快速还款、提前还款、还款记录、还款提醒功能"><a href="#二、增加了快速还款、提前还款、还款记录、还款提醒功能" class="headerlink" title="二、增加了快速还款、提前还款、还款记录、还款提醒功能"></a>二、增加了快速还款、提前还款、还款记录、还款提醒功能</h2><h3 id="1-快速还款和提前还款"><a href="#1-快速还款和提前还款" class="headerlink" title="1. 快速还款和提前还款"></a>1. 快速还款和提前还款</h3><p>快速还款：计算分期、现金贷和大额贷的历史和当前账单金额。</p><p>提前还款：计算分期和大额贷的待出账单金额。</p><p>做这个需求时，快速还款是APP内已有功能，但不在账单模块。账单还款本是一家，所以，这次在账单模块也增加了快速还款入口。快速还款不能还未来待出账单，因此增加了提前还款功能。</p><p>需要考虑的问题是：快速还款和提前还款是否要合并？</p><p>比如：像京东金融一样，账单列表包含历史、当前和待出，待还金额显示三者之和。</p><p><img src="http://image.woshipm.com/wp-files/2019/02/NuzFCD4fSlhUTY8m11nb.jpg" alt="复盘|向你讲解账单啦"></p><p>东南亚用户（主要是印尼）和国内用户消费习惯有很大不同，他们大部分是缺钱状态，用提前还款功能的用户不多。</p><p>所以，最后做的方案是：有历史和当前账单待还时，做快速还款入口展示，无提前还款；当历史和当前还清，有待出账单时，做提前还款入口展示，无快速还款</p><p>提前还款相对于快速还款，增加了提前还款账单列表和详情。</p><p><img src="http://image.woshipm.com/wp-files/2019/02/TednGIbMxSJ0njfqiETV.jpeg" alt="复盘|向你讲解账单啦"></p><h3 id="2-还款记录中应有还款状态标注：还款中、还款成功和还款失败"><a href="#2-还款记录中应有还款状态标注：还款中、还款成功和还款失败" class="headerlink" title="2. 还款记录中应有还款状态标注：还款中、还款成功和还款失败"></a>2. 还款记录中应有还款状态标注：还款中、还款成功和还款失败</h3><p>用户发起的动作需考虑其结果，比如：</p><ul><li>用户发了还款动作，那还款结果是怎样的？</li><li>用户发起了查询报告，那查询结果是怎样的？</li></ul><p>报告未生成，状态是“查询中”，报告已生成，状态是“查看”。</p><h3 id="3-还款提醒：系统通知-APP内消息通知-短信-App首页"><a href="#3-还款提醒：系统通知-APP内消息通知-短信-App首页" class="headerlink" title="3. 还款提醒：系统通知+APP内消息通知+短信+App首页"></a>3. 还款提醒：系统通知+APP内消息通知+短信+App首页</h3><p>根据出账日和还款日不同，增加逻辑，各个渠道给用户推送还款提醒，以降低逾期率。</p><h2 id="三、写在最后"><a href="#三、写在最后" class="headerlink" title="三、写在最后"></a>三、写在最后</h2><p>每一次复盘，写在最后的一定是在做这个项目的过程中的收获和感悟——功能上线后，少不了数据监控。</p><p>我是交行信用卡用户，在做账单改版前，交行账单还不是现在这样，账单需求落地后，发现交行已经更新了现在这个页面（上图：国内信用卡）——包括UI上使用卡片样式，数据展示逻辑，都和我们几乎一模一样。</p><p>当时我觉得很兴奋，说明这个改版思路是正确的。</p><p>因目标用户是东南亚用户，用户行为、受教育水平和消费习惯等和国内有些不同，四国翻译文案均比中文要长的多，所以不能完全按照国内产品思路来做。</p><p>刚开始时也有一些逻辑疏漏，在做的过程中，不断完善。回过头再来看整个账单，做了哪些改动点，数据的来源（订单）和去向（还款）基本上清晰。至此，特别感谢我整个订单组的同事们，开发很卖力，测试很尽心。爱你们！</p><h2 id="支付中心"><a href="#支付中心" class="headerlink" title="支付中心"></a>支付中心</h2><h2 id="一、支付中心改版背景"><a href="#一、支付中心改版背景" class="headerlink" title="一、支付中心改版背景"></a>一、支付中心改版背景</h2><p>\1. 上游环节授信通过率被提高，从15%提高到30%；19年公司战略重电商，意味着越来越多的用户可以下单和需要还款，下游环节支付中心越来越重要。</p><p>\2. 初期为了快速响应业务的支付基础需求和开发资源不足原因，支付中心接入的是第三方供应商H5页面，有以下不足：</p><ul><li><strong>支付方式和订单耦合。</strong>每选一个支付方式生成一个订单，对于同一订单，用户无法切换其他支付方式；</li><li><strong>待支付订单列表无法查看当前订单已选的支付方式和支付码。</strong>若在选支付方式时没有截图，无法二次继续支付；</li><li><strong>支付环节长，</strong>各支付方式2-3级页面，<strong>用户流失多</strong>；</li><li><strong>H5不稳定</strong>，页面跳转不流畅，容易出现卡顿现象；</li><li><strong>第三方H5页面信息展示不明</strong>，没有支付指引重要信息提示，带有和支付无关的如邮箱填写和广告信息。</li></ul><p>基于此，我做了支付改版以响应业务的快速发展和提高系统的高可拓展性，保证支付中心的稳定性，分以下四步：</p><ol><li>完成用户端H5到Native全流程改造；</li><li>接入更多的网关完善支付路由，增强容灾性以提高支付稳定性；</li><li>接入更多的在线支付方式，提高支付成功率；</li><li>日常监控接口和各支付方式支付成功率，快速响应，降低支付失败率。</li></ol><h2 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h2><h3 id="1-用户端H5到Native全流程改造"><a href="#1-用户端H5到Native全流程改造" class="headerlink" title="1. 用户端H5到Native全流程改造"></a>1. 用户端H5到Native全流程改造</h3><p><strong>（1）用户层面—增强用户体验</strong></p><ol><li>支付方式和订单解耦。用户下单后，在支付中心可切换支付方式，一个订单号对应多个支付单号；</li><li>待支付订单列表可查看已选支付方式和支付码，且可切换其他支付方式；</li><li>支付中心为列表+详情结构，支付指引更明确，去掉非支付必填信息。</li></ol><p><strong>（2）系统设计—提高产品容灾性</strong></p><ol><li>可配置，包括一级二级支付方式名称、支付方式Icon、支付方式顺序、支付指引；</li><li>根据订单所属业务线、用户支付金额展示可用的支付方式；比如现在app内业务线有实体虚拟订单和还款;</li><li>支付渠道出现故障时可在支付中心暂停展示。比如BCA银行每周日早0-6固定时间维护；</li><li>支付管理后台管理，支持随时随地渠道和支付方式上下线，切换路由。比如一个网关挂掉的时候，这个支付方式可以切换到另外一个网关上。</li></ol><p>该功能上线后，整体支付转化率提高约14.8%，头部支付方式如BCA提高9.2%左右。这是支付改版的第一步，打好底层基础，为后续接更多的网关和支付方式提供支撑。</p><h3 id="2-接入Midtrans-和DOKU网关"><a href="#2-接入Midtrans-和DOKU网关" class="headerlink" title="2. 接入Midtrans 和DOKU网关"></a>2. 接入Midtrans <strong>和DOKU网关</strong></h3><p><strong>（1）为什么要新接网关？</strong></p><p>已接入的Fastpay 和 Nicepay 网关服务不稳定，影响关联支付方式支付成功率，接入更多的网关提高支付的容灾性和为支付路由做准备。</p><p>目前所有支付方式至少保持了一主一备网关，当一网关发生故障时，迅速切换到另一网关上，提供支付稳定性、降低支付失败率。</p><p><strong>（2）如何选择接入的网关？</strong></p><ol><li>看支付公司的背景和应用商户的体量，在行业内的知名度和排名；</li><li>稳定性和成功率；</li><li>手续费和结算周期；</li><li>支付流程。如提供接口全不全（是否有轮询接口）、关联支付方式全不全、接口性能好不好等。</li></ol><p><strong>具体哪个点优先级最高，根据公司当前战略而定。</strong>如公司发展早期，业务探索、业务量小，手续费会优先于支付稳定性和成功率；当前阶段，公司拿到融资，需要更大的订单量进行下一轮融资，每一笔订单的支付都显得弥足珍贵，支付稳定性和成功率高于手续费。</p><p><strong>（3）网关接入的核心产品流程有哪些？</strong></p><p>标准的创单、请求支付、支付结果通知、轮询、退款、退款通知、取消订单和对账。</p><p><img src="http://image.woshipm.com/wp-files/2019/08/NuhskSrFw95YuijbYQ8k.jpg" alt="img"></p><p>还需要重点注意差错的处理机制，包括掉单后的补单、查询机制和重复支付处理机制。</p><p><strong>（4）支付系统的差错处理？</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/08/1j9qbPDJTrfQUya7WJIY.jpg" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2019/08/VvwTFEfmzs9kDaHoOjFQ.jpg" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2019/08/juiImzrUYPlIjSPu4TLH.jpg" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2019/08/uMSDl67Gt4ybp2HsATh8.jpg" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2019/08/VbMa9UvlKmF9Kh6VCQmC.jpg" alt="img"></p><h3 id="3-接入GoPay-和-DANA网关"><a href="#3-接入GoPay-和-DANA网关" class="headerlink" title="3. 接入GoPay 和 DANA网关"></a>3. 接入GoPay 和 DANA网关</h3><p><strong>（1）GoPay 和 DANA 接入背景？</strong></p><p>在线支付的快捷、便利比印尼传统的便利店和VA较大程度的提高支付成功率。可以看到，电子钱包在购物app上使用率仅次于传统VA的Mobile banking。</p><p><img src="http://image.woshipm.com/wp-files/2019/08/f1MZ5LjzlaGuuBhnxAJR.jpeg" alt="img"></p><p>GoPay 是用户最喜欢的电子钱包，市场占有率65%，7000万用户（OVO45%，6000万用户；LinkAja40%，2600万用户；DANA20%，1500万用户）。</p><p>GoPay依赖的GoJek几乎成为印尼人的骄傲，超过8000万注册用户，2000万月活，400万日活，日单500-600万，在印尼的地位类似腾讯。故GoPay接入优先级最高。</p><p><img src="http://image.woshipm.com/wp-files/2019/08/BzAiNZuS9f2skX7rYWLe.jpeg" alt="img"></p><p>DANA虽然市场占有率远远低于GoPay 和 OVO，但是公司和DANA蚂蚁金服战略合作，属于资源互换项目，所以优先级高于了OVO。</p><p><strong>（2）GoPay 和 DANA 接入相同点和不同点？</strong></p><p>GoPay 通过Midtrans 网关接入，已接入Midtrans 网关的情况下，GoPay 接入比较快，不需要新增接口；DANA是纯电子钱包接入，所有接口需要额外开发。</p><h3 id="4-日常数据监控"><a href="#4-日常数据监控" class="headerlink" title="4. 日常数据监控"></a>4. 日常数据监控</h3><p>支付环节属于核心流程，任何系统不可能确认100%没有bug，但我们需要确保出现任何问题都能第一时间监控到。监控分为<strong>系统监控和业务监控</strong>两种，通过Grafana和企业微信提示监控人。</p><p>系统监控指核心接口是否正常：如<strong>创单、支付结果通知接口</strong>按<strong>请求次数和请求时长</strong>维度加上接口监控；</p><p>业务监控指业务数据是否正常：如一小时内<strong>支付成功人数、支付成功单数、支付成功率</strong>。</p><p>从异常数据采集到故障问题主动发现，优化产品，降低支付失败率。</p><h3 id="5-支付营销"><a href="#5-支付营销" class="headerlink" title="5. 支付营销"></a>5. 支付营销</h3><p>支付营销的目的对于平台来讲，个人觉得更多在加强公司和其他公司的战略合作，给具体的某一支付方式引流，如GoPay，对提高整体支付成功率没有特别大的帮助（因为用户进到支付环节，已经有很明确的支付意愿了，只是选哪种支付方式的问题，很小概率由于某种支付方式有折扣，本身不愿意支付而去支付）。</p><p>相比于接新的在线支付方式提高整体支付成功率优先级没有那么高。Cashback是印尼最受欢迎的营销形式，目前平台也最先做这种营销方案。支付营销不是支付核心模块，所以此处不做额外拓展。</p><h2 id="支付体系"><a href="#支付体系" class="headerlink" title="支付体系"></a>支付体系</h2><p>支付已像空气一般渗透了人们生活的方方面面，大大小小的经济行为都无法离开支付，从而支付产品经理也在互联网的浪潮中，逐渐成为各行业的标配岗位。</p><p>公司要盈利，就需要有交易，有交易就需要收钱。我刚开始接触支付时，一心扑在电商上，后来才知道支付是通往金融的钥匙，放贷还款也需要通过支付，重要性不言而喻。</p><p>在支付领域本身方向上，也有更细的岗位划分，如支付渠道产品经理，交易产品经理、支付结算产品经理、支付风控产品经理等。就支付系统的复杂度而言，每个模块可能都需要2年左右的实践经验才能基本摸透，如要完全吃透某个模块，一是需要个人的努力，二离不开公司业务的发展带来的实践经验，两者缺一不可。</p><h2 id="一、支付产品经理分类"><a href="#一、支付产品经理分类" class="headerlink" title="一、支付产品经理分类"></a>一、支付产品经理分类</h2><p>我个人理解将支付产品经理分为两类：</p><h3 id="1-第三方支付或第四方支付公司的支付产品"><a href="#1-第三方支付或第四方支付公司的支付产品" class="headerlink" title="1. 第三方支付或第四方支付公司的支付产品"></a>1. 第三方支付或第四方支付公司的支付产品</h3><p>无论是第三方支付还是第四方支付其实都是市场需求推动的结果，总得来说都是为了<strong>提高效率</strong>。</p><p><strong>第三方支付承接商户和银行，常见支付宝和微信。</strong>银行没有那么多时间去一个个对接大大小小的电子商务平台。反过来，一个电子商务公司，要去接入全国那么多家银行系统，从投入成本上来说也不现实。</p><p>第三方支付公司的出现解决了这个问题，我帮你对接所有银行，你只需要接我一个就行了。反过来对银行也一样，只要系统和一家第三方支付公司对接，就可以实现为多家电子商务公司的用户提供金融服务。</p><p>目前第三方支付市场里，支付宝和财付通两大巨头已占据将近80%的市场份额。而排名前十的支付机构又占了全国90%左右的交易量。这些支付机构包括：</p><ol><li>财付通</li><li>支付宝</li><li>京东钱包</li><li>银联云闪付</li><li>翼钱包</li><li>百度钱包</li><li>Apple pay</li><li>移动和包</li><li>苏宁支付</li><li>易宝支付</li></ol><p>第四方支付，也即聚合支付，如线下付款时，收银员拿着扫码枪扫你的支付宝或者微信码，常见如收钱吧。</p><p>是商家和第三方支付机构的连接桥梁，为商户提供了一个可以统一各种主流支付渠道的聚合支付产品，无论是微信、支付宝、京东支付、百付宝、银联等，方便用户付款；又可以方便商户进行账单管理与核对，不用多渠道对账。</p><h3 id="2-互联网金融、电商平台等一定需要专业的支付结算产品经理"><a href="#2-互联网金融、电商平台等一定需要专业的支付结算产品经理" class="headerlink" title="2. 互联网金融、电商平台等一定需要专业的支付结算产品经理"></a>2. 互联网金融、电商平台等一定需要专业的支付结算产品经理</h3><p>公司发展一般分阶段。</p><p><strong>第一阶段：</strong>公司在业务发展初期的时候接入支付，最多也就1-2个渠道，并且这时候主要是为了验证业务的可行性，所以很多公司这时候支付模块并没有拆分出来，耦合在业务系统里。现在很多公司考虑到未来支付的扩展性和账务等问题，已经开始招专业的支付人才来做这事。</p><p><strong>第二阶段：</strong>在这个阶段业务已经有一定规模，支付已经成为业务支撑系统当中重要的一环，此时还需完善支付系统的一系列功能，如会员系统（账户系统）、交易系统、资金系统、渠道路由系统，还涉及用户端、商户端、整个支付清算对账体系等，没相关背景的产品经理是搞不定的。</p><p><strong>第三阶段：</strong>发展到这个阶段，已经不仅仅只是为公司业务提供收单支付服务了更多的会做一些延展性的服务比如说对商户的供应链金融、对用户的分期贷款等服务。</p><h2 id="二、进阶路径"><a href="#二、进阶路径" class="headerlink" title="二、进阶路径"></a>二、进阶路径</h2><ul><li><strong>初级</strong>：接入支付方式和支付渠道，提供产品层面方案，比如实名、绑卡、支付、提现等；</li><li><strong>中级</strong>：整合渠道，设计路由系统、对账系统等；</li><li><strong>高级</strong>：熟悉政策法规，设计支付结算底层系统，如账户体系、记账系统、风控系统等。</li></ul><p>虽然同为互联网产品经理，作为支付产品经理与其他偏内容、体验导向的互联网产品经理（例如微博、门户、SNS等）在技能有很多不同。</p><p><strong>最大的差异在于：支付产品经理需要较强的逻辑思维能力，并对后端系统技术实现有一定的理解。</strong></p><p>主要原因在于支付系统最为麻烦不在于前端的用户体验，而是后端复杂业务逻辑。<strong>如果不理解已有系统的需求场景、实现逻辑、局限性、约束，那最终产品经理只能沦落为需求的传声筒。</strong>这也是为何诸多支付公司的技术同学们总觉得产品经理可有可无（虽然偏妥，但也不无道理）。</p><p>因此，好的支付产品经理，都是坑里爬出的勇士。才了解到《支付系统设计白皮书》作者说自己做支付自学了会计。</p><h2 id="三、知识架构"><a href="#三、知识架构" class="headerlink" title="三、知识架构"></a>三、知识架构</h2><ol><li><strong>支付原理</strong><strong>&amp;产品设计。</strong>学习支付整套产品设计流程和原理，例如收银台等页面和流程，下单、支付结果通知、退款等基本支付接口，系统信息流和资金流如何扭转。国内很成功的微信和支付宝接口必读；当然正常的流程只是支付产品很小的一部分，异常流程往往更重要，如掉单、重复支付等；</li><li><strong>合规政策。</strong>了解金融管理部门法律法规，避免二清反洗钱，了解自己的业务需要的资源，在产品策划的过程中避免违规；</li><li><strong>风控体系。</strong>除了常见用户侧异常例如网络问题，支付产品的风控庞大得多，需要考虑的有信息存储和安全，用户安全等级，银行系统问题甚至黑客攻击，如何防范和应对；</li><li><strong>财务****对账系统。</strong>因为直接涉及到钱，支付产品的纠纷往往更严重，因此设计完整和齐全的客服体系，照顾到各种异常情况，确保有应对方案。</li><li><strong>会计基础。</strong>由于作为支付的产品经理，很难不涉及到记账问题。实际上，了解清楚会计的基本原理、记账规则、科目设置等内容即可，不会超出《会计从业资格》这个范围；</li></ol><h2 id="四、学习方法"><a href="#四、学习方法" class="headerlink" title="四、学习方法"></a>四、学习方法</h2><ol><li>多体验竞品的产品流程和分析其行业解决方案，扩大知识面及视野；</li><li>支付偏技术，强逻辑，多阅读接口文档进行深层次了解，思考产品设计时知道技术上大致怎么实现，达到和技术沟通无障碍。多参与技术实现细节的讨论中，不耻下问，向技术了解系统实现逻辑；</li><li>在日常产品设计中，对自己高标准要求，不要以传声筒或撒手掌柜的标准来要求自己。在产品方案中，强迫自己写清楚产品业务用例的实现逻辑；</li><li>积极参与运营日常问题处理，从问题入手，进而熟悉所负责产品的行业需求、业务逻辑、问题、行业知识；</li><li>自主学习会计等学科、了解政策等规范。</li></ol><p><strong>鉴于上，需要学习和提高的地方很多，个人觉得做支付产品有一定门槛，不过有门槛才有竞争力。道阻且长，我刚上路，与君共勉。</strong></p><h2 id="收银台"><a href="#收银台" class="headerlink" title="收银台"></a>收银台</h2><p>线下购物场景中，收银台是顾客在超市最后停留的地方。互联网的发展，线下场景转移到线上，线上的收银台也是用户在网站最后的停留位置。</p><p><strong>交易的存在是支付发生的前提，使用支付方式让交易完成</strong>，支付是交易达成的最后一个环节，这通过支付产品之一的收银台来实现。</p><p>公司内部往往有多条业务线，凡是商业活动一定涉及收款，支付系统扮演平台的角色，为多条业务线提供收款能力，接入的业务线我们称之为商户。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/EyQrDJrJ2d9weK24A5t8.png" alt="img"></p><p><strong>支付平台向商户提供C端支付产品和B端商户平台两种类型的支付产品。</strong>商户接入一种C端支付产品<strong>向用户提供支付服务</strong>，同时使用B端商户平台向C端支付产品<strong>进行功能配置</strong>，这样商户就具备了<strong>收款能力</strong>。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/9m5aouJvweOlsvw9Ewxf.png" alt="img"></p><p>今天重点讲C端支付产品的收银台。</p><p>之前有一些人问到我，支付还需要专门的产品经理吗？接入国内的支付宝和微信不就完了嘛。事实上，大家看到的支付只是冰山一角，仅看商户平台的功能模块中，风控、路由、对账等都是大家看不到的后台支持模块，前端觉察不到却需要花很大功夫去做。</p><h2 id="一、概念解释"><a href="#一、概念解释" class="headerlink" title="一、概念解释"></a>一、概念解释</h2><p>以支付平台的角色来看（支付平台往往接入多家支付渠道，比如支付宝、微信支付和京东支付等），需要解决公司各个业务线在不同场景下，对收银台提供支付方式的不同需求。</p><p>所以收银台有两层概念，分别为：能够提供的<strong>收银台类别</strong>以及各种收银台上能够<strong>支持的支付方式</strong>及<strong>提供支付方式的支付网关</strong>。这里涉及到三个名词概念：<strong>支付产品、支付方式和支付网关。</strong></p><h3 id="1-支付产品"><a href="#1-支付产品" class="headerlink" title="1. 支付产品"></a>1. 支付产品</h3><p>适用不同业务的不同场景的API接口，<strong>不同收银台类型即不同的支付产品。</strong>这里定义了四类：</p><ol><li>PC收银台：电脑PC端完成支付的收银台；</li><li>H5收银台：手机内的H5网页上完成支付的收银台；</li><li>APP收银台：商户APP内完成支付的收银台（APP上使用，不含前端页面）；</li><li>API收银台：提供给商户自己进行包装成自己收银台前端页面的底层接口（不含前端页面，商户自己设计前端页面）。</li></ol><p>不同的支付产品有不同的优缺点，比如PC和H5收银台相较于API收银台，商户接入不需要开发前端页面，接入后可直接使用，但缺点可能是与上游的业务系统UI风格不一样，所以商户接入时要视自己的实际情况而定。</p><p>大家对支付方式这个概念很熟悉，对支付产品这一概念可能陌生。事实上，支付宝、微信支付等对支付产品有明确的定义。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/vxvDyQXG3Q41NAEcH0gp.png" alt="img"></p><p>例如微信支付根据用户不同的支付场景<strong>定义了不同的支付产品：付款码支付、APP支付等。</strong></p><p>在APP上使用微信支付时，我们常常称作微信支付，但从微信支付产品角度看，称APP支付。（大家可以自行去微信支付开发文档上查阅）</p><p><img src="http://image.woshipm.com/wp-files/2021/02/uHScyTn4m0xmbmMly03B.png" alt="img"></p><h3 id="2-支付方式"><a href="#2-支付方式" class="headerlink" title="2. 支付方式"></a>2. 支付方式</h3><p>不同支付产品的支付方式在支付流程时可能会有差别，比如PC收银台的支付宝是外跳转到支付宝收银台页面。但用户在浏览器中访问商家网页应用，选择商品下单、确认购买，进入支付环节，选择支付宝付款，用户点击去支付，进入到支付宝支付路由页面。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/U8AMxpjMBQN5gzYsqbh2.png" alt="img"></p><h3 id="3-支付网关"><a href="#3-支付网关" class="headerlink" title="3. 支付网关"></a>3. 支付网关</h3><p>PC收银台的支付宝和H5收银台的支付宝，这两种支付方式对应的支付网关都是支付宝网关。</p><p>不管是接入PC支付宝还是H5 支付宝，首先都需要商务层面先签约，同支付宝签约<strong>这两种支付产品，成为我们支付平台的两种支付方式，进而支付平台的两种支付产品也得到丰富和完善</strong>。</p><p><strong>总的来说，支付网关是为了提供不同类型的支付方式，多种支付方式丰富了支付产品，支付产品向公司不同业务提供服务。</strong></p><p>业务的持续发展需要不断完善支付产品，比如线上拓展到线下，那就需要新增线下的一种支付产品，进而也需要对应线下的支付方式和支付网关。</p><p>支付方式和支付网关并不是1：n的关系，有些支付方式并不仅仅通过一种支付网关来提供，比如招行快捷支付，既可以通过支付宝网关也可以通过银联网关，从系统稳定性或者商务层面的网关费率等因素考虑，同一支付方式对接不同的支付网关也是支付平台要拓展的方向。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/OrPVBhgSBUefiorKmuWO.png" alt="img"></p><h2 id="二、收银台产品设计思路"><a href="#二、收银台产品设计思路" class="headerlink" title="二、收银台产品设计思路"></a>二、收银台产品设计思路</h2><p><img src="http://image.woshipm.com/wp-files/2021/02/kk12kBgLz9fCIGaga7mo.png" alt="img"></p><p><strong>1、明确用户目标。</strong>明确用户使用你的产品要完成什么任务，这里用户使用收银台是要<strong>完成支付</strong>。</p><p><strong>2、拆解用户行为路径。</strong>根据用户行为过程：触达-参与-完成，拆解用户使用收银台这一产品的支付过程：<strong>支付前-支付中-支付后</strong>，在这三个阶段中用户分别有在该阶段要做的操作行为。</p><p><strong>3、为每个阶段找到对应的产品目标。</strong>产品是用户行为的载体，产品必须要有目标，这样才能聚焦。收银台的<strong>总目标为安全、简单，</strong>至于为什么是这两个目标，这得从支付的起源说起。</p><p>在近二十年来，支付方式经历了不少演变。支付方式从最早的现金交易，到后来的刷卡消费、线上支付，以及分期支付。支付这些年一直在变化、在丰富、在演进，但它一直在解决两个核心问题：信任和效率，对应到支付产品上来，即是<strong>安全和简单。</strong></p><p><img src="http://image.woshipm.com/wp-files/2021/02/AeIPrxqAV5yHC9lSeqjU.png" alt="img"></p><p><strong>4、找到衡量产品目标的数据指标。</strong>产品好不好，数据来说话。用户操作行为的各个阶段指标为<strong>时长和转化率</strong>，但<strong>北极星指标为</strong>用户从达收银台列表到支付完成，获取支付结果这一整个<strong>订单成功转化率</strong>。</p><h2 id="三、收银台功能设计"><a href="#三、收银台功能设计" class="headerlink" title="三、收银台功能设计"></a>三、收银台功能设计</h2><p>整体上分三块：用户使用的<strong>收银台前端页面</strong>、商户对收银台<strong>进行配置的商户平台</strong>和看不见的<strong>支付系统</strong>。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/Ck2aOtWZCh2xmOva8Ulk.png" alt="img"></p><h3 id="3-1-收银台"><a href="#3-1-收银台" class="headerlink" title="3.1 收银台"></a>3.1 收银台</h3><p>按照前面讲到的用户行为路径<strong>支付前-支付中-支付后</strong>列举功能点依次为：</p><p><strong>（1）页面的通用模块</strong></p><p>页面的标题、底部的一些信息展示。</p><p><strong>（2）订单相关信息展示</strong></p><p>订单有效时间。业务系统告知，订单有效时间可能不唯一，比如常规订单也许1小时，但是活动订单也许15min。</p><p>订单待支付金额。订单需要支付的金额，业务系统告知，值是唯一不变的，即使用余额、礼品卡等和支付宝组合支付，该值也不应该变，表明订单需要被支付金额，而不管使用何种支付方式支付。</p><p>商品信息和发货信息。业务系统告知，非必须字段，看商户订单类型，如苹果官网主要售卖高客单价商品，用户对商品和地址会更关注。</p><p><strong>（3）支付方式展示</strong></p><p>涉及到可展示出来的支付方式有哪些以及这些支付方式的的排序规则。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/ff7rkbTsi9KiISga6KkC.png" alt="img"></p><p><strong>（4）默认支付方式选中规则</strong></p><p>默认让用户使用哪种支付方式，减少用户的操作成本（直接选择底部确认支付按钮发起支付）。可以用户自定义设置，比如京东的收银台默认支付工具。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/ecsETvWjgoHIMaac2JWL.png" alt="img"></p><p>也可以采用动态策略。动态策略一般从几个方面考虑：用户最近使用的支付方式、用户最常用的支付方式、限额满足条件、公司推广的支付方式等，这个要根据公司的业务发展来综合考量默认支付方式的展示规则。</p><p><strong>（5）营销信息展示</strong></p><p>支付也涉及营销，比如分期支付方式的免息配置，某种支付方式的推广，与银行或通道洽谈的优惠</p><p>政策，例如，绑定XX银行的卡享受随机立减优惠等。</p><p><strong>（6）确认支付</strong></p><p>确认支付后，支付系统和第三方网关开始交互，调用后端获取支付参数和支付网关，请求网关发起支付请求。确认支付时还要考虑此时是单一支付，还是组合支付或者是拆单支付。</p><p>用户选择支付方式，确认支付后，开始发起支付。不同的支付方式支付流程有较大差异，这里以商户的H5收银台，用户选择支付宝支付，且用户已安装支付宝为例。</p><ol><li>用户在浏览器中访问商家网页应用，选择商品下单、确认购买，进入支付环节，选择支付宝付款，用户点击去支付，如下图 1;</li><li>进入到支付宝支付路由页面，支付宝处理支付请求，并尝试唤起支付宝客户端，如下图 2（此页无法自定义删除）；</li><li>进入到支付宝页面，调起支付宝支付，出现确认支付界面，如下图 3；<img src="http://image.woshipm.com/wp-files/2021/02/n4kR3hq11pxiD9eGWi2U.png" alt="img"></li><li>用户确认收款方和金额，点击立即支付后出现输入密码界面，如下图 4；</li><li>输入正确密码后，支付宝端显示支付结果，如下图 5；</li></ol><p><img src="http://image.woshipm.com/wp-files/2021/02/Tb3gb2B0icqCvq0W7Ju7.png" alt="img"></p><p>支付后用户主要是回到商户网站确认订单支付状态，商户也要根据支付结果个性化展示订单处理结果。</p><p><img src="http://image.woshipm.com/wp-files/2021/02/arw7s1ANsiET4XMFXLc5.png" alt="img"></p><h3 id="3-2-商户平台"><a href="#3-2-商户平台" class="headerlink" title="3.2 商户平台"></a>3.2 商户平台</h3><p>向商户提供配置收银台的一些功能，以下为主要功能模块介绍。</p><ul><li>接入商户信息配置，如商户号等信息。</li><li>渠道中心。渠道的账号配置、渠道是否可用、渠道关联的支付方式等配置。</li><li>支付方式中心。支付方式禁用策略、支付方式排序策略配置。</li><li>风控中心。黑名单、风控规则引擎、风控告警等配置。</li><li>路由中心。支付渠道的分流规则配置，在不同端，不同业务和商品，不同的用户，可以使用什么支付渠道。</li><li>营销中心。免息、支付方式推广等配置。</li></ul><h3 id="3-3-支付系统"><a href="#3-3-支付系统" class="headerlink" title="3.3 支付系统"></a>3.3 支付系统</h3><p>看得到的支付产品后面一定有看不到的系统支撑着，这是支付系统。这里只做简单讲述。</p><p>用户进到收银台列表，支付系统会当前的业务订单生成一笔自己的支付订单，用户每选择一次支付方式，支付系统会请求第三方创建一笔交易，交易中的交易号用来跟第三方网关交互，同时支付系统也会创建一些参数向第三方网关发起支付（发起支付成功，第三方页面才会打开），若用户支付成功，支付系统还会将该笔交易流水推送给财务系统，供财务进行对账查询。<br><img src="http://image.woshipm.com/wp-files/2021/02/WWshhA9IRm3KSGChyoXW.png" alt="img"></p><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>以上为收银台的简要介绍，可以发现，大家看到的某电商收银台这层皮，其实只是冰山一角，真正在解决问题的，是多数人都看不到的水面下的血肉和骨骼。</p><p>如果你想从0到1设计一个收银台，需要先做好以下几个准备：</p><p><strong>（1）了解公司业务模型</strong></p><p>知道业务是怎么样的，售卖的是什么商品，是电商、游戏、课程售卖等等。其实就是卖什么，怎么卖的问题。假设是电商平台，卖的是实物商品，假设售卖课程，卖的就是虚拟商品，实物商品和虚拟商品要考虑的业务规则肯定不同。</p><p><strong>（2）选择支付方式</strong></p><p>想好计划为用户提供什么可用的支付方式，比如微信支付，支付宝支付，银行卡快捷支付，账户余额支付？一般微信支付宝就够了，难免有用户想直接绑定信用卡去支付，虽然通过微信支付宝也可以使用信用卡支付；这个看平台选择，如果有能力尽可能给用户更多的选择，覆盖更多的用户群体需求。</p><p><strong>（3）签约支付通道</strong></p><p>支付宝或者微信的某一支付产品，不能直接接入，首先要合同签署。</p><p><strong>（4）确定收银台的支撑系统</strong></p><p>收银台要想能完成支付至少需要哪些系统，账号、渠道和支付方式的数据结构是怎样的，哪些功能做成可配置，这些要提前做好技术方案。</p><p><strong>（5）根据网关提供API文档接入</strong></p><p>最后一步根据网关提供的API文档接入支付和退款流程即可。</p><h2 id="收银台管理2"><a href="#收银台管理2" class="headerlink" title="收银台管理2"></a>收银台管理2</h2><p><strong>收银台流程、支付渠道管理以及充值处理流程。</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/DK8QT8nXYHF3mtj1cnLi.png" alt="img"></p><h2 id="一、收银台流程"><a href="#一、收银台流程" class="headerlink" title="一、收银台流程"></a>一、收银台流程</h2><p><img src="http://image.woshipm.com/wp-files/2018/07/4wXlTCOMTyhMcPaw2dom.png" alt="img"></p><p>我们在日常生活及业务中，了解到关于收银台的逻辑大致入上图所示，就是收银台前端的基本逻辑，相对来说比较简单。</p><p>但从后端技术层面来讲，里面的内容大致如下：</p><h3 id="1-充值或者支付的请求"><a href="#1-充值或者支付的请求" class="headerlink" title="1. 充值或者支付的请求"></a>1. 充值或者支付的请求</h3><p><img src="http://image.woshipm.com/wp-files/2018/07/m7dXbuyfyvHL3wXC8Ar5.png" alt="img"></p><p>发起支付或者充值请求之后，一般分为 3 种情况：</p><ol><li>站内支付；</li><li>站外支付；</li><li>充值。</li></ol><p>站外支付又分为：线上支付和线下支付。</p><p>线上支付的具体类别可大致分为 3 种：<strong>账户支付、网管支付以及快捷支付。</strong></p><h3 id="2-提供默认可用支付-充值渠道"><a href="#2-提供默认可用支付-充值渠道" class="headerlink" title="2. 提供默认可用支付/充值渠道"></a>2. 提供默认可用支付/充值渠道</h3><p>流程开始之后，首先需要处理可用的支付渠道，其中的流程顺序为：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/QuMgGMATzSnnOrYsJSi4.png" alt="img"></p><ol><li>取得总支付渠道限制，获得可用支付渠道的一个合集；</li><li>取得业务对支付渠道的限制，这一环节就会得出一个与上一环节可用支付渠道的交集；</li><li>检查收款方限制；</li><li>检查商品限制；</li><li>再次检查收款方限制；</li><li>检查用户设定限制。</li></ol><p>每个环节都会得到一个与上一环节可用支付渠道的交集，并得出本环节可用支付渠道的最终合集，层层筛查，进入下一环节。</p><h3 id="3-处理优先默认的支付渠道"><a href="#3-处理优先默认的支付渠道" class="headerlink" title="3. 处理优先默认的支付渠道"></a>3. 处理优先默认的支付渠道</h3><p><img src="http://image.woshipm.com/wp-files/2018/07/JF2Hp9kbd4HBtmlctrMj.png" alt="img"></p><p>进入这一流程时，首先会对业务产品指定有一个判断，在非业务产品指定的大前提下：</p><p>首先判断是否提供支付账户，如果提供，则根据账户记忆进入下一步，再次判断是支付渠道是否可用，在可用的情况下则按指定规则有限默认完成本环节进入下一环节。在不可用的情况下按原始规则有限默认，并完成本环节进入下一环节。</p><p>如果不提供支付账户，则根据 cookies 记忆进入下一步，判断支付渠道是否可用，再根据实际情况选择指定规则有限默认或原始规则有限默认结束并进入下一环节。</p><p>当然，如果判断是业务指定产品，则直接进入支付渠道是否可用的判断，后续判断环节与上述相同。</p><h3 id="4-用户选择支付-充值渠道环节"><a href="#4-用户选择支付-充值渠道环节" class="headerlink" title="4. 用户选择支付/充值渠道环节"></a>4. 用户选择支付/充值渠道环节</h3><p>这一节与我们的日常生活比较贴近，所以非常好理解。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/rkmR4lIObmwLw4QVfCL0.png" alt="img"></p><p>首先是用户选择支付渠道，会立即进入一个是否满足手机护航的判定：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/7aB7wJvkCZmnSc3cHl6K.png" alt="img"></p><ul><li><strong>判定满足：</strong>那就输入手机动态口令和支付密码，然后进行一次校验，校验没有问题就进入支付渠道限额检查。这里风控会同步进行一个控制，成功之后就会执行支付了。</li><li><strong>判定不满足：</strong>则输入支付密码，同样经过校验后进入支付渠道限额检查、风控控制，成功之后执行支付。</li></ul><p>其次是用户选择充值渠道，这里列举了几个比较有代表性的充值渠道：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/Md8l41eGaWRG07SgJ9xa.png" alt="img"></p><p>根据各渠道特性流程上略有区别，例如：快捷充值，选择快捷充值，登录账户后选择一开通快捷支付的银行卡，输入充值金额，按照提示输入支付密码和手机验证码来完成支付。</p><h2 id="二、支付渠道管理"><a href="#二、支付渠道管理" class="headerlink" title="二、支付渠道管理"></a>二、支付渠道管理</h2><p>这一部分内容主要分为 3 个小版块：<strong>支付渠道任务模型、支付渠道各类配置以及支付渠道优先默认规则。</strong></p><h3 id="1-支付渠道任务模型"><a href="#1-支付渠道任务模型" class="headerlink" title="1. 支付渠道任务模型"></a>1. 支付渠道任务模型</h3><p>服务使用模型：“服务使用”是最常见也是最复杂的支付渠道配置目标。</p><p>因此在本章中，主要针对服务使用模型来举例：</p><p>假设 2018 年 7 月 3 日，卖家秋秋老师与买家支付学院主任在购物平台上通过招行 B2C 网关渠道使用商品购买服务交易一个数码产品鸭梨手机。</p><p>分为六个维度来解读：</p><ol><li><strong>服务维度</strong>：服务维度是对所有服务从业务角度划分得到的标准分类体系，这套分类体系不但能够井井有条地组织所有的业务服务，而且在未来推出新的服务时，可以方便地进行扩展。基于这套标准分类体系，我们为每一个具体的服务分配唯一、固定的 ID，作为所有子系统对同一个服务的公共标识。</li><li><strong>时间维度</strong>：时间维度的结构比较简单，它是一个连续维度。每次服务使用都有一个发生时间，对应于时间维度上的一个点，精确到毫秒。如支付渠道可用性规则，需要在客户进入收银台的这个时间点进行处理；如是否启用 CTU 防火墙规则，需要在客户确认支付后未支付出去前进行检查并启用等。</li><li><strong>渠道维度</strong>：渠道代表客户使用服务的“界面”，它是服务提供者与服务使用者的交互方式。通过构建一个层次模型，渠道分为两级：第一级是主渠道类型，第二级是子渠道类型。</li><li><strong>客户维度</strong>：客户在这里是指服务的具体使用者，在“以客户为中心”的业务中，支付机构会为不同的客户提供不同的服务与可用性策略。为了更好地服务客户，满足客户/客户群的个体性需求，业务上需要对客户进行分级。对于客户，我们首先要区分他属于内部、集团还是外部；其次，我们需要区分他的性质，即他是个人还是公司；再次，我们需要区分他的级别，暂时划分为普通与签约。</li><li><strong>行业维度</strong>：针对不同行业的交易标的由于交易价格、成本与利润差异很大，因此在业务上需要有不同的支付渠道可用性标准。在业务层面上，商品是隶属于客户或市场的。而随着商品所属行业的不同，商品本身的特点，均需要以不同的支付渠道来支持其可变性，以确保安全、成本等环节的控制。</li><li><strong>市场维度</strong>：市场在这里是指引导客户使用支付产品服务的场所，它可能是支付产品自己，可能是相关公司或平台的其它网站，如：淘宝，也可能是外部的交易平台商。由于同样的服务可以针对不同的市场来定制规则，因此，在服务使用中也需要包含市场这个维度。</li></ol><h3 id="2-支付渠道优先默认规则"><a href="#2-支付渠道优先默认规则" class="headerlink" title="2. 支付渠道优先默认规则"></a>2. 支付渠道优先默认规则</h3><p><img src="http://image.woshipm.com/wp-files/2018/07/39PzEpWTg7Ghk8FTbvim.png" alt="img"></p><h2 id="三、支付处理流程"><a href="#三、支付处理流程" class="headerlink" title="三、支付处理流程"></a>三、支付处理流程</h2><p>这一部分主要分为 4 个板块： <strong>B2C 充值、 B2B 充值、快捷充值以及余额支付 / B2C 支付。</strong></p><p><strong>（1）B2C 充值:</strong></p><p><strong>充值流程：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/nuio51i70y6CpyPVoGFm.png" alt="img"></p><p>具体功能为：①客户点击充值功能；②收银台提供充值页面；③客户输入充值金额；④客户选择充值渠道；⑤客户确认充值信息；⑥请求充值服务；⑦生成银行报文；⑧提交银行处理；⑨客户在网银上进行相关操作；⑩接到银行返回信息；⑪为客户展示充值结果。</p><p><strong>（2）B2B 充值</strong></p><p><strong>充值流程：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/AgJIjcJaY5txuqmZlxWA.png" alt="img"></p><p>具体功能为：①客户点击充值功能；②收银台提供充值页面；③客户输入充值金额；④客户选择充值渠道；⑤客户确认充值信息；⑥请求充值服务；⑦生成银行报文；⑧提交银行处理；⑨客户在网银上进行相关操作；⑩接到银行返回信息；⑪为客户展示预授权结果信息；⑫企业进行本笔充值复核；⑬确认充值完成。</p><p><strong>（3）快捷充值流程</strong></p><p><strong>充值流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/CllR7YBxAwC5YRU4F0PS.png" alt="img"></p><p>具体功能为：①客户点击充值功能；②收银台提供充值页面；③客户输入充值金额；④客户选择充值渠道；⑤客户输入支付密码；⑥检查支付密码是否正确（判定）；⑦请求充值服务；⑧生成银行报文；⑨提交银行处理；⑩接到银行返回信息；⑪为客户展示预授权结果信息。</p><p><strong>（3）余额支付 / B2C 支付</strong></p><p><strong>具体功能：</strong></p><p>1）余额支付：</p><ol><li>客户进入收银台，选择余额支付。当余额不足时，允许一卡通、网银进行补支付；</li><li>客户输入支付密码，检查支付密码的正确性；</li><li>检查证书情况；</li><li>若启用了手机护航，则进行收集动态口令的校验；</li><li>CTU 防火墙的检查；</li><li>继续推进支付；</li><li>收银台提供支付结果信息。</li></ol><p>2）B2C 支付流程：</p><ol><li>客户进入收银台，选择网银支付；</li><li>客户选择 B2C 的银行进行支付；</li><li>客户确认支付信息；</li><li>请求充值服务；</li><li>生成银行报文；</li><li>提交银行处理；</li><li>客户在网银上进行相关操作；</li><li>接到银行返回信息；</li><li>继续推进支付；</li><li>收银台提供支付结果信息。</li></ol><h2 id="支付核心"><a href="#支付核心" class="headerlink" title="支付核心"></a>支付核心</h2><p>支付核心：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/WnaIDUSGFiZZWq8shUGM.png" alt="img"></p><h2 id="一、支付核心和清算核心职责"><a href="#一、支付核心和清算核心职责" class="headerlink" title="一、支付核心和清算核心职责"></a><strong>一、支付核心和清算核心职责</strong></h2><p>首先要明确一个概念：一个完整的支付清算系统结构内，各种特定业务所涵盖的支付服务、清算服务，是相互独立的。</p><p>其独立性，体现在具体的产品研发过程，以及后期维护等各项工作中：</p><ol><li>这种现状导致了业务产品开发复杂化、风险性提高；</li><li>支付与清算的相关规则各自为政，彼此独立，加大管理难度；</li><li>在开放平台的大背景下，也不能提供给大量外部业务系统所需要的基础支付服务；</li><li>若清算服务部署于在后台管理系统，各类清算细则繁冗复杂，对运营部门造成很大不便性。</li></ol><p><strong>在设计支付清算系统时建议：</strong></p><p>将支付核心和清算核心设计为两层，分为两个独立子系统。</p><ol><li>支付核心提供适应各类产品使用的基础支付服务；</li><li>清算核心则将所有机构所能提供的底层清算服务归集，专门负责与银行的各类清算接口对接。</li></ol><p>支付层则对外提供各类经过包装的支付服务，涵盖清算服务、账务服务、客户相关服务等，实现对基础支付服务的编排。</p><h2 id="二、提现协议系统业务流程分析"><a href="#二、提现协议系统业务流程分析" class="headerlink" title="二、提现协议系统业务流程分析"></a><strong>二、提现协议系统业务流程分析</strong></h2><p><strong>前提：</strong>以同步/异步的维度划分提现支付协议，得出两类提现支付协议的处理流程。</p><p><strong>维度：</strong>会员层、提现产品层、支付层、财务核心、清算层、银行。</p><p><strong>（1）同步提现支付协议处理流程图</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/quYoYqBoRZ2I7RCuL0BG.png" alt="img"></p><p>会员提交提现申请后，进入提现产品层申请同步提现支付协议，然后进入支付层请求扣款提现金额。此时进入财务核心执行扣款，同时报送清算请求指令进入清算层，报送银行处理，然后进入银行执行扣款并返回清算结果。</p><p>此时做一个判断，若清算成功则回执处理结果，并回到提现产品层进行业务处理并通知用户提现处理结束。若清算失败则进入财务核心，进行回充。</p><p><strong>（2）异步提现支付协议处理流程图</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/KgIPQEuo6yW7LMcIdqz9.png" alt="img"></p><p>会员层提交 T 日申请提现需求后，进入提现产品层申请异步提现协议，然后进入支付层：首先请求冻结提现金额，并进入财务核心进行冻结；在 T + N 日请求扣款冻结金额，并进入财务核心层进行扣款，同时报送清算请求指令，进入清算层进行清算指令的记录并生成清算报文（文件），再进入银行层执行清算。</p><p>在 T + N 日，运营平台层执行回导清算结果/文件，进入清算层勾兑清算指令并回执处理结果，进入支付层进行判断。若清算成功则回执处理结果，并回到提现产品层进行业务处理并通知用户提现处理结果，若清算失败则回到清算层进行回充。</p><p><strong>（3）退票支付协议的处理流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/7M4MHCt66MoijGWRgGmT.png" alt="img"></p><p>这部分内容比较容易理解，这里就不做详解了。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/z00uPCfq2a0Jq85mwQQn.png" alt="img"></p><p>如图，将支付与交易分开，主要是为了体现出支付服务机构的核心支付服务功能。</p><p>核心支付服务能够为会员提供丰富个性的支付服务：<strong>充值、提现、内/外转型支付、支付侧营销等内容。</strong></p><p>若将交易产品中包装的相关支付服务，交由支付服务层与清算服务层协作完成，并将交易以及其他产品释放出来，则产生的整体系统框架图如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/k1KZbpqzLnSF0o6NHxgz.png" alt="img"></p><h2 id="三、提现支付协议领域模型"><a href="#三、提现支付协议领域模型" class="headerlink" title="三、提现支付协议领域模型"></a><strong>三、提现支付协议领域模型</strong></h2><p><strong>模型总览：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/8BLIkAH4GIivflO7ErAT.png" alt="img"></p><p>通过对提现支付协议、提现支付指令的归纳抽取，得到本模型图。其中，操作指令部分不对外暴露。</p><p>就提现支付协议本身，分为同步/异步两种处理方式：<strong>前者将提现支付协议的申请过程、处理过程打包处理；后者则是分阶段处理。</strong></p><p>提现支付指令里包含了收款方-银行卡，付款方-支付账户的各自支付工具，依据此可拆分出相应的账务类操作指令与清算类操作指令。</p><p>作为提现支付协议的一种，退票支付协议也将退票单的申请与处理过程打包。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/jw6dUBmyPM3kRlZTadHQ.png" alt="img"></p><ul><li><strong>每 1 提现支付协议，拥有 1 到多个明细项；</strong>提支付协议本身和明细项信息，是产品在使用支付协议时，各专用申请单据转化而来，由原始业务单据数据经过简单加工后得出。</li><li><strong>每 1 提现支付协议，拥有 1 到多个提现支付指令；</strong>支付指令是在协议和协议明细项基础之上加工得出，其具备了进行后续操作处理的全部要素信息，除原始单据中请求要素外，经过支付层的一系列诸如补全、拆分、检查之后产生。部分没有业务数据的提现产品，如：正常提现和卡通提现，都是以支付指令作为其产品数据。</li><li><strong>每 1 提现支付指令，拥有 1 到多个提现操作指令；</strong>提现操作指令是真正可被系统处理的，运行时得出的具体操作步骤。具体表现为账务相关、清算相关，以及其他底层公共服务的处理单元。</li><li><strong>为了简化提现支付指令与提现支付协议的从属关系，可以直接认为每 1 提现支付协议拥有1到多个提现支付指令。</strong></li></ul><p><strong>核心业务逻辑：</strong></p><p>以在线用户发起的正常提现申请为例，整体的交互时序图如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/Oer08izIm7HMrjnJ2cph.png" alt="img"></p><p>支付层内部处理的交互时序图</p><p><img src="http://image.woshipm.com/wp-files/2018/07/EXFAGD9kewZGgNL4F9Gd.png" alt="img"></p><p>提现支付指令作为提现支付协议的流水数据，其处理生命周期的状态迁转如图所示。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/9L0rZiAYuIxShF3De5Do.jpg" alt="img"></p><p>异步提现支付协议下的提现支付指令状态图</p><p><img src="http://image.woshipm.com/wp-files/2018/07/tbgjVH2riStSguphQVfB.jpg" alt="img"></p><p>提现退票支付协议下的提现支付指令状态图</p><p><img src="http://image.woshipm.com/wp-files/2018/07/kqFOfbIKr4zanrQdIV6T.jpg" alt="img"></p><p>同步提现支付协议下的提现支付指令状态图</p><h2 id="四、提现业务边界分析"><a href="#四、提现业务边界分析" class="headerlink" title="四、提现业务边界分析"></a><strong>四、提现业务边界分析</strong></h2><p>首先，提现业务边界分析可以拆分为两大部分：业务用例边界以及系统用例边界。</p><p>这里着重讲一下系统用例边界，分为：</p><ol><li>异步提现支付协议申请；</li><li>异步提现支付协议推进处理；</li><li>接受清算处理结果回执；</li><li>统一协议处理结果回执；</li><li>同步提现支付协议申请；</li><li>同步提现支付协议推进/恢复处理；</li><li>提现退票支付协议；</li><li>打款机构；</li><li>支付能力；</li><li>分布式任务；</li><li>公共查询类服务：协议授权查询服务、机构信息查询服务；</li><li>提现查询类服务：银行卡段检查服务、对公账户联行号检查服务、支行列表查询服务、清算通道支付限额查询服务；</li><li>管理服务：协议授权管理服务、打款机构管理服务、支付能力管理服务、缓存刷新服务。</li></ol><h3 id="1-业务用例边界"><a href="#1-业务用例边界" class="headerlink" title="1. 业务用例边界"></a><strong>1. 业务用例边界</strong></h3><p>支付层作为提供基础支付服务的核心系统，所承担的职责围绕着以下主要业务功能点：</p><p>以协议方式提供适用于各类产品使用的支付服务：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/80mbewOAE38NMY2XYV73.png" alt="img"></p><p>如图所示，可分为同步提现支付申请协议、异步提现支付申请协议以及单笔退票支付申请协议。</p><p>承担包装清算层所公布的各类底层公共查询服务，以及独立提供给产品层的各类公共查询服务：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/miP5uk5d0pDOyLA7O7FL.png" alt="img"></p><p>以提供公共查询服务为职责，则分为协议授权查询、提现统计查询、银行卡段检查、对公账户联行号查询、机构信息查询以及清算通道支付限额查询。</p><p>作为协议使用的辅助手段，提供不同协议的干预处理服务：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/TSyLydnqleRfTrF2Qb3Z.png" alt="img"></p><p>可提供四种不同的干预处理服务：异步提现支付协议推进、异步提现支付协议取消、同步提现支付协议推进、统一提现支付协议回执。</p><p>可供灵活编辑的各种核心处理规则配置机制，以及提供配套的规则管理服务：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/mWHpUHVZ3egfXIcuGLwO.png" alt="img"></p><p>如图所示，三种不同的管理服务内含不同的核心处理规则配置机制：协议授权管理服务、打款机构配置管理服务、提现支付能力管理服务。</p><h3 id="2-系统用例边界"><a href="#2-系统用例边界" class="headerlink" title="2. 系统用例边界"></a>2. <strong>系统用例边界</strong></h3><p>支付服务层的主要作用：与产品层对接，暴露各类支付协议以供产品使用，并囊括各协议的账务处理、清算处理、客户相关检查等部分；释放产品层与清算服务层的链接，使得后者不受限于具体产品业务逻辑，专注于与金融机构的清算过程。对于产品层来说，同样也无需关注具体的清算过程。更方便、更简洁。</p><p>假设目前公司的产品层尚未成型，那么现有的各类提现相关产品是分散在各个子系统中的，在这种情况下：</p><p>通过对提现产品的提炼，可抽取三种提现支付模式：<strong>异步提现模式、同步提现模式以及批量提现模式</strong>。其中批量提现模式，是对前两者的再组装、复用的过程。因此，在支付服务层对提现支付协议的划分可根据同步、异步两种方式即可得出。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/Hb4ZtiUD346KWNVJnz6T.jpg" alt="img"></p><p><strong>此图要点：</strong></p><ol><li>支付服务层暴露提现支付协议给产品使用，贯穿提现业务的整体生命周期，提供提现支付协议申请、推进执行、取消、查询等服务；其中提现支付协议的推进执行入口，主要包括针对同步提现支付协议的推进处理，和异步提现支付协议的推进处理（例如：生僻字复核）。</li><li>产品希望得到提现支付协议的处理结果，支付层需要以统一透明的方式，将提现支付协议处理结果，回执给特定产品。在产品层需要有统一的接受支付层处理回执服务，在接受到支付层的回执之后，此服务将自行分发至各特定提现产品进行处理。</li><li>支付服务层报送账务请求至账务核心，请求账务处理，包括充值、提现、支付以及冻结、解冻等。</li><li>支付服务层请求清算服务层执行清算过程，与产品层同理，支付服务层需要得到清算指令的处理结果来决定其下一步业务处理。对于差评层需要取消提现支付协议的，支付服务层需要得到清算服务层允许后方可决定是否取消。所以支付服务层与清算服务层的交互有发送清算指令，接受清算结果，查询清算指令，取消清算指令以及问询清算指令是否可絮叨等。</li><li>退票作为提现支付协议的方向处理过程，支付服务层提供给管理平台退票申请入口，将退票作为提现支付协议的一种特殊类型即退票支付协议看待，与提现支付协议简历关联。辅以退票支付指令，进行会员账务回充等处理。</li><li>支付服务层需要将内部各类规则配置释放给管理平台，以便后续可支持灵活的规则组合，以达到各类支付协议业务敏捷的目的。</li></ol><p><strong>（1）异步提现支付协议申请</strong></p><p>作为提现支付协议中最为基础的一种，异步提现支付协议适用于现有各类非实时处理的提现产品，如：<strong>正常提现、认证提现、委托提现等。</strong></p><p>参照提现支付协议认领模型设计，产品层可将异步提现支付协议的使用分为：申请、推进处理两个阶段，以及特殊情况下的取消操作。</p><p>本文重点描述异步提现支付协议，在申请过程中支付层的体系结构以及处理流程。</p><p>需要重点指出的是，支付层所提供的协议申请使用嵌套分布式事物，在此将申请过程分为两个阶段处理：</p><p><strong>阶段一：</strong></p><p>调用者开启分布式事务，在事务块内请求异步提现支付协议申请：</p><ol><li>整合现有各类非实时处理类提现产品要素，设计专用的申请单据对象；异步提现支付协议支持每次申请单笔或批量明细项；</li><li>通过内部的业务接入层将专用单据转换成统一的内部领域模型对象；</li><li>对领域模型对象加工，包括补全、拆分、检查等；</li><li>启动嵌套分布式任务，执行预授权处理，即冻结提现款；</li><li>组装处理结果并返回。</li></ol><p><strong>阶段二：</strong></p><p>调用者根据支付层协议申请的返回结果，决定提交或回滚分布式事务。</p><p>这个调用是隐式的，与调用账务核心服务接口方向一致，即调用者本地事务提交，则分布式失误提交，同时支付层调用账务核心的嵌套式分布式任务也提交，否则本次申请做回滚处理。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/cy4dr6Ul19T6npO8JIIZ.png" alt="img"></p><p><strong>异步提现支付协议推进处理：</strong></p><p>异步提现支付协议在申请阶段只是将提现额做了冻结，后续处理是通过支付层的调度任务根据优先级以及可执行时间按顺序处理，包括对支付指令的账务解冻、扣款、报送清算指令等步骤。</p><p>对于正常提现或认证提现，某些需要审核生僻字的提现申请。产品层调用者在请求支付层申请处理，如果指定了不允许支付层自行处理的，则支付层不会自行通过调度任务方式推进处理，而是等待产品层通知才进行处理。</p><p><strong>支付层自行调度的推进处理：</strong></p><ol><li>加载协议数据，激活领域模型对象；</li><li>执行结算处理，包括账务解冻与扣款；</li><li>执行报清算处理，通过确保达到的ESB消息通知清算层执行清算。</li></ol><p><strong>产品层通知方式的推进处理：</strong></p><ol><li>加载协议数据，激活领域模型对象；</li><li>记录协议的相关审核人以及类似于生僻字审核所需要的银行开户名等信息；</li><li>执行结算处理，包括账务解冻与扣款；</li><li><strong>执行报清算处理，通过确保达到的ESB消息通知清算层执行清算。</strong></li></ol><p><img src="http://image.woshipm.com/wp-files/2018/07/BabPCSTK4GhPhaiLl4je.png" alt="img"></p><p><strong>1）异步提现支付协议取消/接受清算处理结果回执</strong></p><p>异步提现支付协议取消：</p><ul><li>这里提到的协议取消不是对整个协议的取消，支付层只允许对单笔支付指令的取消行为；</li><li>对于大多数协议支付指令为单笔的提现支付协议，如果该笔支付指令取消成功，则协议也相应进入处理结束状态；</li><li>取消支付指令由于涉及账务处理，所以继续使用嵌套分布式事务解决。</li></ul><p>需要注意的是：</p><ul><li>只有处于已预授权状态的支付指令才可以被取消，如果已经扣款或者已报清算，则不允许在支付层发起取消。产品可以通过致使清算指令失败的方式令支付指令失败，达到取消的效果。</li><li>请求账务执行解冻处理。</li><li>通知产品层代理者本提现流水已取消。</li></ul><p>接受清算处理结果回执：</p><p>在经历了上述两个处理过程后，清算层根据自有的业务规则进行清算处理。最终的清算结果需要确保通知到支付层，此处继续选用高可靠性的ESB确保到达。</p><p>需要注意的是：</p><ul><li>对于清算成功的支付指令，将该笔置为成功状态；</li><li>对于清算失败的支付指令，请求账务进行失败回充处理，并将该笔置为失败状态；</li><li>对于清算成功的支付指令，更新其实付金额为应付金额；对于清算失败的支付指令，更新其实付金额为0；</li><li>成功或失败状态的支付指令都代表处理结束；如果申请的异步提现支付协议只有所有支付指令均处理结束，则需要将协议也置为处理结束状态；同时累加其所属支付指令的实付金额作为协议的实付金额；</li><li>所有处理结束的支付指令，均需要回执给产品层，由其进行具体业务处理。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/07/v2QYLlQRGeHCzpXWd9cj.png" alt="img"></p><p>全局系统中有多处业务场景使用提现取消服务，如风控的申请后拒绝行为，客服的提现失败任务，以及后台冻结账户等，都需要取消指定的提现申请记录。</p><p>请求者（系统）使用分布式事务，来要求支付层保证整体业务的原子性，也就是说支付层所提供的取消服务，在分布式事务第一阶段执行成功后，如账务解冻成功后，需要将协议重新置为系统状态，等待请求者提交分布式事务。</p><p>相应的，如果请求者发生异常而回滚分布式事务，支付层必须确保协议整体模型数据恢复至取消前状态（包括金额等关键数据要素），而不能与其他基于分布式事务的申请服务一样，将数据删除。</p><p>同时，支付层必须确保在请求者提交分布式事务后，才能发送回执消息给产品层代理者。不允许在业务处理内部发送回执消息，否则一旦请求者回滚事务，此消息无法删除。</p><p><strong>2）统一协议处理结果回执/同步提现支付协议申请</strong></p><p><strong>统一协议处理结果回执：</strong></p><ul><li>除了上述的支付指令处理成功/失败已经提现取消作为处理结束状态，需要回执给产品层外，对于退票情况，也需要回执给产品层；</li><li>产品层目前也是通过前置来统一处理的，所以支付层在回执产品层提现处理结果时需要一并报送该笔支付指令的产品码、子协议代码以及备注信息、操作员等；</li><li>这里回执给产品层的处理结果，也是采用高可靠性的ESB确保到达。</li></ul><p><strong>（2）同步提现支付协议申请</strong></p><p>对于需要同步支付并清算的提现产品，使用本协议。同异步提现支付协议，本协议也可以使用嵌套分布式事务。</p><p>不同的是本协议的使用需要三阶段处理模式：</p><p><strong>阶段一：</strong></p><p>调用者开启分布式事务，在事务块内请求异步提现支付协议申请。</p><ul><li>快捷提现都是通过快捷协议号，即收款方信息较为简单，为此设计专用的申请单据对象，只支持每次申请单笔明细项。</li><li>通过内部的业务接入层，将专用单据转换成统一的内部领域模型对象。</li><li>对领域模型对象加工，包括补全、拆分、检查等。</li><li>开启嵌套分布式事务，执行结算处理，直接进行扣款。</li><li>组装处理结果并返回。</li></ul><p><strong>阶段二：</strong></p><p>调用者根据支付层协议申请的返回结果，决定提交或回滚分布式事务。这个调用是隐式的，与调用账务核心服务接口方式一致——即调用者本地事务提交，则分布式事务提交，同时支付层调用账务核心的嵌套分布式事务也提交，否则本次申请做回滚处理。</p><p><strong>阶段三：</strong></p><p>调用者分布式事务提交后，采用主动调用同步提现支付协议的推进处理服务，通知进行后续处理。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/VzQ6IS76rqdQTujCpY0S.png" alt="img"></p><p><strong>1）同步提现支付协议推进/恢复处理</strong></p><ol><li>之所以没有在同步提现支付协议申请过程中进行清算，原因是清算层无分布式事务支持。而同步提现支付协议的清算是需要同步请求清算层的，为了保证前期处理过程的一致性。支付层在申请阶段确保账务扣款成功，这个是由嵌套分布式事务框架来确保的。</li><li>而此时并未进行实时清算，产品层需要显示的调用本推进处理服务来通知支付层进行后续清算处理。这个通知是不需要确保的，原因是经过前期的申请处理，支付层的协议处理已提交。而产品层显示调用支付层进行推进只是为了实时的拿到最终处理结果，从而回显给会员。</li><li>而支付层内部则简单的请求清算层进行同步清算即可。</li><li>如果发生掉单的情况，支付层内部的恢复程序会不断的尝试恢复，直至清算处理结束为止。这里就需要清算层对于支付层，同一支付指令的多次清算请求，做忽略处理，并返回当前的处理状态。</li><li>支付层同步请求清算，清算层的返回结果中有三种清算状态：</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/07/Cz7FSWzry54HDEF4YTGM.jpg" alt="img"></p><p>如果支付层在请求同步清算时出现了严重异常，如清算层异常宕机或清算返回丢失，则仍然返回产品处理中结果，支付层内部回复程序会继续尝试回复。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/VOko91j79Sdbbk42kUrz.png" alt="img"></p><p><strong>2）提现退票支付协议</strong></p><p>提现退票支付协议作为本讲引入的协议之一，通过申请支付层的协议，由支付层负责账务与业务推进处理。在本协议下，退票流水将作为支付指令存在，与被退票的支付指令平级，不会去对已经处理成功的原支付流水做任何改动。</p><p>由于不需要进行清算，支付层内部只需要处理账务充值部分即可。所以本协议也是同步的，即申请成功则全部处理完毕，使用嵌套分布式事务。</p><ol><li>只有处理成功的支付指令才可以被退票；</li><li>每一笔支付指令最多只能被退票一次；</li><li>退票金额为原支付指令的实付金额；</li><li>新产生的（退票）支付指令建立起与原支付指令的关联关系；</li><li>对于退票申请处理中，如果请求账务失败，则本次申请失败。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/07/0RvPpHwmasAHBMqCDYpr.png" alt="img"></p><p><strong>3）打款机构/支付能力/分布式任务</strong></p><p><strong>打款机构：</strong></p><p>任何一笔提现申请，最终目的都是从某一支付账户提现至指定的银行卡上，这个银行卡就是提现支付协议中指定的收款方信息。</p><p>由于银行卡信息中的开户行种类繁多，比如：各类非直接打款银行，对于这些开户行的提现申请，实际会通过跨行的方式进行提现。具体说来就是根据开户行，提现的额度范围，账户的对公对私属性等，来决定最优的提现方式。</p><p>产品层不知道本次提现的实际打款机构，而支付层对每笔支付指令进行账务处理时需要知道具体的打款机构，这样才能请求账务进行扣款或者回充处理，所以打款机构的规则就需要支付层进行维护。</p><ul><li>根据既定的打款机构配置方式，按照开户行、提现的额度范围、账户的对公对私属性以及产品码来补全支付指令的打款机构；</li><li>对于同步提现支付协议，其打款机构与开户行相同。</li></ul><p><strong>分布式任务：</strong></p><p>支付层的大量调度任务，如：异步提现支付协议的推进、同步提现支付协议的掉单恢复等，将来会有更多的调度任务加入。</p><p>考虑到线上环境是多服务器并发处理任务的，对于这种分布式任务需要解决两个问题：</p><ol><li><strong>防止重复处理：</strong>由于各服务器程序代码都是一样的，这样就很容易造成彼此处理的数据相同，造成资源的浪费，并且可能带来严重的资损风险。</li><li><strong>最大限度的并发：</strong>在解决了重复处理的问题后，还必须让集群服务器发挥效能，真正实现多服务器并发的处理，在保证安全的情况下最大程度的提高处理效率。</li></ol><p><strong>支付能力：</strong></p><p>作为支付协议最重要的处理规则，支付层对外提供可供快速定制的各种内部处理打包方案，这些打包方案里配置了一些极为关键的规则要素：</p><ol><li><strong>支付处理优先级：</strong>决定其在支付层处理的优先级别，值越大的越优先处理；</li><li><strong>支付处理延时时间：</strong>以此推出每笔支付指令的具体可执行时间；</li><li><strong>清算优先级：</strong>报送的清算指令，在清算层内部的处理优先级别；</li><li><strong>内部渠道：</strong>内部渠道的划分，如线下、快捷等，以此决定清算通道；</li><li><strong>账务子交易代码：</strong>执行账务扣款的子交易代码；</li><li><strong>失败回充账务子交易代码：</strong>执行账务失败回充的子交易代码。</li></ol><p>除此之外，每个支付能力拥有以下要素：</p><ol><li>子协议代码：一个支付能力可以被多个支付协议使用，这里就是可以使用这个支付能力的子协议代码。</li><li>是否是默认能力：每个支付协议都有且只有一个默认的支付能力。</li><li>作为初始数据，支付层配置了若干支付能力，正式由于这些支付能力的存在，支付层能够做到灵活的发布新的支付服务。而这种打包方案的发布，无需代码改动成本、无发布成本，只需简单配置即可工作。</li><li>产品与可使用的支付协议之间是多对多的关系，支付协议与可使用的支付能力之间也是多对多的关系。</li><li>不同的产品，使用不同的支付协议，实际上是在使用不同的支付能力。</li><li>不同的产品，使用相同的支付协议，也可以使用不同的支付能力。</li><li>相同的产品，使用相同的支付协议，仍然可以使用不同的支付能力。</li></ol><p><strong>4）其他服务类</strong></p><p><strong>公共查询类服务：</strong></p><ul><li>协议授权查询服务：此服务由支付层自行提供，所有使用支付协议的产品，必须得到支付层的使用授权。这里提供了根据产品码、子协议代码检查是否可用的查询服务。</li><li>机构信息查询服务：此服务由清算层提供，支付层代为封装，查询所有系统支持的机构信息列表，每个机构信息包括机构ID、机构名称等基本要素。通过机构ID查询机构信息服务；通过机构名称查询机构信息服务；检查指定的机构ID与机构名称是否匹配服务。</li></ul><p><strong>提现查询类服务：</strong></p><ul><li>银行卡段检查服务：此服务由清算层提供，支付层代为封装。会员在设置银行卡信息时，产品通过此服务检查会员设定的银行卡信息的有效性。同时在发起提现申请时，支付层内部也需要通过该服务再次请求清算层检查，以确保报送的清算指令数据合法性。</li><li>对公账户联行号检查服务：此服务由清算层提供，支付层代为封装，产品层在检查设置了对公银行账户有效性时使用。</li><li>清算通道支付限额查询服务：此服务由清算层提供，支付层代为封装，某些特定场景下，产品层希望提前得到清算层，所设定的某个清算通道支付上限金额。</li><li>提现统计查询服务：此服务由支付层自行提供，统计会员在某时间段内的所有统计信息，包括提现成功、失败、取消、退票以及处理中的总比数、总金额等。</li></ul><p><strong>管理服务：</strong></p><ul><li><strong>协议授权管理服务：</strong>提供产品的协议使用授权开通、关闭服务。</li><li><strong>打款机构管理服务：</strong>提供打款机构规则的配置、取消服务。</li><li><strong>支付能力管理服务：</strong>提供支付能力的配置、取消服务。</li><li><strong>缓存刷新服务：</strong>前文提到的支付层内置本地缓存机制，一旦某些清算层的配置规则或支付层自有配置规则发生变化，需要刷新这些缓存。支付层提供管理平台使用的本地缓存刷新服务，支持全部缓存刷新和对指定的某个缓存刷新。这里需要考虑由于线上是集群服务器环境，要做到所有服务器均可刷新。此外，对于支付层自由配置规则的调整，内部会自动进行刷新本次调整所对应的缓存内容。</li></ul><p><strong>本地缓存：</strong></p><p>由于支付层代理了清算层的一些底层查询服务，并且这些服务频繁的被产品层使用，而且支付层内部处理也需要用到这些底层服务。为了降低远程查询的系统开销，支付层需要建立起本地缓存机制，将适合的清算层查询结果缓存在本地。</p><ol><li>机构信息查询结果；</li><li>清算通道支付限额查询结果；</li><li>支行列表查询结果。</li></ol><p>除此之外，支付层自有的配置规则也可以考虑使用缓存的模式，减少数据库读取频率：</p><ol><li>协议授权关系列表；打款机构规则列表；</li><li>支付能力列表。</li></ol><h2 id="五、充值系统业务流程分析"><a href="#五、充值系统业务流程分析" class="headerlink" title="五、充值系统业务流程分析"></a>五、充值系统业务流程分析</h2><p>充值协议处理主体流程图（充值遵守的系统处理原则：先清算，后结算）：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/SARl3h8AzHxZi4xDJvSL.png" alt="img"></p><p>充值协议处理主体流程图（充退遵循的系统处理原则：先结算，后清算）：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/GBa8LGzc6rlBM3wflwlk.png" alt="img"></p><p>后结算处理的充值协议，如阿里国际站的小额担保交易的使用场景，其处理流程如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/yGyIm23Lo1mxi9EkIh3M.png" alt="img"></p><h2 id="六、充值协议系统级架构和领域模型"><a href="#六、充值协议系统级架构和领域模型" class="headerlink" title="六、充值协议系统级架构和领域模型"></a>六、充值协议系统级架构和领域模型</h2><h3 id="系统整体架构"><a href="#系统整体架构" class="headerlink" title="系统整体架构"></a><strong>系统整体架构</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/07/TRYNxNKBMx3kqhwfZaRf.jpg" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/07/QJMQJBQfIfXJmRDwRBH0.jpg" alt="img"></p><p>我们从多个视角来快速浏览支付层的整体系统架构：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/0bb4JcxBebFCN0OlmbZ3.png" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/07/ihOJsnoaMYyY4JJ8Y1KB.png" alt="img"></p><h3 id="模型总览"><a href="#模型总览" class="headerlink" title="模型总览"></a><strong>模型总览</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/07/xsYCjJcl8xbpMhHXqQZ6.png" alt="img"></p><p>这里需要指出的是，充值协议不存在支付层处理的时限性，全部都是实时报送清算层完成的。引入的异步处理类充值协议并不是非实时报送清算层，而是由于金融机构回执给清算层的清算结果是异步的，今儿演变为清算回执异步通知至支付层。</p><p>充值协议需要支持各类场景下的充值行为，如：网银、快捷等，这些充值场景分表代表的是付款方支付工具的接入方式。当加工处理为充值指令内部的清算单据时，仅作为此清算通道所必须的清算要素而存在，它们最终成为报送清算层的各类充值清算操作指令。对于充值协议本身不同的支付工具决定了支付、清算系统交互的细微差异，如：快捷与网汇E，需要实时响应服务使用者协议处理结果，而网银则被动接受金融机构的异步通知。</p><p>充值不再采用提现协议中协议、协议明细、指令三者间的1:N:M关系，而是简化为协议与指令间1:N关系，在不进行定期支付的场景下，协议明细项作用不大。</p><p>每1充值协议，拥有1到多个充值指令，充退指令是在各充值协议单据要素基础之上加工得出，其具备了进行后续操作处理的全部要素信息，如需要报送清算层的清算单据和与账务进行交互的账务单据。</p><p>每1充值指令，拥有1到多个充值操作指令，充值操作指令是真正可被系统处理的、运行时得出的具体操作步骤，具体表现为清算。</p><h3 id="核心业务逻辑"><a href="#核心业务逻辑" class="headerlink" title="核心业务逻辑"></a><strong>核心业务逻辑</strong></h3><p>用户进入统一收银台界面，选择了充值渠道以及充值金额，收银台经过规则检查（如安全、渠道等）后，向支付层发起充值协议申请：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/EH9bMwELmmNLFhcGqEsU.png" alt="img"></p><p>清算层在处理完金融机构的清算结果通知后，回执给支付层：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/4RYGBWETbLdJ9doffMAX.jpg" alt="img"></p><p>重要的规则、约束、平衡检查如下：</p><ul><li>产品所使用的充值协议必须经过授权，处于开通状态；</li><li>必须指定支付渠道API；</li><li>原则上受理的充值额度区间为：0&lt;额&lt;= 无限大;目前的充值申请均由统一收银台发起，相关特定渠道的充值限额已由收银台进行控制，支付层不对充值额度再次检查；</li><li>账务充值动作，必须在清算层明确回执银行清算成功后方可进行，实际充值金额以清算层回执金额为准。</li></ul><h3 id="充值指令的状态迁转"><a href="#充值指令的状态迁转" class="headerlink" title="充值指令的状态迁转"></a><strong>充值指令的状态迁转</strong></h3><p><strong>如图所示：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/FTvfWPrK8IIls7LTVaE4.jpg" alt="img"></p><ol><li>其中已预授权与已预清算状态均为中间状态，为B2B网银支付和Migs网银支付所设计。实际情况下已预清算状态不会迁转至清算失败状态，但是在系统设计中我们认为这样的状态迁转有效。</li><li>绝大多数的充值指令，均是从已报送清算状态，直接迁转为清算成功或清算失败状态。</li></ol><h2 id="七、充退协议领域模型"><a href="#七、充退协议领域模型" class="headerlink" title="七、充退协议领域模型"></a>七、充退协议领域模型</h2><h3 id="模型总览-1"><a href="#模型总览-1" class="headerlink" title="模型总览"></a><strong>模型总览</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/07/5lK4qPLBdWKeQsq4OCaU.jpg" alt="img"></p><p>充退协议的处理过程与提现协议极其类似，唯一的差别在于提现协议可以指定收款方的支付工具，如客户指定收款的银行卡信息。而充退则依照<strong>“由哪里来，回哪里去”的原则</strong>，即客户不能指定收款方信息。</p><p>充退必须要关联到一笔充值指令，金融机构依据充值清算过程中的付款方，作为本次充退的收款方，而支付层则无需关心收款方信息，并且也无法得知此信息。</p><p>允许对一笔充值指令流水号进行多次充退，只要充退金额满足系统限制即可发起，所以充值指令与充退指令间存在这样的关系：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/1t55wREi9MgMueoYNjAz.png" alt="img"></p><p>另外异步后结算充退协议是专门为外卡这样的充值渠道退款而开设的，我们都知道充退与提现的资金流向相同，在处理此类业务时，支付层必须确保先做完账务结算，才能报送清算指令。</p><p>而后结算充退协议则用于非常特殊的场景：在报送清算层时支付层无法完成账务处理，如外币充退。在支付层不做任何账务处理的情况下，报送充退清算指令，最终清算完成后再进行账务结算处理。支付层不保证此类充退的账务结算顺利完成，由此带来的结算失败风险由业务产品承担。</p><p>由于金融机构与清算层的交互使用充值指令流水号，而不是以支付层所产生的充退指令流水号作为交互依据，并且存在着一笔充值指令流水号多次、且同金额的充退指令。这样对于后续账务、会计系统以及对账中心的资金清算对账都带来了麻烦。</p><p>原则上，我们希望同一笔充值指令流水号只能存在一笔处于活动中的充退指令，当这笔充退指令全部处理结束时，才能发起对该充值流水号的再次充退。</p><p>在某些特定商业背景下（如机票平台大客户的充退需求）必须大客户一次性对一笔充值指令的连续多次充退请求，有如下两种实现方式：</p><ul><li><strong>方式一：</strong>需要清算层在报送银行端时进行恰当的处理，如将支付层报送过来的充退清算指令进行合并，或采取延迟报送银行等手段加以实现；</li><li><strong>方式二：</strong>产品层加强此类合并充退的组织力度，即支付层、账务/会计、清算层以及对账中心都不为此类业务进行内部业务合并，而是交由产品进行合并，请求支付层的充退已经是合并后的单据。这样的整体代价较小，并且提高了核心系统的业务处理稳定性。</li></ul><p>统一的充退申请代理除了上述的完成对充退申请合并工作外，该代理将作为所有充退产品申请入口，一个很重要的职责是识别产品所发起的充退申请合法性。由于充退申请存在资损风险点，且发起场景非常复杂、难以统一控制，所以将这些申请进入支付层的安全性检查统一由代理者进行识别，支付层本身的充退协议做到最底层的合法性检查即可。</p><p>另外，支付层分流器以异步消息通知的方式完成回执，交易或缴费类产品在自身业务推进处理失败时，统一报送可疑事件至此代理，由其来识别各类可充退规则配置，决定是否向支付层发起充退协议申请。</p><p>鉴于此，支付层提供的充退协议遵循一笔充值指令，最多只能有一笔处于活动状态充退指令的约束。同样的原因，充退协议也不再引入协议明细项，直接建立协议与指令的关系；</p><ul><li>每1充退协议，拥有1到多个充退指令，充退指令是在各充退协议单据要素基础之上加工得出，其具备了进行后续操作处理的全部要素信息，如需要报送清算层的清算单据和与账务进行交互的账务单据。</li><li>每1充退指令，拥有1到多个充退操作指令，充退操作指令是真正可被系统处理的、运行时得出的具体操作步骤，具体表现为清算操作指令、账务操作指令以及其他底层公共服务的处理单元。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/07/elf3AEOmQfUUJviJywwS.png" alt="img"></p><h3 id="核心业务逻辑-1"><a href="#核心业务逻辑-1" class="headerlink" title="核心业务逻辑"></a><strong>核心业务逻辑</strong></h3><p>前文中提到充退协议与提现协议的处理方式极其类似，除了收款方信息用户无法指定外，其余部分与提现的现有做法一致，所以此处不再赘述。充退协议存在时限性，我们继续沿用支付能力可配置的做法，将充退产品与充退协议实现松耦合绑定关系。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/zbEgw0OR1UvlNJYXf5v0.jpg" alt="img"></p><p>注：对于后结算充退协议，指令状态直接迁转为已报送清算状态，在等待清算回执后再做账务结算。</p><p><strong>重要的规则、约束、平衡检查等包括以下各点：</strong></p><ul><li>每笔充值指令最多只拥有一笔处于活动中状态的充退指令。</li><li>（每笔充值指令下所有处于活动状态的充退指令金额总额）ART &lt;= （该笔充值指令实付金额）DT – （所有该笔充值指令下已充退成功的金额总额）SRT。</li><li>预结算充退协议申请单据中指定的主事务号不得重复，全局唯一。</li><li>产品所使用的提现支付协议必须经过授权，处于开通状态。</li><li>必须有可匹配的支付能力。</li></ul><p><strong>充值协议领域模型VS充退协议领域模型：</strong></p><p>与提现和退票的关系类似，充退也是建立在充值基础之上的特殊协议，都是完成了正向协议的反向资金处理过程。</p><p>在前面讲述中将提现协议与退票协议进行合并，反映在模型本身、处理流程以及数据存储等各方面都保持一致，</p><p>而本期充值协议与充退协议则是分开建设的，原因有以下几点：</p><ol><li>提现无多次退票场景，每笔提现指令与退票指令存在唯一对应关系，而充值与充退则存在1:N的对应关系。</li><li>将退票与提现合并，在数据格式上要求严格的统一，即拷贝原有的提现数据，生成退票数据。提现、退票的数据量小，开销少，对于独立的查询、统计均比较方便。而充值与充退的数据量相差太大，二者进行合并必然带来各自处理以及查询统计的巨大消耗，尤其以充退为甚。</li><li>充退流水要素构成比较简单，只需记录所关联的充值指令流水号即可完成后续的清算退回过程，没有必要拷贝充值数据。</li></ol><h2 id="八、充值业务边界分析"><a href="#八、充值业务边界分析" class="headerlink" title="八、充值业务边界分析"></a><strong>八、充值业务边界分析</strong></h2><p><img src="http://image.woshipm.com/wp-files/2018/07/MHXpcO44S10dplo3hJnF.png" alt="img"></p><p><strong>业务用例边界：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/wQGaV3tt4G3ADRKn9l9g.png" alt="img"></p><p>充值业务在支付层设计的业务用例主要包括以下若干模块：</p><ol><li>以协议方式提供适用于收银台或其他业务产品使用的充值服务 ；</li><li>以协议方式提供适用于各类业务产品使用的充退服务；</li><li>建立对支付渠道的统一管理；</li><li>基于通用性而设计的统一业务分流组件；提供相应的注册（推进）服务；</li><li>作为协议使用的辅助手段，提供不同协议的干预处理服务；</li><li>承担包装清算层所公布的各类底层公共查询服务，以及独立提供给产品层的各类查询统计服务；</li><li>可供灵活编辑的各种核心处理规则配置机制，以及提供配套的规则管理服务。</li></ol><p><strong>系统用例边界：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/Qv40VF2X5U2usEBPcX3X.jpg" alt="img"></p><p><strong>网银充值协议申请：</strong></p><ul><li>用户选择网银渠道，如B2C或B2B以及VISA等，收银台组装本充值协议申请单据，请求支付层处理；</li><li>如申请单据中包含业务分流回执信息，则需要完成对回执上下文的注册工作，这里交由监听器处理；</li><li>报送清算指令清算层，并将可供收银台实现页面跳转的地址或html串响应给收银台。</li></ul><p>基本流程示意图：</p><p><img src="http://image.woshipm.com/wp-files/2018/07/2FJUH72jnVhvpLXpxi7y.png" alt="img"></p><ol><li>协议申请单据一旦经过合法性检查，必须先存储，同时发送协议申请事件，以期分流任务注册完成。</li><li>同步报送清算指令，如果此时请求失败或超时，直接返回调用者申请失败即可，清算层完成指令落地工作并返回跳转表单对象。</li><li>会产生一定的废单数据，如会员在网银页面后直接关闭。</li><li>结算行为必须在得到清算层明确的清算成功回执之后，以实付金额为准进行账务结算，下同。这里的清算回执是异步的，所以不在此图中显示，见后续充值清算回执说明。</li></ol><p><strong>代金卡（充值码）充值协议申请：</strong></p><p>网银充值协议申请后所返回的跳转表单对象，供收银台跳转至金融机构。而代金卡的充值处理中收银台，无需获取跳转表单对象。这里有可能是代金卡独立业务系统，已明确了跳转表单对象，所以这个充值协议的处理过程，仅是将支付流水与清算流水记录即可，等待外部（百联）系统对清算层的回执发生后发起结算行为。</p><p>代金卡充值协议需要收取手续费，在报送的协议申请单据中需要指定待冻结的金额，支付层充值领域服务完成充值后，即发起对充值账户的冻结处理。</p><p><strong>快捷充值协议申请：</strong></p><p>不同于网银充值，快捷不需要会员在金融机构再次确认，收银台、支付层、清算层以及金融机构之间全部实时交互完成。当然，对于支付层与清算层之间掉单的数据，需要恢复补偿措施。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/EW113BZfExCoUJ3BzIvW.png" alt="img"></p><p><strong>接受充值清算回执：</strong></p><ul><li>对于网银充值需要用户进行操作的，清算层异步通知支付层金融机构的清算结算；</li><li>快捷充值或网汇E类无需确认的，考虑到清算层实时通知支付层有可能出现掉单，此处也作为业务恢复点。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/07/7Rvs9rhDMRGtENe12KiX.png" alt="img"></p><ol><li>必须以清算回执的实际清算金额为准进行账务充值处理；</li><li>发送协议推进处理事件必须在结算行为事务块之内完成，即确保结算完成，且分流任务被启动。</li></ol><p><strong>无清算充值协议申请：</strong></p><p>以上介绍的各类充值协议其处理过程，都遵循了支付层先记录单据，待清算层完成清算后再由支付层进行结算的处理原则，也就是意味着当清算层回执支付层具体的清算结果时，支付层一定是有相应的单据的。而由于COD业务模式的特殊性，物流收到货款后即才支付机构发出通知，以物流订单号作为充值订单号，要求完成此次充值行为。</p><p>COD是支付机构内系统最先获知此充值请求的，由它来通知支付层创建充值协议并立即完成结算行为，在此之前支付层并无任何单据信息。</p><p>为此，支付层需要为COD模式的业务开设专用的充值协议，即所有单据据要素已由调用者收集完毕，并使用此协议完成充值，注意支付层此时的处理仅结算即可，无需再次与清算层发生关系。</p><p>这个时候可以把COD当成是业务产品在使用此充值协议，由于金额机构系统不会再次通知COD，当它们完成自身业务处理后，使用高质量确保的异步消息通知支付层形式，来完成本次充值。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/Zf7RI39YE1pwffhm2Tgw.jpg" alt="img"></p><p>支付层要严格控制消息的幂等性，不能为中间账户多次充值！</p><p><strong>充值后通知事件：</strong></p><p>所有成功完成的充值协议，都需要以异步消息方式通知CTU及积分核心系统本充值事件。</p><p><strong>支付与清算系统掉单恢复：</strong></p><p>对于实时完成支付、清算过程的充值协议，需要辅以定时调度任务恢复系统响应超时的掉单充值指令。扫描2小时内处于报送清算状态的充值指令，使用清算层提供的指令查询接口问询当前处理进度。对于清算明确解释指令处于未知状态的，则无需再做处理，等待其处理结束后主动发起通知。</p><p><strong>充值协议查询：</strong></p><p>用以解释当前充值订单处理状态，当清算层push相关信息至收银台后，收银台使用此服务获知处理结果并显示用户。</p><p>此服务不限于仅在此场景下被使用：</p><ul><li>处理成功状态：充值成功，业务分流后产品处理成功；</li><li>充值成功状态：仅充值成功，业务分流后产品处理失败或未知状态；</li><li>充值失败状态：充值失败，无论业务分流是何结果。</li></ul><p><strong>预结算充退协议申请：</strong></p><ul><li>同提现协议处理方式，使用此协议的请求者（产品）必须经过授权，通过指定具体支付能力的方式达到不同的处理时限以及有差异性的结算、清算过程。</li><li>以原充值指令号及该笔充值指令的支付渠道API请求清算层，获得新的退回API及充退流水号。</li><li>使用嵌套分布式事务，保证账务冻结的处理成功，当满足处理时限要求后，依序进行账务结算以及报清算处理，见下文关于异步充退推进调度所述。</li><li>当前协议下每笔待充退的充值指令，不允许存在活动中状态的充退指令。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/07/MpdixMHWtRXFHVTTjDRX.jpg" alt="img"></p><p><strong>后结算充退协议申请：</strong></p><ul><li>针对诸如Migs的渠道，支付层提供了后结算充退协议供使用，与预结算充退协议不同处在于，完全依赖清算层的回执才进行账务扣款，并且不存在冻结、解冻以及失败回充的动作。仅在清算层明确回执清算成功后，以实际清算金额（RMB）为准进行账务扣款。</li><li>由于没有事先结算，理论上清算完成后进行账务扣款有可能失败，如：账户余额不足。对于此类场景，系统要不断重试，直到能够扣款成功为止。</li></ul><p><strong>异步充退推进调度：</strong></p><p>使用分布式任务组件，作为异步充退推进处理的调度策略，这里要完成：</p><ul><li><strong>结算：</strong>解冻、扣款，注意如果是后结算充退协议则不需要进行此类账务处理。</li><li><strong>清算：</strong>报送清算指令。</li></ul><p>调度任务中只负责识别出当前待推进处理的指令集合，交由独立门面服务进行上述处理。此门面服务需要对外开放，如系统约定对于大客户充退申请的处理时限，业务部门可能对其进行临时干预，要求立即完成清算，把这个服务释放出去，供管理平台调用。</p><p>重要：待推进处理的指令集，所对应的通道API必须处于可用状态，如大客户所申请的标准卡通类充退，我们不希望在其通道已关闭的情况仍对其进行扣款、报清算处理。</p><p><strong>异步充退超时调度：</strong></p><ul><li>处于结算成本以及客户引导的原因，结算人员对客户发起某些金融机构下的充退是不给予处理的。同时某些充退在申请时其通道是可用的，而推进处理时则发现通道已关闭，此类充退指令则一直处于待推进状态。</li><li>为此类申请设置超时时间，如7日内仍处于申请状态的，则将其充退冻结款项进行解冻处理。</li></ul><p><strong>接收充退清算回执：</strong></p><p>当清算层与金额机构清算完毕，业务对账完成后，清算层将清算结果回执给支付层，支付层进行后续处理。</p><ul><li>结算：当清算失败则进行回充；注意如果是后结算充退协议则仅在清算成功的状态下发起扣款，清算失败不做账务处理；</li><li>业务分流：发送协议推进处理事件。</li></ul><p><strong>单笔充退指令取消：</strong></p><p>允许异步充值指令的取消行为，所遵循的处理原则有：</p><ul><li>外部系统请求支付层取消某一笔充退指令，如果是预结算的，只有该支付指令处于预授权状态放可进行取消。对于后结算充退指令，只要该笔充退指令没有报送至清算层均可被取消。</li><li>预结算充退指令取消要完成账务解冻处理。</li><li>如果当前状态不允许进行取消，则外部系统需要请求清算层进行取消。复核清算层的取消规则后，清算层会以清算失败的状态异步回执支付层，则支付层进行失败回充。</li></ul><p><strong>人工充退指令推进：</strong></p><p>见上述异步充退推进调度中所使用的独立门面服务，完成结算以及报清算处理过程。</p><p><strong>充退汇总查询：</strong></p><p>独立的门面服务，支付层内部以及外部系统均可使用此服务，用以解释指定的充值指令所对应的所有充退指令集合，包括每笔充退指令的金额、状态等。</p><p>服务使用者可通过此服务的结果输出，决定是否继续接受针对本充值指令的充退请求，如：支付层收到产品的充退协议申请，自我完成对“一笔充值指令最多只能存在一笔活动中状态的充退指令”约束规则检查。</p><p><strong>可充退额度统计：</strong></p><p>用以统计每笔充值指令当前可充退金额，如前台会员自助充退则需要获得此统计金额进行控制。</p><p>计算规则如下：</p><p><strong>当前可充退金额=充值指令总额 — （所有此充值指令下充退指令成功金额总和+ 所有此充值指令下充退指令处于活动状态的金额总和）</strong></p><p>此服务接口可接受批量充值指令的可充退额度统计。</p><p><strong>充退高可用性的渠道配置：</strong></p><p>对于业务部门希望一定要将其处理掉的充退申请，比如：某些渠道下的充值指令在发起充退申请时，线下文件方式退款失败了，那么业务部门可能选择柜面提交的方式再次处理；对于支付层的要求是识别出这些高可用性的充退申请，在报送清算指令时为其指明此参数项。</p><p>目前的识别规则分三个维度：<strong>产品、商户(客户)、渠道</strong>，实际上充退产品在申请充退协议时从产品和商户的角度来决定，比如：强制充退产品发起的充退申请，或者由BD签约商户发起的充退都是属于高可用性的充退申请。</p><p>而渠道的识别规则的充值指令，其充退必然属于高可用性，渠道的识别规则我们不希望产品进行管辖，那么识别的规则需要产品层与支付层共同协作完成。</p><p>产品申请的充退协议中如果已指定了高可用性，则无需再次检查；产品申请的充退协议中未指定高可用性，支付层内置渠道规则生效。</p><p><strong>各类规则配置管理服务：</strong></p><p>简单的介绍一下引入的各类配置规则包括：</p><ul><li>支付渠道配置管理；</li><li>与收银台相关的过滤配置管理；</li><li>统一的支付能力配置管理；</li><li>支付能力与协议配置管理；</li><li>分流目标管理；</li><li>充值后冻结渠道配置管理。</li></ul><p>以上各类规则配置，支付层均需开设相应的管理服务供管理平台使用。</p><p><strong>业务回执分流器：</strong></p><p>本讲说的支付层重要的基础设施之一，负责完成与支付业务处理无关的业务回执分流工作，作为支付层与其他产品系统的通讯支撑。</p><p>分流器需要解决如下几个问题：</p><p><strong>（1）Target</strong></p><p>回执的目标，即需要将支付结果通知给谁，通过预定义的分流目标配置数据，我们将各类产品的接收支付层回执服务地址、通讯方式、通讯质量等记录起来，作为初始的回执目标。新产品上线，辅以管理平台的功能菜单，达到回执目标数据可灵活配置。</p><p><strong>（2）Context</strong></p><p>回执给目标的信息，当请求支付层的支付协议如充值协议，在充值转支付场景下，交易系统需要得到支付层的响应：充值是否成功、充值金额等。</p><p>context有两种注册方式：<strong>一种是包含在协议申请单据中，一种是无任何充值背景的、纯利用此组件进行业务回执，如线下网点等。</strong></p><p>支付层回执给产品的context包含两部分：<strong>请求者注册信息与支付层自有处理结果信息。</strong></p><p>示例：url①+(回执者单据号② [金额，状态，支付渠道…..]③) + (接收者单据号④[买家，卖家，交易金额，商品名称]⑤)</p><p>其中：</p><ol><li>可以在注册请求中指定该url，也可以由支付层通过配置获取，以请求中指定优先；</li><li>必选，代表着希望告诉对方系统处理结果的唯一单据号；</li><li>可选，解释该单据号的关联要素信息；</li><li>必选，代表中接收者唯一可识别的业务单据号；</li><li>可选，解释该单据号的关联要素信息。</li></ol><p><strong>（3）Strategy</strong></p><p>每个回执上下文的处理状态可分为：</p><ul><li><strong>未通知：</strong>尚未回执至产品层；</li><li><strong>已通知：</strong>已回执产品层，但未得到应答；</li><li><strong>成功：</strong>已回执产品层，得到应答，并且后续处理成功如充退申请成功，终结状态；</li><li><strong>失败：</strong>已达到最大尝试次数，不再进行再次尝试的终结状态。</li></ul><p>分流器与与业务逻辑互不侵入，仅仅充当通讯工具的角色，原则上分流器不会自我发起业务回执，需要第三者来通知分流器执行回执。但分流器本身也拥有一定的处理抉择权，如已通知的任务实例。</p><p>分流器只对这种场景下的回执行为进行再次尝试，直到满足所指定的最大回执次数为止，分流器只关心系统间通讯状态。</p><p>本讲说的回执通讯方式选型为基于ESB的异步通知方式。</p><p><strong>业务回执分流注册：</strong></p><p>本讲有充值/充退背景的业务回执行为，在组装申请单据至支付层时即设置了回执上下文。而其他子系统也可以直接使用业务回执分流器完成回执，可仅注册回执上下文信息。</p><p><strong>统一支付能力：</strong></p><p>设计提现、充值、充退领域服务可配置的支付能力，保证后续的支付等都可以配置各类协议所使用的差异性支付能力。</p><p><strong>领域服务监听器：</strong></p><p>这里将分流器建设成与支付协议无关的系统间共用通讯通道，从而确保分流器本身的稳定性；另一方面，各类支付协议如充值协议的核心领域服务需要建设的更加坚固、稳定，现在需要另外一个角色来将两者连接起来——领域服务监听器，由其来决定是否该通知分流器进行回执。</p><p><img src="http://image.woshipm.com/wp-files/2018/07/kK0mVS5fdghWwB2AKiGD.jpg" alt="img"></p><p>如上图，通过监听领域服务处理结果，来识别是否需要发起对产品的回执，这样就让核心领域服务层与分流器做到隔离。</p><p>这里会设置一些识别规则，如预定义网银充值B2B特定支付渠道，对于交易产品来说，关心B2B支付的预授权以及清算完成状态。实际上这不是交易产品的约束，而是渠道自身所固有的。</p><p>当充值协议申请单据中指定了回执目标及回执上下文时，此处依据所配置的规则，识别出来当指令状态迁转为预授权或清算成功/失败时，需要通知分流器进行分流，此时即完成分流任务的注册工作。</p><p>当充值领域服务接收到清算层的回执如清算成功后，领域服务完成账务充值等业务逻辑，通知本监听器，包括当前充值指令的状态、金额等信息。由此后领域服务不再关心监听器，以及分流器的实际处理过程，监听器要识别出当前指令状态是否需要回执产品，满足条件则通知分流器进行回执。</p><p><strong>业务回执分流器恢复调度：</strong></p><p>即前文中所提到的分流器默认调度策略：接收到监听器通知但并未执行的，或者采取同步回执通讯方式的，对方应答丢失的两种场景下需要进行再次尝试，当回执次数超过指定的上限后即不再尝试。</p><p><strong>业务回执分流器恢复调度：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/07/flCPpgumXXWvDq7gHKfM.jpg" alt="img"></p><p>如图，支付层将对所有的支付渠道进行管理，支付渠道包含了与金融机构交互的清算通道、以及无需清算类的通道，如余额等，所以支付渠道的范围是大于等于清算通道范围的。</p><ul><li>清算层负责管理各类清算通道的可用性维护，理论上支付渠道中所包含的清算通道部分没有必要一定要与清算层的保持一致，如：状态、API的命名等。但某个清算通道的关闭/开启，我们希望能够直接反映至前台，基于用户体验而考虑，在清算通道发生关闭/开启事件后，需要以异步消息通知至支付层。</li><li>支付层负责同步更新该通道的可用状态，以此反映至收银台的可供选择渠道列表。不考虑对清算层新开通的清算通道数据做同步，此处需要人工介入。</li></ul><h2 id="清算核心"><a href="#清算核心" class="headerlink" title="清算核心"></a>清算核心</h2><h2 id="系统业务流程分析"><a href="#系统业务流程分析" class="headerlink" title="系统业务流程分析"></a><strong>系统业务流程分析</strong></h2><p><img src="http://image.woshipm.com/wp-files/2018/08/5tIfi3wVQQ4uAY1DnyvK.png" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/08/ZOx9MkdnYcggfyZB9OU9.png" alt="img"></p><ul><li>第0步由产品层来实现各种接受提现请求的场景。</li><li>第1-1.2步骤归为支付层处理，支付层的核心是支付协议，前面讲支付核心时已经分析过，简单点说：<strong>一个支付协议可以=一个账务指令+一个清算指令</strong>。其中账务指令和清算指令，都是可以进行运行的最小单位。</li><li>第1-2.4步，本讲中称作<strong>清算平台</strong>，其中2.2和2.3承担的工作叫做<strong>通信前置</strong>，负责指令的发送，和接受指令的返回，在物理部署上他们将会是独立的通信前置机器。像使用文件这种人工提交的方式处理的指令2.2和2.3步骤则分别会被影射到文件生成器，和文件解析器上，也是清算系统和外部进行批量交互的核心组件。</li><li>第3步是清算层处理完毕后的收尾工作，让支付层知道最后的处理结果，对于先扣款的交易来说，这一步的影响仅仅在于两边记录的清算指令最终状态的一致性，对于以后可能出现的其他交易来说，这个状态可能会决定后续账务处理。</li></ul><h2 id="系统架构和领域模型"><a href="#系统架构和领域模型" class="headerlink" title="系统架构和领域模型"></a>系统架构和领域模型</h2><p>逻辑视图</p><p><img src="http://image.woshipm.com/wp-files/2018/08/mpzhN102I0uC7UY0vsr4.png" alt="img"></p><p>部署视图</p><p><img src="http://image.woshipm.com/wp-files/2018/08/tyLg4im7uZZFqBIZqOdj.png" alt="img"></p><ul><li>这里的mix系统职责是两块，一块是作为复杂支付渠道的业务产品，包括（网点支付、代金卡、COD、MotoPay），一块是划入支付层职责的转帐和分润业务。之所以要提出这个系统，是因为这些复杂支付渠道的业务逻辑被分散在多个系统中（支付系统、开发平台、银行网关），而这些在系统中的定位是通信前置，不应该包含这些逻辑。所以统一迁到mix系统中。</li><li>Mix系统的使用者有外部前置系统和收银台，外部前置系统提出复杂支付渠道请求时，外部前置做了基本的接口校验之后，所有逻辑处理由mix来负责。收银台是支付渠道的发起者，如果发起复杂支付渠道请求，也先转给mix来处理。</li><li>Mix系统作为复杂支付渠道的业务产品，但完成支付，最终还是调用支付核心来完成。与mix后端交互系统，目前只有支付核心。发起支付请求时，mix调用支付核心。支付核心支付完毕之后，业务分流给mix系统。</li><li>清算核心负责整体清算模型的运转，所有跟外部机构有清算需求的业务，都经过清算核心，包括前面提到的复杂支付渠道。</li><li>支付核心和清算之间的关系非常明确，支付核心调用清算核心进行清算请求，清算核心清算完毕之后，反馈给支付核心。</li><li>清算核心是负责整体清算模型，具体的清算指令发送，是由几个通信前置来完成的。</li></ul><p><strong>模型总览：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/hhytsaunl6MdzEpidpNU.png" alt="img"></p><p><strong>清算实体通用模型：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/DlB0UiWhtrpY4AzLCGKE.png" alt="img"></p><p>清算指令和清算文件是多对一的关系，核对并处理过的清算指令和清算文件处理结果是多对一的关系。以上都和清算通道接口是一对一的关系、即不论文件或者指令只有一个清算通道接口。</p><p><strong>渠道类型：</strong></p><p>渠道类型和其中一个维度通信类型是密切相关的。</p><p>渠道类型可以这样来划分：快捷、线下、信用卡、人工、银企互联、B2B、B2C、VISA，MIGS（国际支付）、COD、代金卡等</p><p>清算的各种模式也是和渠道类型分不开的，例如：渠道类型为快捷的，统统是使用的实时接口，银企互联则采用批量数据通过接口提交的模式，而线下类型则是批量数据生成文件来进行提交的。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/l2dL3FaqhjuVX9vD7JwM.jpg" alt="img"></p><p>支付机构内部渠道划分为以下几类：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/z8upnp1rXSENhIa66dR2.png" alt="img"></p><p>银行卡类型：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/jP2EO7ScpsT5ZvGHpyao.jpg" alt="img"></p><p>清算类型：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/OydqOe5V9Fw98A5KZpGL.png" alt="img"></p><p>清算指令的状态：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/6LXPWnkkWxsAPUpZ1ybY.png" alt="img"></p><p>清算指令的通信状态（文件类状态）：<strong>指令类状态。</strong></p><p>批量的指令有两种发送的实现模式：</p><ul><li>落地为文件供结算人工下载，人工发送提交。</li><li>直接通过和银行交互的接口批量或者单笔发送出去。</li></ul><h3 id="核心的业务逻辑"><a href="#核心的业务逻辑" class="headerlink" title="核心的业务逻辑"></a><strong>核心的业务逻辑</strong></h3><ol><li>充值文件内清算指令总笔数=充值清算文件处理结果总笔数；</li><li>充值文件内每笔清算指令金额和状态=充值清算文件处理结果内每笔清算指令金额和状态；</li><li>充退文件内清算指令总笔数=充退清算文件处理结果的总笔数；</li><li>充退文件内每笔清算指令金额和状态=充退清算文件处理结果内每笔清算指令金额和状态。</li></ol><h2 id="业务边界分析"><a href="#业务边界分析" class="headerlink" title="业务边界分析"></a><strong>业务边界分析</strong></h2><p><strong>用例总图：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/myhDkJkhma2UPLIDsd6D.png" alt="img"></p><p><strong>清算文件处理：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/vrRnyog0Ch3lyfyThyhw.png" alt="img"></p><p>充值回导文件获取。</p><p>充值回导文件有两种获取方式：</p><ul><li>一种是人工去银行网银系统去下载，并保存到本地硬盘，然后通过工作平台提供的上传功能进行上传。</li><li>第二种是人工或系统触发（系统自动触发会是固定时间点，或者有规律的时间段）并由系统通信前置与银行服务器进行交互拿到回导文件。</li></ul><p>我们这里主要指的是第二种。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/Ppm82MKMAS6OfXSJJwe6.jpg" alt="img"></p><ul><li>如上图，我们将会通过标准接口和通信前置交互获取到文件，实际保存动作由通信前置完成，保存完成后将文件路径返回给清算文件处理模块。通信前置获取到文件后，要把纯文件信息保存到数据库中。</li><li>在文件被解析成功后将数据导入SETTLE_BANK_RETURN表，同时将文件摘要信息保存到SETTLE_BANK_RETURN_BATCH表。</li><li>通信前置需要一定的缓存功能，比如：一些银行多种业务一个文件返回的，那么通信前置需要能区分出来，不要去请求银行多次。</li></ul><h3 id="清算文件处理"><a href="#清算文件处理" class="headerlink" title="清算文件处理"></a><strong>清算文件处理</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/08/Y8ruNuKuVNUmvRrabMus.png" alt="img"></p><p><strong>充值回导文件解析：</strong></p><ul><li>见上图，我们要把解析脚本内容保存到数据库，直接读取数据库中的内容，这样方便管理和更新。</li><li>每一个文件解析脚本和文件模板都需要仔细开发。</li></ul><p><strong>充值回导文件导入：</strong>文件解析完成后，需要把数据对象存储到数据库中，对于充值来说业务关键字段和提现一样：充值订单号和充值金额。</p><p><strong>充值回导文件对账：</strong></p><ul><li>对账需要在导入后进行触发，可以是人工触发，也可以是系统自动触发，也可以在导入后立即系统自动触发对账。系统将提供接口供工作平台调用或者系统自己调用。</li><li>系统触发可以配置成一个定时执行任务，这样可以把实时要做的事情变成异步确保会做的事情，将使用到定时预约的系统功能，在定时查询中有讲这个工具。</li></ul><p>通用的对账流程如下图：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/K3vKmXjNQ4Hjn4ljGji2.png" alt="img"></p><p><strong>银行通信前置：</strong>主要涉及到的工作是网银对指令的签名、校验签名以及报文服务费与清算核心的对接，还有获取对账文件的对接。</p><p><strong>清算指令处理：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/xbYaG7LVvdHTkp029bax.png" alt="img"></p><p><strong>指令的清算结果状态：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/T8yRQ5AD0VBiFRoSZafx.jpg" alt="img"></p><p><strong>清算指令的通信状态（文件类状态）：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/hBqn4oNpEoTcsKiKCutG.png" alt="img"></p><p><strong>指令类状态：</strong>批量的指令有两种发送的实现模式。</p><ul><li>落地为文件供结算人工下载，人工发送提交。</li><li>直接通过和银行交互的接口批量或者单笔发送出去。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/08/u2doy0xm6IjIJsF1H0Eg.jpg" alt="img"></p><p><strong>内部服务管理：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/f2ngHoq9iOekXMNYn5Sc.png" alt="img"></p><p><strong>指令处理时序图：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/6c943O5ovPfl1p6yS4aK.png" alt="img"></p><h2 id="系统边界分析"><a href="#系统边界分析" class="headerlink" title="系统边界分析"></a><strong>系统边界分析</strong></h2><p>经过前期对业务上的一些认识，目前产品可以分为三大类：<strong>网银异步模式、直连模式、其它个性化模式。</strong></p><ul><li><strong>网银异步模式包含：</strong>B2B、B2C、VISA、MIGS这些有支付机构和银行页面展示的，银行端需要用户输入账号密码进行支付的业务。</li><li><strong>直连模式包含：</strong>网汇E、快捷这些通过某种协议只需要在网站确认就可以进行支付的业务。</li><li><strong>其它个性化模式包含：</strong>MOTO、线下网点金融机构、信用卡还款、COD货到付款、代金卡、电话支付这些属于清算但是模型很复杂的业务。</li></ul><p><strong>直连模式：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/TK2EUcG9FXIwSQur5TiR.png" alt="img"></p><p><strong>网银异步模式：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/WdANJ3jYpTkQI9RdmKbx.jpg" alt="img"></p><h2 id="支付系统架构"><a href="#支付系统架构" class="headerlink" title="支付系统架构"></a>支付系统架构</h2><p>流程图：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/MpFhea5RShcTAPmlHwrD.png" alt="img"></p><ol><li><strong>架构的定义：</strong>架构一定是基于业务功能来展开的，主要是制定技术规范、框架，指导系统落地，好的架构是需要不断演变和进化而来的。</li><li><strong>架构需要关注的基础核心点主要是：</strong>安全、稳定、可扩展。</li><li><strong>构建架构时需要关注的点：</strong>目标客户是谁、主要场景有哪些、流程是怎样的、模型、职责有哪些、边界在哪里以及设计。其中比较难以理解的点是困难及模型这两块。</li><li><strong>架构与业务需求的关系：</strong>架构的产生来自于业务需求，业务需求进一步抽象形成架构，架构指导后续研发，研发最终成果解决业务需求的问题。整体是一个正向循环的关系。</li></ol><h2 id="一、支付架构"><a href="#一、支付架构" class="headerlink" title="一、支付架构"></a>一、支付架构</h2><p><img src="http://image.woshipm.com/wp-files/2018/08/mCjzsiSPqqfKd4zUHbh2.png" alt="img"></p><h2 id="二、支付流程分析"><a href="#二、支付流程分析" class="headerlink" title="二、支付流程分析"></a>二、支付流程分析</h2><p><img src="http://image.woshipm.com/wp-files/2018/08/qO8Rs4nH2IGgGlbHTXCu.png" alt="img"></p><ul><li>第一步，用户选择支付渠道，进入商户客户端；</li><li>第二步，商户客户端发送支付要素，到商户服务端；</li><li>第三步，商户服务端发起支付请求到渠道侧（个别渠道如支付宝是不需要此步骤）；</li><li>第四步渠道返回支付凭证到商户服务端；</li><li>第五步商户服务端返回支付凭证到商户客户端；</li><li>第六步，用户调用支付宝控件完成支付。</li></ul><p>接下来是重点，第七步一般渠道是采用异步通知方法来通知商户，但是有些企业是在第六步支付完成之后，在C端会同步通知支付成功。如果以此结果来判断支付是否成功，其实是不严谨会出问题的，应当调用渠道的支付接口来进行核查，然后以渠道返回的结果为准。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/eKfXYUCR1Ru4HM1NW1Dw.png" alt="img"></p><p>在日常工作中，许多企业在选择第四方服务商或者渠道的时候，会着重关注「并发」这个点，认为并发量需要达到上万级才可以满足日常需求，但实际上这个量级非常大，其实并没有必要的。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/tu2yCp3nXYZftXmv2C6t.png" alt="img"></p><p><strong>若直接对接渠道可能会遇到的问题：</strong></p><ul><li>接口文档升级、变更能及时得到通知；</li><li>有些业务没有异步通知；</li><li>同一业务在不同渠道表现不一样；</li><li>各种渠道的各自异常。</li></ul><p><strong>商户的要求：</strong></p><ul><li>清晰的 API 、SDK 文档；</li><li>安全；</li><li>所有应用接口统一标准的异步通知；</li><li>保证出口 IP 稳定（安全）。</li></ul><p><strong>在系统架构设计时需要注意的一些要点：</strong></p><ol><li>提供规范的 API、SDK；</li><li>安全（通讯安全、数据安全）；</li><li>稳定；</li><li>异步通知统一；</li><li>各渠道的异常；</li><li>及时了解渠道接口调整。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/08/zCmEbszFwyxX4V7LVCjk.png" alt="img"></p><p>以上为示例</p><h2 id="三、支付核心逻辑"><a href="#三、支付核心逻辑" class="headerlink" title="三、支付核心逻辑"></a>三、支付核心逻辑</h2><p><img src="http://image.woshipm.com/wp-files/2018/08/GIkGia2YP7so6rUYmINS.png" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/08/9ZSTfpyIpHZjZeSB8z9a.png" alt="img"></p><p>这里讲一下，支付成功之后，我们会把订单信息同步到财务系统，在账务系统里我们设计了诸如转账、汇款等功能，在前期设计时会设计好账务的生成规则，例如；一笔支付的请求会生成多笔账务，对其字段进行区分，这样方便管理和维护。</p><h3 id="支付网关"><a href="#支付网关" class="headerlink" title="支付网关"></a>支付网关</h3><p>此处特指API网关，支付网关的功能：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/DQ9hIfIxp9bjMrgVeF8C.png" alt="img"></p><p>限流最好不要放到业务流程中做，会影响用户的体验。</p><p><strong>支付网关的内容：</strong></p><ol><li>唯一的请求入口；</li><li>统一的身份认证、签名、加解密、流控；</li><li>API 调用计费；</li><li>API 的监控、报警分析；</li><li>API 发布管理；</li><li>熔断；</li><li>API 聚合；</li><li>协议转换。</li></ol><p>上述内容除了必要意外，其他不放在业务层做，也是为了更好的用户体验。</p><h3 id="支付逻辑"><a href="#支付逻辑" class="headerlink" title="支付逻辑"></a>支付逻辑</h3><p>主要是根据请求的参数进行静态检验和业务逻辑校验，避免系统异常。</p><ol><li>适配渠道的参数校验：长度、类型、格式；</li><li>订单的支付状态：是否支付；</li><li>订单的有效期等等。</li></ol><p><strong>要点：</strong></p><p>一般商户是不需要做支付路由，大部分都是指定了最终的某个支付渠道。</p><p>但也有些没有指定了某个最终的渠道，比如银行卡的支付可以选择哪个第三方支付来完成支付，还有微信线上线下的封装，这个时候就涉及到支付路由规则配置。</p><ul><li><strong>费率：</strong>单笔费率、总额费率、阶梯费率；</li><li><strong>营销活动：</strong>固定时间单笔优惠、单笔满减、单笔这款、直接补贴；</li><li><strong>额度限制：</strong>单笔额度、时间范围内总额度；</li><li><strong>服务指标：</strong>失败率、平均响应时间、异常率、TPS；</li><li><strong>特殊配置：</strong>特殊要求（比如某渠道能快速结算）。</li></ul><p><strong>支付网关的目的——省钱。</strong></p><h3 id="支付风控"><a href="#支付风控" class="headerlink" title="支付风控"></a>支付风控</h3><p>要点：梳理清楚业务风险，分析风险原因，制定风险防范规则。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/8uUhe1xtwnR0oZL8CgvY.png" alt="img"></p><p><strong>（1）数据来源</strong></p><p><strong>内部数据：</strong></p><ul><li>用（商）户信息</li><li>交易数据</li><li>账户数据</li><li>黑名单</li><li>设备、位置信息</li><li>日志数据</li></ul><p><strong>外部数据：</strong></p><ul><li>第三方购买</li><li>央行征信</li><li>芝麻信用</li><li>合作数据</li></ul><p><strong>（2）风控流程</strong></p><p><strong>事前：</strong></p><ul><li>入网审核</li><li>风险评估</li><li>单笔限额设置</li><li>单日限额设置</li><li>频次设置</li></ul><p><strong>事中：</strong></p><ul><li>实时分析</li><li>多维度判断</li><li>拒绝</li><li>拦截 – 进一步验证– 人工介入</li><li>延迟操作（例如用户大额提现，需要时间段进行复核）</li></ul><p><strong>事后：</strong></p><ul><li>数据分析</li><li>巡查、警告</li><li>降低评级</li><li>升级防范措施</li><li>逻辑完善</li><li>反馈至事前、事中规则中</li></ul><h3 id="账务系统"><a href="#账务系统" class="headerlink" title="账务系统"></a>账务系统</h3><ul><li>账务生成</li><li>内部对账</li><li>原始账单下载</li><li>生成标准账单</li><li>对账</li><li>差错处理</li></ul><p>账务生成后首先进行内部对账，一直后进行原始账单下载，再生成标准账单，进行对账之后进行差错处理。</p><p><strong>内部流程如图：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/rm37fTLk2o2L9bRThaZx.png" alt="img"></p><ul><li>订阅交易信息；</li><li>根据交易事件查询生成账务的规则。</li></ul><p>交易事件：<strong>支付、退款、转账等等。</strong></p><ul><li>根据规则生成账务明细；</li><li>将账务明细落地。</li></ul><p><strong>对账流程（实现方式之一）</strong></p><p>内部对账：</p><ul><li>保证账务和交易信息配对</li><li>一条交易信息有多条账务信息</li></ul><p><strong>渠道账单下载：</strong></p><ul><li>下载；</li><li>账单标准化（对账字段统一）；</li><li>落地标准化账单。</li></ul><p><strong>对账：</strong></p><ul><li>账务和标准账单对账；</li><li>双向对账；</li><li>差错处理。</li></ul><p><strong>账单下载：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/eugyQiO0UEArQDnbpffI.png" alt="img"></p><p>这里提一句，在做异常处理这部分工作时，有的研发朋友写代码时遇到过类似的问题，例如：订单在周末下单，但账单周一才能查询；等到周一时发现查询不到，选择立即重试 + X 分钟后重试就结束了。</p><p>这样是不行的，因为银行有的是 8 点之后可以查询到，有的是 9 点之后，所以要选择递增时间重试，然后标记人工处理。</p><p><strong>对账：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/LsOTOmNoJwHHywd6GuPe.png" alt="img"></p><p><strong>对账部分：</strong></p><ol><li>获取核对文件；</li><li>以账务系统为准来逐笔比对（以某个字段为准进行比对）；</li><li>数据一致标记成功，数据不一致标记差错。</li></ol><p><strong>反向操作：</strong></p><ol><li>以渠道账单为准来逐笔比对；</li><li>数据一致标记成功，数据不一致标记差错。</li></ol><h3 id="差错处理"><a href="#差错处理" class="headerlink" title="差错处理"></a>差错处理</h3><ul><li>本地丢失：渠道账单的数据未在账务中查找到。</li><li>渠道丢失：账务中的数据未在渠道账单中查找到。</li><li>数据差错：账务与渠道某些对账字段未能对上。</li></ul><p><strong>此处需要注意的是，</strong>针对差错都需要向渠道查询每笔订单信息再次确认，同时，有些渠道的交易成功时间本来就是有错误的。一般来说是件不会差错很大，一般出现在跨日交易中，例如：当天交易无账单，先标记为差错，第二天再改正。</p><h2 id="四、支付基础服务"><a href="#四、支付基础服务" class="headerlink" title="四、支付基础服务"></a>四、支付基础服务</h2><ul><li>Webhook</li><li>公共推送服务</li><li>主动查询</li><li>补偿</li><li>链路监控</li></ul><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/BlXzVF5hPpMqS0WP2fxP.png" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/08/IYOel7uXbl0g0VhXiTA3.png" alt="img"></p><h3 id="公共推送服务"><a href="#公共推送服务" class="headerlink" title="公共推送服务"></a>公共推送服务</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/cmw7C4JiLijdbqxFg1CY.png" alt="img"></p><p><strong>主动查询</strong></p><p><strong>异步延时调用</strong></p><p>场景：</p><ol><li>订单创建成功的时候会向服务推送主动查询信息，如果订单支付成功会通知服务取消后续的主动查询，否则在过期时间点向渠道主动查询订单是否支付目的是避免渠道异步通知服务的异常。</li><li>退款创建成功的时候会向服务推送主动查询信息，该服务会在一定的时间范围内多次查询渠道直到有明确的结果返回（有些渠道没有异步通知）。</li><li>转账也是类似的逻辑，但某些渠道只提供重试的功能，要注意幂等性。</li><li>……</li></ol><p>补偿：</p><ul><li>协调保证各模块间数据的一致性；</li><li>一般会跟重试、回滚、兜底来协调使用；</li><li>使用条件：系统异常、业务异常；</li><li>补偿失败报警人工干预。</li></ul><p><strong>链路监控</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/0aaYKH24JnCANwhgXlln.png" alt="img"></p><p><strong>展示信息：</strong>应用、URL、调用方、调用时间、调用次数、调用失败次数、本地平均耗时、总平均耗时、调用失败平均耗时 、错误率、依赖度。</p><p><strong>关注：</strong>Cache、SQL、HTTP、TCP</p><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/vBtKr1EeEJXY8KMP02OP.png" alt="img"></p><h3 id="依赖度"><a href="#依赖度" class="headerlink" title="依赖度"></a>依赖度</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/DzkxRTvFR0fUf5qE2USM.png" alt="img"></p><h2 id="五、支付安全"><a href="#五、支付安全" class="headerlink" title="五、支付安全"></a>五、支付安全</h2><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><p>防窃听、防越权防抵赖、防破坏、防篡改、防重放、防泄漏。</p><p><strong>使用范围：</strong>网络、系统、应用、业务等。</p><h3 id="数据安全要点"><a href="#数据安全要点" class="headerlink" title="数据安全要点"></a>数据安全要点</h3><ul><li>加密通讯（防窃听）</li><li>双向签名（防抵赖、防篡改）</li><li>敏感数据加密存储（防泄漏）</li><li>密钥管理（通过认证接口获取，只允许加载到内存，不允许直接写入配置文件）</li><li>权限控制（防越权-非法访问）</li><li>数据的完整性（放篡改- 数据被恶意修改、非法篡改）</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>内部接口认证。</li><li>避免内部代码未经审核发布到托管平台！！！</li><li>数据异常分析。</li><li>安全机构合作。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>使用 HTTPS 加密传输；</li><li>传输的数据使用签名；</li><li>提交的数据是符合规则并且是不存在或者是未支付的；</li><li>支付成功以服务端异步通知为准。</li></ul><h2 id="财务对账"><a href="#财务对账" class="headerlink" title="财务对账"></a>财务对账</h2><h2 id="概念及目的"><a href="#概念及目的" class="headerlink" title="概念及目的"></a><strong>概念及目的</strong></h2><p>首先抛出3个问题：</p><ol><li>为什么需要对账？</li><li>支付机构是如何进行账务对账的？</li><li>互联网平台应该如何进行对账模块的设计？</li></ol><p><strong>对账</strong>是会计学的一个名字，会计学对对账的定义是：<strong>为了保证账簿记录的真实性、完整性、准确性，在记账以后结账之前，定期或不定期地对有关数据进行检查、核对。</strong></p><p>账簿记录是对公司企业日常经济活动的记录，类似于我们日常生活中使用记账 APP 来记录日常开销，记账 APP 里的每一条记录都是账簿记录。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/wQJ6OCKb89V28dBDhYDP.jpg" alt="img"></p><p>这里重点是对账簿记录进行核对，包含三个方面的核对工作，即账证核对、账账核对、账实核对。</p><p><strong>（1）账证核对</strong>，是将账簿记录与记账凭证进行核对，这里是记账凭证是指日常经济活动的书面证明。如果还是用记账 APP 来类别的话，我们超市购物的小票、购买商品的发票、银行卡的收款转账记录，都是记账凭证。</p><p><strong>（2）账账核对</strong>，是把有相互关系的多个账簿记录进行核对。有相互关系的账簿记录，包括总分类账簿间核对，明细账簿间核对等多种类型。例如：我们使用记账 APP 时，整个家庭的日常开销和购物、教育、交通等分类开销的核对，是总分类账簿间核对；核对银行卡取现记录和日常现金支出记录，是明细账簿间核对。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/76UHBP9UgUxnOXNsLrY2.jpg" alt="img"></p><p><strong>（3）账实核对</strong>，是各项资产物资的记录数值与实际真实数额间的核对。例如：我们使用记账 APP 记录购买了一台手机，我发现自己手里确实有一台手机，这就是账实核对。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/fsXG2jFldFxomnGocgID.jpg" alt="img"></p><h2 id="业务场景中的对账"><a href="#业务场景中的对账" class="headerlink" title="业务场景中的对账"></a><strong>业务场景中的对账</strong></h2><p>以上内容说明的是会计上是如何定义对账的，下面让我们看一下具体的业务场景中，是如何定义对账的。</p><h3 id="1-对账的职能"><a href="#1-对账的职能" class="headerlink" title="1. 对账的职能"></a>1. 对账的职能</h3><p>Ping++ 服务的客户都是开展电子商务业务的互联网公司或项目，我们习惯称之为电商平台。电商平台的对账，主要需要完成如下三个任务：</p><ol><li>核对平台自身系统交易数据与支付渠道的对账单数据，并将交易金额和支付渠道结算资金进行核对。</li><li>保证电商平台各系统间交易状态、交易资金的一致性，支付订单和业务订单状态要一致，收款金额和订单金额一致，总收款金额和商品金额、运费金额要一致。</li><li>要包含对账和后续的差错处理流程。</li></ol><h3 id="2-对账的内容"><a href="#2-对账的内容" class="headerlink" title="2. 对账的内容"></a>2. 对账的内容</h3><p>对照会计定义中，对账包含的三个方面核对工作。</p><ol><li>对于电商平台来说，<strong>记账凭证</strong>就是电商平台自身的交易订单，支付渠道提供对账单。</li><li><strong>账账核对</strong>，最重要的是将系统交易数据和渠道的对账单数据进行核对。同时也包括自营商品交易、入驻第三方交易数据的核对，有余额钱包的平台，需要进行余额数据和交易数据的核对。</li><li>电商平台需要向入驻第三方进行付款时，要进行结算数据与交易数据的核对。<strong>账实核对</strong>，是将交易数据与支付渠道收款金额、已发货商品数量进行核对，结算数据和付款进行进行核对。</li></ol><p>对账模块是大家搭建电商平台、进行业务系统、支付系统规则设计时，容易忽视的环节。往往在平台业务上线后，交易量出现爆发增长，人工无法处理每天出现的差错交易时，才会考虑设计、开发对账模块。</p><p>将对账模块的价值比作一个冰山的话，业务运行正常情况下显示的价值，就是冰山海面上的部分；当电商平台发生差错交易时，平静被打破，才会显现出对账的真正价值。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/ahybzVIPTjlIgpZ8I6mi.jpg" alt="img"></p><h3 id="3-对账的价值"><a href="#3-对账的价值" class="headerlink" title="3. 对账的价值"></a>3. 对账的价值</h3><p>平台发生差错交易时，对账模块的价值主要体现在：</p><ol><li>通过系统自动进行交易数据的核对，解放了财务、运营人员的工作时间，让他们可以专注于可以公司创造更多价值的工作上；</li><li>自动完成大量交易数据的核对工作，订单数据量很大的情况，单靠人工无法完成交易数据核对并定位差错；</li><li>可以在第一时间发现差错交易，并及时进行处理。不用等到客户投诉来了，再定位问题进行处理，提高了用户体验。</li></ol><p>电商平台的对账包含差错处理模块，运营人员人工完成差错处理后，将交易数据同步更新到支付系统；同时还包括电商平台日常业务流程中，和支付系统相关的业务订单系统、发货仓储系统、财务管理软件等周边系统，保证整个平台数据的一致性。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/f8f9EgRGXwp4vF4QV5Tf.jpg" alt="img"></p><h2 id="对账的设计"><a href="#对账的设计" class="headerlink" title="对账的设计"></a><strong>对账的设计</strong></h2><p>如何进行对账模块的设计，我想先说明下支付机构是如何进行账务对账的。众所周知，支付机构每天需要处理大量的交易订单和资金，支付机构的账务对账对我们进行电商平台对账模块的设计，有很好的指导价值。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/8anOXOM9d2xltytvq70p.jpg" alt="img"></p><p>支付机构在进行交易处理时，主要涉及三个系统模块，分别是<strong>联机</strong>、<strong>清分</strong>和<strong>结算</strong>。</p><p><strong>（1）联机系统</strong>负责处理商户的交易，并将交易发送到后端扣款渠道完成交易。支付、代扣、代付、预授权等多种类型的交易，都通过联机系统进行处理。联机系统完成交易处理后，记录的交易信息有：交易时间、交易商户、交易金额、交易类型、扣款渠道等信息。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/odShzu2RC0JPTiuNKmBp.png" alt="img"></p><p><strong>（2）清分系统</strong>主要负责各类账务金额的计算，根据交易类型计算交易商户手续费，根据扣款渠道计算交易成本，手续费减去成本等到支付机构的手机数据。清分系统还负责对账工作，将联机交易信息和资金来源方流水文件进行核对。</p><p>资金来源方就是扣款渠道，两方的数据核对完成后，对于有差异的流水，生成差错交易。差错交易会交由运营人员，进行差错交易处理。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/hUU1VcK8xgIsjBBJ18Uv.jpg" alt="img"></p><p>对账后，正确无误的交易会生成结算流水文件。如果某一个扣款渠道的流水文件存在差错交易，则这个扣款渠道所有交易都不会生成结算流水文件。等待运营人员完成差错处理后，清分系统再对该扣款渠道的所有交易生成结算流水文件。</p><p><strong>（3）结算系统</strong>根据清分生成的结算流水文件，生成支付机构对外付款的商户结算数据、等待收款的资金来款方数据，以及支付机构的收益数据。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/9Utd1QPlGD2Z8t44vep5.jpg" alt="img"></p><p>支付机构负责进行交易资金处理的工作人员，在所有扣款渠道的资金全部入账后，对交易商户所有扣款渠道的交易资金通过一笔资金，完成交易资金的结算。结算系统根据结算流水文件，为交易商户生成对账单，供交易商户后续核对交易订单使用。清分系统对账后，会生成差错交易等待运营人员处理。</p><h3 id="典型差错类别及处理方法"><a href="#典型差错类别及处理方法" class="headerlink" title="典型差错类别及处理方法"></a>典型差错类别及处理方法</h3><p>下面会介绍几种典型的差错类型及其处理方式。</p><p>第一种差错类型是长款，简单来说就是支付机构<strong>收的钱多了</strong>。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/i9LUbiq4VIqITLEQKQ4B.jpg" alt="img"></p><p>这种类型的差错交易表现为，资金来款方流水文件有记录，而支付机构联机交易状态为未支付、超时等情况。这种情况下，交易商户未收到交易成功信息，支付机构需要交易资金通过来款渠道返还用户。</p><p>第二种差错类型是短款，也就是支付机构<strong>收的钱少了</strong>。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/zUFcfL3SFFJipcm6DrKH.jpg" alt="img"></p><p>这种类型的差错交易表现为，资金来款方流水文件无记录，而支付机构联机交易状态已成功支付。除了支付机构自身系统故障，错误记录了交易状态之外，发生短款差错的常见原因是，<strong>该笔交易资金在通过人民银行系统进行资金划转时，未能及时划转到来款渠道，导致来款渠道无法将交易资金结算到支付机构</strong>。</p><p>这种情况下，支付机构需要向来款渠道发起请款操作，同时将交易商户的其他无差错交易资金进行优先结算。</p><p>第三种差错类型双方的交易数据记录不一致，例如交易金额不一致、支付机构记录的成本金额和来款渠道实际成本金额不一致等。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/FHggUWV0y97jG4onhr4M.jpg" alt="img"></p><p>发生数据记录不一致的情况，比较罕见，处理差错时，需要业务人员和开发人员配合，根据实际情况进行针对性的处理。</p><h3 id="对账模块设计思路"><a href="#对账模块设计思路" class="headerlink" title="对账模块设计思路"></a><strong>对账模块设计思路</strong></h3><p>对于支付机构账务对账流程，有了一个宏观的认知后，下面会借鉴支付机构的对账流程，介绍下<strong>互联网电商平台的对账模块设计思路。</strong></p><p>支付系统是电商平台对接各个支付渠道，完成交易订单处理的核心系统。电商平台进行对账模块设计时，首先要进行的就是支付系统对账。</p><p>支付系统对账，是将本系统产生的交易资金和支付渠道的结算金额进行核对。包含对<strong>账单下载、数据准备、对账、差错处理</strong>四个环节。</p><p><strong>（1）账单下载</strong>支付系统要对接支付宝、微信、银联等多个渠道，在进行对账单下载时候，就需要针对不同的支付渠道的特点，进行针对性的处理，主要注意这三个方面的不同，分别是：<strong>下载方式不同、下载时间不同以及文件格式不同。</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/5UKG6oEmGADjp8Iz4aNU.png" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/08/6FTLWUkt8pdtFTDuYB3J.png" alt="img"></p><p>完成了对账单下载，就需要对渠道对账单数据和本地交易数据，整理成可供对账处理的数据。</p><p><strong>（2）数据准备</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/xwDAIDpYJhf1OYKyc0yO.png" alt="img"></p><p>数据准备后，要注意和渠道对账单原始数据、本地交易订单原始数据进行核对，保证数据的准确性。</p><p><strong>（3）对账</strong>单笔账单需要对商户订单号、渠道流水号、交易时间、交易金额等字段进行比对，所有订单进行逐笔比对。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/4FIRzQ1PfiWyi9cfibQe.png" alt="img"></p><p><strong>（4）差错账处理****失败订单</strong>：支付系统中状态为“失败”的，渠道状态为“成功”的订单。</p><ul><li>首次对账，对账模块本地交易数据无此订单；</li><li>按渠道数据中的商户订单号、渠道流水号、交易时间，在支付系统查找该笔订单，导入对账模块进行数据准备后，进行二次对账。</li></ul><p><strong>跨天订单</strong>：本地交易数据和渠道对账单记录的交易时间不在同一天。</p><ul><li>交易时间中日期一致的不记录为差错；</li><li>日期不在同一天，按本地交易日期计入当天差错交易。</li></ul><h2 id="支付渠道"><a href="#支付渠道" class="headerlink" title="支付渠道"></a>支付渠道</h2><h2 id="一-支付渠道业务规则"><a href="#一-支付渠道业务规则" class="headerlink" title="一. 支付渠道业务规则"></a>一. 支付渠道业务规则</h2><p>这部分内容主要介绍常见支付渠道的业务规则以及选择渠道过程中需要关注哪些重点，主要面向商家的业务部门，方便根据自身业务模式匹配最合适的支付渠道。</p><h3 id="1-产品概述和应用场景"><a href="#1-产品概述和应用场景" class="headerlink" title="1. 产品概述和应用场景"></a>1. 产品概述和应用场景</h3><p>要想了解支付渠道的业务规则，首先需要知道目前主要的支付渠道、支付产品有哪些，是什么模式，然后商家根据自身产品及业务模式去匹配最优的支付方式。</p><p>一般情况下对接的支付渠道有两类：</p><ul><li>银行：招行、建行、农行等</li><li>支付机构：微信、支付宝、京东等</li></ul><p>每个渠道有自己的收款产品，对应在不同的支付终端上使用。这里讲一下，「支付终端」换成「支付场景」也是合适的，不同公司团队个人叫法可能有所不同，总之方便理解来看就是电脑网站、手机网站以及手机应用等等。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/e3vQYD3lCocF6IeBhSga.png" alt="img"></p><p>这里将各个渠道的收付款产品放到了对应的支付终端下，不同支付终端下支持的渠道支付产品也有所区别，且需要独立申请开通权限。</p><p>微信在移动应用、手机网页、pc 网页、公众号内、线下扫码、微信小程序中的支付产品分别是：APP 支付、H5 支付、扫码支付、公众号支付（仅能在微信浏览器内支付）、刷卡支付（也包含扫码支付 ）、小程序支付（ 其中小程序内不能使用其他渠道的支付产品）。扫码支付和刷卡支付的区别是，前者是用户扫商家码，后者是用户的支付码被商家扫。其中需要注意的是，APP 支付和公众号支付需要分别在开放平台和公众平台进行申请开通。开通公众号支付后，默认会开通扫码支付和刷卡支付的产品权限。H5  支付功能是在微信商户平台上开通的支付产品权限，前提是至少开通APP支付、小程序支付、公众号支付的其中一种支付权限。</p><p><strong>分期产品：</strong>目前比较常见的花呗分期和京东白条，这两家的分期产品早期都是放在收银台的一种支付方式，C 端用户在选择支付宝或者京东支付之前并不能直观的了解到该商家是否支持分期，所以后期两家也推出了分期前置的模式，即支持分期支付方式直接在商家收银台进行展示（对于 C 端用户来讲，更加直观，体验更好，能够有效降低消费者心里门槛），与支付宝、微信、QQ 钱包支付可做平级展示。</p><p>简单介绍了商家收款，我们也来看看商家付款的产品功能：</p><ul><li><strong>代付：</strong>代付，我们通常称「代付」主要指的是商家充值到在支付机构开通的备付金账户，然后直接调用代付接口下发给 C 端用户或者 B 端商家银行账户。</li><li><strong>转代付（这个叫法可能不同公司有所不同，转代付比较容易理解）：</strong>转代付，这里指的是先通过支付渠道的支付产品收款至企业账户，然后直接通过出款接口进行下发。现在的微信新资金流的企业付款就是转代付的模式。</li><li><strong>分账（严格意义来讲不能称之为商家出款行为）：</strong>指的是商家在发起收款订单时即指定了相关的分账信息，用户支付成功时，直接将资金分账到对应的 B 端商家企业账户。</li></ul><p>下面一张图看看<strong>转代付</strong>和<strong>分账</strong>的区别：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/ASD17z7x5ZhgKZ9WFuBl.png" alt="img"></p><p>B 商家发起收款 100 元，后续可以给 C 端商家或者 B 端商家进行打款。这里需要注明的是，给商家或者用户打款的 X 和 Y 元，跟 100元没有必然联系，只要确保出款账户内资金足够用于 B 商家打款即可。</p><p>这里需要提及下，微信的企业付款只能针对 C 端用户，不能给 B 端商家打款。支付宝的单笔转账可以给 C 端用户和 B 端商家的支付宝账户转账。</p><p>因为微信现在区分新旧资金流，所以现在企业付款到零钱资金根据商户号的账户开通情况，实际出款账户有做区别：</p><ul><li>默认情况下，企业付款到零钱使用商户号基本户（或余额账户）余额。如商户号已开通运营账户，则企业付款到零钱使用运营账户内的资金。</li><li>基本户（或上述其他出款账户）的资金来源，可能是交易结算款项（仅基本户），或给账户充值的资金。当出款账户余额不足时，付款将因余额不足而付款失败。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/08/chZiZCX0wKANpnNyO3K5.png" alt="img"></p><p>B 商家发起 100 元收款，含分账指令给 C 商户 20 元，那么最终用户完成这笔订单支付的时候，则商家 B 收款 80 元，商家 C 收款 20 元。分账模式比较适用于平台类型的商家或者集团类型的商家，目前所接触到的微信分账并没有对外开放申请，最多关联的分账账户有 5 个的限制。支付宝的分账目前看到的是在跨境上有用到，最多支持在 10 个以内。两个分账功能均需要单独联系 BD 进行申请。</p><h3 id="2-行业准入和区别"><a href="#2-行业准入和区别" class="headerlink" title="2. 行业准入和区别"></a>2. 行业准入和区别</h3><p><strong>（1）商家收款类别</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/pFv1HVCD1V8yfG8oeI9K.png" alt="img"></p><p>1）这里简单列了下大的分类，主要有实物类、虚拟类和政府/事业单位（主要指的公立医院和学校）走微信和支付宝的渠道申请所对应的费率和结算周期的区别。特殊行业对应所需要的资质也有所区别。</p><ul><li><strong>实物类：</strong>医疗类的会有资质文件才可以申请，比如医疗器械、身体康复用品的需要持有《医疗器械经营企业许可证》、经营内容包含美瞳或者隐形眼镜，则需要提供《第三类医疗器械销售资质》等等；</li><li><strong>虚拟类：</strong>比如游戏道具购买，需要具备《网络文化经营许可证》。</li></ul><p>2）商家的行业可以直接参照腾讯或者支付宝的的商家类目、费率、资质的文档，简单粗暴，可以到官网上了解一下。</p><p>3）这里提及一下，前面的花呗分期和京东白条产品：使用的前提都是至少拥有支付宝或者京东对应的基础支付功能，才能进一步申请分期的产品权限，目前两家的分期产品的权限都是需要单独联系 BD ，走线下申请的流程，周期较长。</p><p><strong>（2）商家付款类别</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/bBhZx4WayOLiZV64H3hR.png" alt="img"></p><blockquote><p>Tips：微信新资金流开通企业付款功能要求商户号开通 90 天且持续 30 天以上有交易流水，才可以申请开通「企业付款」权限，且目前服务商模式不支持企业付款。</p></blockquote><p>目前银行卡代付的申请，看各家机构的要求，目前尚且没有比较固定的行业分类。基本上 case by case 的去看。所以我们主要看看在使用商家付款产品的时候，需要关注哪些内容。</p><p><strong>① 费用</strong></p><p>看代付的费用从两种情况来看，一个是付款到银行卡，一个是付款到钱包账户。</p><p>前者的费用一般是按照单笔手续费计算，比如 1-2 元/笔。后者代付到钱包一般是免费，这个手续费商家不承担，主要在用户发起提现的时候会需要支付提现手续费。</p><p><strong>② 限额</strong></p><p>各家支付机构不一样，但是主要需要与支付机构沟通的是单笔、单日、单月、以及每天的调用频次等是否有限制，限制是多少。</p><p>避免业务部门已经申请完成了渠道，后面产品对接发现根本不能满足业务应用场景，那就后使用起来就 GG 了。</p><p><strong>③ 到账时间</strong></p><p>选择商家付款渠道的时候也需要关注付款到账时间，因为有些应用场景对于实时性要求比较高。</p><p><strong>④ 支持的银行</strong></p><p>支持银行列表也需要多加关注，尤其是 B2B 转账或者对于有特殊银行需求的商家。</p><p>前面在商家付款中提到的代付和转代付，对于微信的<strong>企业付款</strong>产品区分新旧资金流。</p><p>微信现在区分新旧资金流企业付款到零钱资金根据商户号的账户开通情况，实际出款账户有做区别：</p><ol><li>默认情况下，企业付款到零钱使用商户号基本户（ 或余额账户 ）余额。如商户号已开通运营账户，则企业付款到零钱使用运营账户内的资金。</li><li>基本户（或上述其他出款账户）的资金来源，可能是交易结算款项（仅基本户），或给账户充值的资金。当出款账户余额不足时，付款将因余额不足而付款失败。</li></ol><h3 id="3-渠道合作模式和优惠政策"><a href="#3-渠道合作模式和优惠政策" class="headerlink" title="3. 渠道合作模式和优惠政策"></a>3. 渠道合作模式和优惠政策</h3><p>早期商家跟渠道的合作比较单一，但是近 2 年渠道也推出来比较多的合作模式来吸引商家以及合作伙伴。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/Z5DJ6sqqwzbITiVjt7No.png" alt="img"></p><p>简单介绍下各种合作模式：</p><ol><li>直连</li><li>直连（ 入驻 ）</li><li>普通服务商</li><li>银行服务商</li></ol><p>目前服务商模式做的比较好的是微信和支付宝，微信的营销活动做的比较好，之前的智慧餐厅推广叠加活动、随机立减活动，以及最近的朋友圈广告功能投放功能等等活动，无论是从商家成本还是用户体验上，都极大的调动符合条件客户参与活动的积极性。</p><p><strong>各种合作模式的优缺点</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/08/04U9yjME2PiRA0qvaS8J.png" alt="img"></p><h3 id="4-退款处理规则"><a href="#4-退款处理规则" class="headerlink" title="4. 退款处理规则"></a>4. 退款处理规则</h3><p>接下来我们讲讲退款，原先「退款」这一块的逻辑是放在后面渠道开发对接部分的。</p><p>但是因为近期日常渠道运营中遇见了一个关于手续费的问题，退款是否退回手续费的问题一定程度上决定了某些特定场景的商户对于支付渠道的选择，因此把它提到业务规则中来聊一聊。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/EMzjQeFcCSwY4PB70qaA.png" alt="img"></p><p>为什么在业务对接的时候就需要关注上图这三点呢？</p><ol><li><strong>某些特定行业对于退款的周期有特殊要求</strong>，比如共享单车的押金、家具公司的较长退货期等等，这一类允许较长周期退款的行业都需要关注各个渠道的退款周期。如果退款周期不满足需求，最好在入网阶段就能提出延长订单可退款周期的需求，按照渠道要求提交业务说明并变更退款周期。避免到了后期渠道不好调整而导致用户与商家的纠纷投诉。</li><li><strong>关于退款是否退回手续费的规则需要提前与渠道确认好</strong>，正常情况下当用户产生退款，商家是会被渠道退回支付时收取的交易手续费的。但少部分支付渠道存在以下几种情况：退款不退回手续费、部分退款不退回手续费、退款只退部分手续费（退动态手续费，不退固定手续费部分）</li></ol><p><strong>因此需要提前捋顺几个问题：</strong></p><ol><li>退款功能是否需要提前额外申请</li><li>退款周期是否需要延长</li><li>退款资金是否需要额外充值：待结算账户、余额充值账户</li><li>退款或者撤销是否退回原订单的支付手续费</li></ol><p>以下是一张关于各渠道的退款周期，是否退回手续费以及退回手续费的逻辑说明：</p><p><img src="http://image.woshipm.com/wp-files/2018/08/E6axfPCkDai6NzrmulSa.png" alt="img"></p><h3 id="5-支付渠道对接及管理"><a href="#5-支付渠道对接及管理" class="headerlink" title="5. 支付渠道对接及管理"></a>5. 支付渠道对接及管理</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/6acCRRrqyDiscN0WDvCG.png" alt="img"></p><p><strong>（1）资金结算方式</strong></p><p>手动提现还是自动结算，自动结算是否有资金门槛（因为在跨境微信支付宝的渠道资金结算，直连会有 5000 usd 结算资金门槛）</p><p><strong>（2）获取对账单方式</strong></p><p>业务需要提前确认获取对账单方式，是只能通过商户平台下载还是也能通过接口下载。</p><p>如果通过接口下载是否需要提前走申请流程，因为我们有遇见过一些支付渠道下载对账单也需要提前走线下公司盖章的申请流程，周期略长。前期若没有确认好，会都后期项目开发周期造成影响。</p><p><strong>（3）清分时间</strong></p><p>这个跟获取对账单方式时候可以一并确认，一般渠道的清分时间都是 00-24 点之间的交易。</p><p><strong>（4）区分不同交易对账单</strong></p><ul><li>微信新资金流，因为没有待结算和余额充值账户的概念，退款都是从基本户中出去的，所以退款的订单都会在 ALL 类型的对账单中；</li><li>微信旧资金流，区分待结算账户和充值余额账户，即使针对 ALL 类型的对账单，也不包含余额充值的退款对账单。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/08/pJRrEtDSHNR1kXjAFBwF.png" alt="img"></p><h2 id="二-支付渠道对接及管理"><a href="#二-支付渠道对接及管理" class="headerlink" title="二. 支付渠道对接及管理"></a>二. 支付渠道对接及管理</h2><p>这部分内容着重介绍在开发对接渠道过程中需要关注哪些问题，主要面向商家的产品部门。</p><p>第一部分主要讲了商家的业务部门在前期申请渠道时候，场景适配以及需要提前跟渠道沟通了解的注意事项。</p><p>第二部分就涉及到产品技术对接阶段的一些细节处理。</p><h3 id="1-渠道对接步骤和内容"><a href="#1-渠道对接步骤和内容" class="headerlink" title="1. 渠道对接步骤和内容"></a>1. 渠道对接步骤和内容</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/0bt5IK0Y2x6iUKxzWW1e.png" alt="img"></p><p>公司内各个部门不同的产品，线上线下产品适用场景不同，费率会有所区分，注意事项在第一部分已经阐述。</p><ol><li>切记不要申请错了权限，这个对于微信是比较常见的问题（ 服务号、订阅号、APP ）</li><li>配置并获取参数，这一个步骤建议是产品与业务部门能一起操作、确认。另外如果有线下版本的协议，建议产品也可以看下，因为我们曾经遇见过一些渠道有业务处理时间的限制，但是没有写在线下开发文档中，是单独列在了协议中。在获取参数时，部分渠道是一定要通过测试案例提交才能获取正式参数，此处也需要留足项目时间。</li><li>对接支付相关的 API ，按照自己内部支付模块以及支付渠道的对接开发文档对接开发即可。</li><li>上线结果通知：这一步列在这里的原因是因为对外的技术服务商在日常工作中需要留足足够的时间给协同模块。</li><li>关联模块功能更新：可以完成一笔成功的交易并不代表整个交易功能已经完善。比如对于交易明细的展示和管理、报表展示。后期商家内部渠道参数的更新、维护等配套模块也需要做更新。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/08/f5ACXwEbVUjECqEOVrWv.png" alt="img"></p><p><strong>① 是否需要添加出口IP</strong></p><p>部分渠道需要添加 IP 白名单才可以进行开发、测试调试，有些渠道较快的能添加完成，但是有些银行类的可能要走比较漫长的线下申请。</p><p><strong>② 对接的接口版本</strong></p><p>不同支付渠道的接口版本对应的支付渠道的参数也不一样，所以在商务确定产品合作后需要确认对应的业务申请参数和渠道开发的接口版本是否一致。</p><p><strong>③ 订单号长度和组合</strong></p><p>支付机构遇到此类问题比较多。每个渠道的订单规则其实略有不同，例如招行早期的订单号只允许数字形式，不允许其他任何符号；微信、支付宝和银联对订单号的长度要求不同，因此建议订单号长度为 8~20 位，目前来看基本可以适配要求。</p><p><strong>④ 交易金额单位</strong></p><p>一般情况下单位都是以「分」为单位，但也遇到过以「元」为单位的情况。</p><p><strong>⑤ 商品描述特殊字符，是否展示在用户可见的渠道支付页</strong></p><p>部分渠道会因为在商品描述中加入了特殊字符而导致交易失败，然后因为报错提示信息不明显，会导致开发定位较长时间，另外需要确认该信息是否会展示在用户所见的渠道支付页上，避免字段设置的信息给用户产生疑惑。</p><p><strong>⑥ 收款公司名称展示</strong></p><p>常规情况下，大部分支付渠道是可以在后台进行设置或者在入网时有很清晰的提示，但是有些渠道是通过某个字段来进行填写并上传的，比如建行龙支付。</p><p><strong>⑦ 订单过期时间的模式确认</strong></p><ol><li>绝对时间（ 某个固定的时间 ）</li><li>相对时间（ 例如用户在支付页面密码输错了扣款失败，才开始计时 ）</li><li>二维码有效期</li><li>过期时间单位</li></ol><p><strong>⑧分期支付是否支持前置展示</strong></p><p>主要是用户体验的问题，假设不做前置展示可能会在最后一步支付时流失掉这个订单。</p><p><strong>⑨ 是否支持禁用信用卡</strong></p><p>有些商家不希望用户支付使用信用卡，部分渠道可以通过请求参数字段进行设置，也有渠道通过入网签订协议后台配置。</p><p><strong>⑩ 前端带回的参数信息</strong></p><p>大部分商家比较在意前端带回的结果参数信息，例如订单号、支付结果等等</p><p><img src="http://image.woshipm.com/wp-files/2018/08/GhyD4svd1WTCZaie3pT0.png" alt="img"></p><p><strong>① 可退款订单周期、权限开通</strong></p><p>之前在对接线下扫码支付，走服务商模式，退款权限并不默认开通，需要走线下申请的流程后才可以开通。可退款订单周期如之前提及，需要提前申请确认。</p><p><strong>② 单笔订单退款次数、频率限制</strong></p><p>例如微信是有单笔订单对多 50 次退款限制的，虽然实际场景中遇见单笔退款几十次概率很小，但一旦出现这类情况就需要做好线下给用户退款的准备。</p><p><strong>③ 是否支持原单重试</strong></p><p>这种场景微信比较多，微信现在文档上备注的已经十分详细了，尤其对于商家转账红包这种类型的出款，一定需要提前确认是否支持原单重试，避免重复出款。</p><p><strong>④ 是否支持部分退款&amp; 是否退还手续费以及计算逻辑</strong></p><p>对接的渠道大部分都支持部分退款，但是有些个别的渠道是支持退款不退手续费。因此商家遇到用户退款的情况，就会在退款时损失手续费。同时对计算逻辑也要进一步确认，有些渠道的手续费分两部分，一部分是固定手续费，一部分是动态手续费。在退款时也会有全退、只退动态手续费不退固定手续费以及手续费全部不退的情况。</p><p><strong>⑤ 多选一单号请求，需要确认优先级</strong></p><p>这个在退款时微信、QQ 钱包都有过类似的问题，例如早期 QQ 钱包超过 30 天的订单如果不使用交易单号就会报错。因此如果渠道的文档表示两个字段二选一都行，就要提前确认好优先级。</p><p><strong>⑥ 退款描述特殊支付，是否展现在用户可见的地方</strong></p><p>这部分和前面是一样的，就不细说了。</p><p><strong>⑦ 是否支持退款的异步通知</strong></p><p>最早期的时候微信退款无异步通知，我们自己做了个自动查询模块，定时（5s、10s、20s、1min 等等递增）去调用退款查询接口来获取退款状态，现在微信也支持了退款成功的异步通知，主要的支付渠道也都支持了该功能。</p><p><strong>⑧ 是否区分退款资金来源</strong></p><p>这块主要是需要清楚地明白和业务的关联点在哪里，一般在退款接口上会有区分字段提示。</p><p><strong>⑨ 同步返回的状态，是否可以作为最终结果</strong></p><p>该种情况除了接口文档上的描述外，建议与渠道再做二次确认。通常是根据异步通知或者查询的退款结果进行更新，但是存在部分渠道建议直接根据创建退款同步返回结果直接判断的情况，比如支付宝国际的退款，并不提供退款查询接口。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/6C6ig8L7DCyQ5nisvawE.png" alt="img"></p><p><strong>① 支付和退款的查询是否区分接口</strong></p><p>有的渠道不作区分，但有的渠道例如单号是区分支付成功单号以及退款单号两种不同的字段。</p><p><strong>② 确认查询接口展示的状态参数</strong></p><p>比如退款、用户被扫等模式可能存在多个状态，需要考虑多状态之间的关系和更新逻辑。</p><p><strong>③ 多选一单号查询，需要确认优先级</strong></p><p>与前文相同，不做赘述。</p><p><strong>④ 区分通信结果、业务结果、交易结果</strong></p><p>查询一个交易结果之前需要判断通信结果以及业务结果，最终展示的交易状态要根据交交易结果来判断。</p><p><strong>⑤ 结算金额、优惠金额、退款渠道等信息是否返回</strong></p><p>常规情况下渠道会通过支付成功之后的异步通知或者查询返回对应的信息，但是也存在部分渠道是通过后台配置的优惠信息，仅在支付成功页面、对账单中才有体现，并不会体现在交易返回参数中。</p><p><strong>⑥ 查询和异步通知返回的交易相关信息一致</strong></p><p>例如支付宝国际支付，查询与异步通知返回的信息不一致，是由于币种的转换造成的。存在部分返回信息需要提前邮件申请进行配置，虽然对外并没有文档指引和说明。</p><p><strong>⑦ 查询频率是否限制，是否有建议的查询间隔机制</strong></p><p>不同的渠道略有不同，有的渠道对频率有限制、间隔有限制。因此在前期需要确认。</p><p><img src="http://image.woshipm.com/wp-files/2018/08/xO6n8gvB8ifNCX6xOrqH.png" alt="img"></p><p><strong>① 各种交易是否有异步通知</strong></p><p>产品与技术对接过程当中，需要稍微注意一下，因为渠道的文档都放一起，按照惯例是都有的，但是背不住要踩坑，比如线下支付的用户被扫模式。</p><p><strong>② 异步通知地址是请求上送还是后台固定配置</strong></p><p>不同渠道不一样，大部分是通过接口请求上送；小部分渠道通过后台固定地址配置。</p><p><strong>③ 何种状态会触发异步通知</strong></p><p>需要校验异步通知的状态类型，比如支付成功、订单支付中、订单关闭等等，避免未区分异步通知类型导致错误更新订单状态。</p><p><strong>④ 交易成功时间字段</strong></p><p>有些渠道交易成功时间这个字段不正确，可能会导致对账会出现一些问题，需要人工去处理。</p><p><strong>⑤ 是否带回交易请求上送的附加信息</strong></p><p>在渠道提供的交易请求信息并不足以区分商家内部的业务订单时，商家往往还会上送额外的字段信息，有些渠道有去无回，即异步通知不带回该额外信息，导致商家业务更新异常。</p><p><strong>⑥ 重试机制以及恢复信息</strong></p><p>重试机制需要提前确认，如果渠道间隔时间比较长，就需要提前在订单过期前之前加一些查询机制，避免用户体验糟糕。</p><p><strong>⑦ 签名验证或IP 白名单</strong></p><p>异步通知的验证真伪性一般可以通过签名或者 IP 白名单，如果是 IP 白名单的话提现与渠道确认好出口 IP 。</p><h3 id="2-常见对接问题和解决方案"><a href="#2-常见对接问题和解决方案" class="headerlink" title="2. 常见对接问题和解决方案"></a>2. 常见对接问题和解决方案</h3><p><img src="http://image.woshipm.com/wp-files/2018/08/k44M6bvR5AX4gKcFTyhx.png" alt="img"></p><p>一般情况下上图中的情况会导致交易异常，因此建议商家除了对接渠道异步通知也要对接查询接口，可以设置查询任务；同时不建议商家以业务查询结果为参考，查询服务端的订单状态，一旦不一致就调用接口去查询一下，更保险。还有不要查询频率太高，可能造成渠道结果返回不了。</p><p>例如支付宝和微信使用线下渠道会有风控（ 一般线上套线下才会有 ），因此匹配自身场景去申请渠道是最安全的。渠道系统异常的情况，最好是多对接几个渠道，万一挂掉了一个另一个也不影响使用。渠道更新接口/ 规则没有及时同步的情况，这就需要经常爬一下各渠道的公告平台了。渠道数据状态不同步的情况只能去咨询渠道，根据渠道的建议去修改查询模块。</p><h2 id="支付系统难点全面梳理剖析：核算对账核心"><a href="#支付系统难点全面梳理剖析：核算对账核心" class="headerlink" title="支付系统难点全面梳理剖析：核算对账核心"></a>支付系统难点全面梳理剖析：核算对账核心</h2><h2 id="清算对账系统"><a href="#清算对账系统" class="headerlink" title="清算对账系统"></a>清算对账系统</h2><p>支付公司提供的所有金融服务是建立在银行资金体系之上的，支付公司账务系统内账户的资金都与其在银行的存款资金一一对应，为了保证真实的资金账户和虚拟账户的资金转换正确，支付公司必须及时与银行进行各类业务的资金核对，所有资金核对都依赖于银行的系统。</p><h3 id="1-资金流入与银行的对账"><a href="#1-资金流入与银行的对账" class="headerlink" title="1. 资金流入与银行的对账"></a><strong>1. 资金流入与银行的对账</strong></h3><p>从银行流入的资金是由银行侧控制资金结转清算与对账时间，即每日客户通过银行向支付机构充值的资金是由银行实时通知支付机构充值指令的发生，银行在每日晚间经过汇总后向支付机构的银行收款账户入账，同时提供入账清算文件。支付机构获取该文件后，与业务数据进行核对。</p><p><img src="http://image.woshipm.com/wp-files/2018/09/N05jREGfCG1lNFgDM8SR.png" alt="img"></p><p>对账结果若相符，则没有问题。若出现对账结果不符，很有可能是系统或者业务在某些环节发生问题，存在两种情况：</p><ol><li>银行充值明细多，支付机构充值明细少；即银行向支付机构入账资金多于支付机构业务发生情况，一般采取临时挂账处理，查出原因后再具体解决；</li><li>银行充值明细少，支付充值明细多；即银行向支付机构入账资金少于支付机构业务发生情况，则可能对支付机构产生资金损失，一般采取临时挂账处理，查出原因后再具体解决。</li></ol><h3 id="2-资金流出与银行的对账"><a href="#2-资金流出与银行的对账" class="headerlink" title="2. 资金流出与银行的对账"></a><strong>2. 资金流出与银行的对账</strong></h3><p>从支付公司流出的资金是由银行侧控制资金结转清算与对账时间，即每日客户向支付机构申请提现的资金是在每日支付公司批量向银行发起提现请求时，从支付公司银行存款账户扣转，但扣转的结果一般需要一段时间才能从银行侧得到反馈。</p><p>当银行侧提供扣转成功和失败的清算文件，支付公司获取这些文件进行明细核对，对于提现失败的申请，由支付公司后台发起直接将资金回充入客户账户，不在对账中心进行对账处理。</p><p><img src="http://image.woshipm.com/wp-files/2018/09/3wIKQ4uLXcmAjbXgwilr.png" alt="img"></p><h2 id="什么是对账？"><a href="#什么是对账？" class="headerlink" title="什么是对账？"></a>什么是对账？</h2><p><img src="http://image.woshipm.com/wp-files/2018/09/wu2ldWCFjRwQlsym970q.png" alt="img"></p><p><strong>什么是资金对账？</strong></p><p>在会计上的概念：指为了保证账簿记录的正确性而进行的有关账项的核对工作，做到账证相符、账账相符、账实相符。</p><p>在支付机构的概念：<strong>资金对账</strong>，在对账中心进行，将系统保存的<strong>账务流水</strong>与银行返回的<strong>清算流水</strong>和清算文件进行对账，核对系统账务数据与银行清算数据的一致性，保证支付机构各备付金银行账户每日的预计发生额与实际发生额一致。即核对银行实际清算资金如充值、充退、提现等业务的银行处理结果是否一致。</p><p><strong>对账中心的作用？</strong></p><p>是主要处理对账的系统模块，主要业务是<strong>清算对账</strong>。对账中心部署于工作平台，分别接受<strong>会计系统</strong>和<strong>清算系统</strong>的数据输入进行对账处理。</p><p>对账中心最主要的<strong>职责</strong>是勾兑银行清算流水与支付系统入账流水，用以检查反映银存实际账户的余额变化与支付系统内部户余额变化是否平衡。对于已经核对无误的银行清算流水和支付系统入账流水，分别进入相应的历史银行流水库和历史入账流水库。</p><p>对于勾兑结果中银行清算流水多于系统入账流水的，而操作人员不明确资金的来源，需要根据所设定的分类规则将暂不明确的资金进行挂账处理。而后我们认为该部分资金已经系统入账，可以入历史流水库。</p><p>因为此时的银存实际账户的余额增加，与之对应的是支付系统内部户余额也增加了，比如： T 日的挂账可能会在 T+N 日后进行销账确认，而后续的销账行为是对明细流水的业务分流处理，我们不应将 T+N 日的销账所产生的账务流水作为入账流水，不再需要到对账中心体现。</p><p><img src="http://image.woshipm.com/wp-files/2018/09/FQaKCjhPdQMj6dwnZLcS.png" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2018/09/oUZhUrzCftysp2mogrOB.png" alt="img"></p><h2 id="对账内容和数据来源"><a href="#对账内容和数据来源" class="headerlink" title="对账内容和数据来源"></a><strong>对账内容和数据来源</strong></h2><p><strong>第一步</strong></p><p>入账流水和清算流水进行核对，目的是保证对每一笔订单银行的处理结果和我们系统的业务处理结果一致。</p><p><strong>第二步</strong></p><p>对账汇总确认单和银行对账单进行核对，目的是通过轧余额等方式，核对各类业务的银行处理结果是否与银行实际清算给我们的资金一致。</p><p><img src="http://image.woshipm.com/wp-files/2018/09/usUOayXUpWHxv52GVQ6F.png" alt="img"></p><h3 id="1-对账业务流程"><a href="#1-对账业务流程" class="headerlink" title="1. 对账业务流程"></a><strong>1. 对账业务流程</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/09/GHpNSyK70kYyEysfdduW.png" alt="img"></p><p><strong>对账业务流程图</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/09/B7DFp6ZblWaCfNj9cYoL.png" alt="img"></p><h3 id="2-对账中心主要功能"><a href="#2-对账中心主要功能" class="headerlink" title="2. 对账中心主要功能"></a><strong>2. 对账中心主要功能</strong></h3><p><strong>银行发生资金变动的入账流水</strong>，包括：充值、提现、提现失败、充退、充退失败、退票、购汇、信贷放款、信贷还款、还贷失败一系列业务引起的账务变动信息。这些业务流水在账务系统入账后，<strong>会计核心接收到登记分录请求并处理完毕，发送该流水至对账中心</strong>，对账中心对于某个业务的反向资金变动所产生入账流水也同步至对账中心。</p><p>这样做的目的是让待清算与入账流水在日切点保持等额，比如：提现 T 日会员申请提现，生成文件后会员账户提现金额转入待清算提现款项，与此同时发送流水到对账中心，此时待清算与对账中心入账流水是保持平衡的。</p><p>而 T+1 日银行处理失败，系统会回充带清算提现款，如果此时不发送失败流水到对账中心与其对应的流水进行购销的话，则入账流水就会不变，和带清算提现不平衡。</p><p><img src="http://image.woshipm.com/wp-files/2018/09/BPXmMOHfEiqrn5vOG6vo.png" alt="img"></p><p><strong>Tips：</strong></p><ol><li><strong>完整的日结流程支持：</strong>银行清算流水入库 → 流水对账 → 流水分类 → 汇总确认单 → 自动挂账 → 销账确认 → 操作员轧账 → 总账日结以及登记银行余额等。</li><li><strong>完善的报表模型输出：</strong>如按入账日期 / 银行日期 / 清算日期等的统计报表、银行账户余额报表、未达款项报表等；</li><li><strong>提供日切服务：</strong>在经确认后进入历史清算流水的，同步汇总该部分数据进入历史流水汇总表中保存，所以在日切时，只需直接将该汇总数据再次汇总即可。</li><li><strong>外围业务功能支持：</strong>提供对于银行账户（ 独立于对账中心之外，不参与处理逻辑 ）的管理功能，支持与内部户的映射管理，用以满足部分报表需求；提供基于账务核心所提供的业务代码查询功能；提供对于财务系统的交互支持，包括与财务科目的对应关系管理、通知流水数据等；提供用以校验订单与清算流水匹配状态的错账核实功能。</li></ol><p><strong>对账流程图</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/09/wJPeksjanJWaqVweeBQc.png" alt="img"></p><h2 id="对账中心功能模块分析"><a href="#对账中心功能模块分析" class="headerlink" title="对账中心功能模块分析"></a><strong>对账中心功能模块分析</strong></h2><p><strong>获取资金对账数据：</strong></p><ul><li><strong>获取方式</strong>：需要进行清算流水导入的文件一般通过人工在页面上导入，另外有些业务的流水文件通过系统自动匹配或者定时获取的方式得到。</li><li><strong>清算流水导入渠道非常多</strong>：需要统一各清算流水导入功能到一个页面入口， 同时引入清算通道对账的逻辑，将清算流水导入过程需要映射清算通道（ 包含新增清算流水等 ）。</li><li>各类业务的清算流水文件的解析和导入逻辑不一样。</li></ul><p><strong>清算流水对账：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/09/wM4bDlm9KTMzPcmmYBgy.png" alt="img"></p><p><strong>对账逻辑：</strong></p><p><strong>一对一对账：</strong>入账流水只可能存在一条，银行入账流水也仅存在一条，然后一对一去对。目前按照一对一对账的业务涉及到：网银 B2C 充值、网银 B2B 充值、VISA、网汇E、卡通充值、正常提现、认证提现、银企互联提现、卡通提现、卖家信贷、信用卡还款提现、COD、网点支付。</p><p><strong>对账标准：</strong>清算通道 + 订单号 + 金额 Or 银行名称 + 业务代码 + 订单号 + 金额。</p><p><strong>满足一对一的业务如下：</strong></p><ul><li>提现成功：500401</li><li>认证提现：500402</li><li>还贷：500404</li><li>卡通提现：500403</li><li>个人网银充值：400301</li><li>企业网银充值：400302</li><li>VISA：400314</li><li>网汇e：400315</li><li>卡通充值：400304</li><li>贷款：400307</li><li>银企互联提现：500405</li><li>信用卡还款提现：500407</li><li>后台强制提现500406</li><li>COD</li><li>网点支付</li></ul><p><strong>Tips：</strong></p><ul><li>清算流水有，入账流水也有，金额一致，对账成功，清算流水、对账流水打上 ‘对账成功’ 标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水也有，金额不一致，清算流水记金额不等，记录对账日期为系统当日，入账流水不变；</li><li>清算流水有，入账流水该订单号没有，清算流水打上 ‘银行多帐’ 的标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水没有该业务代码初始状态的，清算流水打上 ‘银行多帐’ 的标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水没有该银行的初始状态的记录，清算流水打上 ‘银行多帐’ 的标志，记录对账日期为系统当日；</li><li>对账之前需要判断 1 对 1 的流水中是否有重复，有重复的返回失败不进行后续对账。</li></ul><p><strong>多对多对账：</strong>入账流水里相同订单号，相同清算渠道，相同，金额相同业务代码的流水存在对条（比如充退）；而银行清算流水也可能是存在多条的情况的，这种情况下是多对多去对账的，遵循先到的先对的原则。</p><p><strong>对账标准：</strong>清算通道 + 订单号 + 金额 Or 银行名称 + 业务代码 + 订单号 + 金额。</p><p><strong>满足多对多的业务如下：</strong></p><ul><li>充退：410401</li><li>银企互联充退：410402</li><li>Motopay 充退：410403</li></ul><p><strong>Tips：</strong></p><ul><li>清算流水有，入账流水有，满足对账标准，则对账成功，清算流水、对账流水打上 ‘对账成功’ 标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水有，金额不等，清算流水打上 ‘金额不等’ 的标志，记录对账日期为系统当日，入账流水不变；</li><li>清算流水有，入账流水没有该订单号，清算流水打上‘银行多帐’ 的标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水没有初始状态 410401 的流水，清算流水打上 ‘银行多帐’ 的标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水没有这个银行初始状态 410401 的流水，清算流水打上 ‘银行多帐’ 的标志，记录对账日期为系统当日；</li><li>清算流水有，入账流水没有初始状态的 ‘410401’ 的流水，清算流水打上 ‘银行多帐’ 的标志，记录对账日期为系统当日。</li></ul><p><strong>一对多对账：</strong>入账流水有多条，和银行的一条去对账。</p><p><strong>对账标准：</strong>清算通道 + 订单号 + 金额 Or 银行名称 + 业务代码 + 订单号 + 金额</p><p><strong>涉及的业务：境外收单</strong></p><ul><li>境外收单购汇扣款（520101）</li><li>购汇益回补购汇账户（400319）</li></ul><p><strong>Tips：</strong></p><ul><li>入账流水存在 2 条 520101 的，清算流水存在 1 条 520101 的，将入账流水的 2 条加和后的金额和清算流水的进行对账，一致的为对账成功；</li><li>入账流水存在 1 条 520101 的，1 条 400319 的，那么要将 2 条金额之差和清算流水的 1 条 520101 的进行对账。不会出现 3 条 520101 或者 2 条 400319 的情况。</li></ul><p><strong>内部流水购销 ：</strong>内部流水购销是针对那种有入账流水表来说的，比如提现业务，提现文件生成就会扣款此时会同步一笔入账流水；而回导失败之后又会回充，此时也会同步一笔反向的业务流水，这两条流水不用再去和银行的资金流水进行对账，直接在入账流水这边进行购销即可。</p><p>需要购销的业务如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/09/iRytMT6Qb0RmEBCZWWYu.png" alt="img"></p><ul><li>购销的规则：非已勾销状态下，同一银行同一订单号，金额一致而业务代码相反的正向流水进行勾销，而且一条反向流水只勾销一条；</li><li>日终轧账时候的购销：日终轧账的时候会对未购销的流水再次进行购销确保当天的流水都购销完全。（这个情况是为了解决反向流水先于正向流水先出现的逻辑错误情况而加的并提示流水号）；</li><li>如果业务代码相反，而金额不等的情况，就无法进行购销，这种情况原来是作为违反逻辑规则来进行标记的。这部分数据进行查明之后，可以修改流水之后，在日终轧账的时候从新进行购销；</li><li>购销分 ‘一对一’（提现）和 ‘多对多’ （充退）的购销；</li><li>勾销的流水不入历史库。</li></ul><p><strong>对账汇总确认单：</strong></p><p>显示对账结果，选择后续的相应的处理界面，复核员在此模块进行流水的确认，还有的功能就是对于已经对账处理的银行清算流水与系统入账流水进行后续业务分流推进。</p><ul><li>对于大部分对账成功的数据，可以将这些<strong>流水确认</strong>，确认后该部分流水将进入历史清算流水，只有进入历史清算流水的才认为银行与支付系统数据对平。对账成功的银行清算流水、账务入账流水全部进入各自历史清算流水表保存，相应的银行清算流水与入账流水同步删除。</li><li><strong>金额不等的流水</strong>，可能是银行清算流水文件有误，也可能是错账，采取的做法是操作员手工修改金额，在银行清算流水管理里操作或直接删除，将其推进到下一轮的对账处理环节，<strong>对账是可以重复对的</strong>，只要满足<strong>初始状态</strong>要求的流水即可。</li><li><strong>多账部分</strong>，由于各种已明确/未明确的原因，银行已经实际清算给支付公司了，但支付公司的账务系统并没有入账，需要提供一个<strong>流水分类和分类汇总挂账</strong>的操作入口。系统默认<strong>多账的流水给出的菜单是流水分类</strong>，金额不等的流水给出的流水管理页面。区别在于，在点流水分类时，只允许修改业务类型、银行日期，而且改完后不改变多账状态；流水管理，修改状态后，流水的对账状态将变成初始状态，需要进行重新对账。</li><li><strong>流水进入历史库的校验规则</strong>。</li></ul><p>举例说明：A 操作员导入了一笔流水，系统对账成功，银行清算流水与账务入账流水状态都被置为成功状态；B 操作员再次导入该相同流水，由于入账流水处于成功状态的可以继续对账，所以再次对账成功。系统在对账环节认为正常，但在入历史清算流水时必须做每组流水数据的平衡检查：必须是清算流水总额与入账流水总额匹配才可以进历史数据。</p><p>对于上述的场景，如复核员针对 B 操作员的对账成功流水确认后，可以正常进入历史流水，对账批次号认最后操作的批次。而继续对 A 操作员的成功对账流水确认，则系统将认为是不合法的入历史流水行为。或者不对特定操作员的汇总确认，系统必须检验出所存在的重复银行清算流水，并将对应的明细数据显示复核员。此时可将该重复对账的清算流水删除即可。</p><p><strong>流水分类和分类汇总挂账：</strong></p><ul><li>对于多账的流水对账中心提供一个单独的处理入口，首先在此处进行分类，然后进行汇总挂账处理。操作人员可以根据多账流水的未确认类型修改成对应的业务代码，允许修改成业务类型为 7 的可挂账的类型（其他业务代码不允许挂账）；流水可以重复分类，系统不做控制；但已申请挂账的除外，分类完毕的多账流水可直接提供分类汇总挂账操作。</li><li>系统根据既定的业务代码判断是待查收入或待查支出挂账，页面跳转至相关凭证登记页面，此处业务规则同待查收支挂账；另一部分比如退票，因为不经过对账环节，所以需要直接在清算流水查询里面新增，业务代码 700106 未确认退票，不需要经过对账，直接去汇总确认单里将流水挂账。允许挂账的业务代码如下 ：700101 其他应付款，700102 其他应收款，700103 银行错账，700104 未确认结汇款，700105 线下汇款，700106 未确认退票，700107 未确认收款，700108 未确认支出款。</li><li>提交凭证登记申请相关校验：流水此刻状态是否是 ‘多帐’ ，申请提交人是否是当时的对账人，凭证登记成功，清算流水记录凭证号，流水状态改为 ‘已挂账’ ；</li><li>汇总挂账的反交易同步入账流水，金额是负值，系统在清算流水里在做一条数据，自动对账。</li></ul><p><strong>清算/入账/历史流水管理：</strong></p><p>清算流水管理</p><p>对于所有的清算流水，都可以在此模块下进行查询、修改、删除，同时也可以新增流水。</p><ul><li><strong>查询功能</strong>，银行名称、业务代码、银行日期不能为空，业务代码和银行可以多选。</li><li><strong>修改功能</strong>，处于未对账（初始）、金额不等、多账、对账成功状态的流水可以进行单笔、批量修改操作，这里的批量修改动作与流水分类功能类似，只是该功能入口不仅支持对批量流水的业务代码、银行日期更新，也支持其他要素信息批量修改，作为提供给操作员在未对账前批量修改已知流水的手段之一；对已挂账的流水，不允许更新。</li><li><strong>流水删除</strong>：处于未对账（初始）、金额不等、多账、对账成功状态的流水可以进行单笔、批量删除操作，已挂账状态不允许删除。</li></ul><p>入账流水管理</p><p>入账流水管理功能提供对账务入账流水的查询以及下载功能；为了杜绝对入账流水的人为变更操作，<strong>禁止支持对入账流水进行修改或删除处理。</strong></p><ul><li>查询时银行名称、业务代码、入账日期不能为空，业务系统流水号：针对某类业务的业务流水号，如充值业务就是充值流水号；账务流水号：账务处理的流水号，即账务操作记录数据的序号，在账户明细查询里可以获取。</li><li>对于提现类失败回充的流水，在操作员进行对账动作后，系统自动进行购销，在入账流水查询时，将对账状态选为已购销可以查到，这些不进入历史库，根据数据量，系统定时清理这些数据。</li></ul><p>历史流水管理</p><p>分为历史入账流水和历史清算流水，查询功能在同一页面，查询时可以一起查询，也可以单独查询。历史流水只供查询和下载，不允许进行修改和删除操作。选择历史银行流水和历史清算流水（清算日期的时间间隔不能超过 7 天）进行查询，历史入账流水中无银行日期，历史银行流水中无入账日期。</p><p><strong>银行余额录入功能：</strong></p><p>在该模块下，实现对每个银行账户的实际余额录入，以此来和内部账户余额进行匹配校验。分为银行余额登记，银行余额导入（复核），以及银行余额查询功能。</p><p><strong>银行余额登记</strong>：选择对应日期以及银行账户录入后，保存，此时去银行余额查询是看不到录入余额的，需要复核导入核对完毕后才能看到，保证核对的有效性。登记后系统记录一个临时余额。系统每天凌晨 1:15 的时候会跑批，取上一日已复核过的余额自动带入下日临时余额，如果不登记的话，就取上日余额。</p><p><strong>银行余额导入</strong>：标准格式是一个填写银行余额的 excle 模板，导入后的核对逻辑，对复核员导入的数据进行检测该帐户是否有临时余额。根据银行账号、银行日期、银行余额等条件查询银行余额表。</p><p>判断 1 ：如果查询出结果为空那么将返回给用户：“这个银行帐号找不到对应的银行临时余额！”。</p><p>判断 2 ：如果查询结果大余一条，将返回给用户：“这个银行帐号的一天有多个银行临时余额，不正常！”</p><p>判断 3 ：检测该银行帐号对应的银行余额是否相等。如果不相等将返回给用户：“临时余额和实际余额不相等，核对失败！”当余额核对成功后，将复核员导入的余额写入该对应帐户的实际余额，并修改余额状态为已复核。实际余额更新成功后，将删除当天日期的临时余额。</p><p><strong>银行余额查询</strong>：对操作员登记余额的信息，以及复核员复核过的余额进行查询，查询条件：银行名称、银行帐户、帐户状态、银行日期、余额状态。帐户状态：分为正常、废除、和销户三个状态，默认为正常状态。余额状态：分为未录入（N）、已录入（A）、已复核（Y）三个状态，默认为全部。</p><p><strong>内部账户登账：</strong></p><p>业务简述</p><p>针对日常结算工作中非银行待查类的内部账户进行登记，如：清算款、利息、手续费等；该业务登记不产生后续业务登记行为，即不具有作为初始凭证号的使用功能。对于批量销帐类业务处理中，多会员转帐失败的，导致过渡户上有剩余金额情况的，可通过此处进行内部户登账，将过渡户（负债）和银存（资产）余额同时减少，再通过待查收入挂帐实现平衡。</p><p>业务校验规则</p><ol><li>必须登记的是一借一贷帐户信息；</li><li>借贷方帐户不能一致；</li><li>金额必须大于 0 ；</li><li>不允许任意一方是销帐帐户。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/09/aXlZKiDaMgEUROop0EIx.png" alt="img"></p><p>是否同步对帐中心流水：不需要同步对帐中心流水。</p><p><strong>待查收入挂账：</strong></p><p>业务简述</p><p>应用于结算操作员针对日常结算工作中的银行待查收入进行登记，所产生的业务凭证号作为后续销帐业务的原业务凭证号，并且作为所有该登记所引发的后续业务登记的初始凭证号。其中待查收入挂帐业务凭证的借方（银存帐户）所对应的银行名称作为后续销帐业务的银行名称，包括差额重新挂帐部分再销帐的业务凭证，都递沿该银行名称。</p><p>业务校验规则：</p><ol><li>必须登记的是一借一贷帐户信息；</li><li>借贷方帐户不能一致；</li><li>金额必须大于 0 ；</li><li>借方帐户必须是银存帐户；</li><li>贷方帐户必须是销帐帐户。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/09/hB0PYQYMOt2fg47b5tfL.png" alt="img"></p><p>是否同步对帐中心流水：不需要同步对帐中心流水。</p><p><strong>待查收入确认：</strong></p><p>业务简述</p><p>针对银行待查收入登账的挂帐，可以通过本模块进行销帐。此处采取销帐确认方式进行处理，需要选择相应的待查收入挂帐业务凭证进行销帐业务登记。该业务登记可能产生后续业务登记行为，如差额销帐情况下，系统会自动做不足额部分的重新挂帐并复核通过，所产生的挂帐凭证作为后续销帐凭证的销帐卡片号。</p><p>业务校验规则：</p><ol><li>所销的原待查收入挂帐凭证必须合法；</li><li>所销的原待查收入挂帐凭证必须已复核通过，处理完毕；</li><li>所销的原待查收入挂帐凭证不能已被销帐；</li><li>销帐总额(贷方发生额之和不得大于原待查收入挂帐凭证发生额)并大于 0 ；</li><li>贷方必须是内部户。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/09/g82BZgKowVIs8xjpwI9H.png" alt="img"></p><p><strong>待查支出挂账：</strong></p><p>业务简述：</p><p>针对日常结算工作中的银行待查支出进行登记，所产生的业务凭证号作为后续销帐业务的原业务凭证号，并且作为所有该登记所引发的后续业务登记的初始凭证号。其中待查收入挂帐业务凭证的贷方（ 银存帐户）所对应的银行名称作为后续销帐业务的银行名称，包括差额重新挂帐部分再销帐的业务凭证，都递沿该银行名称。</p><p>业务校验规则：</p><ol><li>必须登记的是一借一贷帐户信息；</li><li>借贷方帐户不能一致；</li><li>金额必须大于 0 ；</li><li>贷方帐户必须是银存帐户；</li><li>借方帐户必须是销帐帐户 。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/09/kB5gh29lj96EDSMoxDeA.png" alt="img"></p><p>是否同步对帐中心流水：不需要同步对帐中心流水。</p><p><strong>待查支出确认：</strong></p><p>业务简述</p><p>针对银行待查支出登账的挂帐，可以通过本模块进行销帐。此处采取销帐确认方式进行处理，需要选择相应的待查支出挂帐业务凭证进行销帐业务登记。该业务登记可能产生后续业务登记行为，如差额销帐情况下系统会自动做不足额部分的重新挂帐并复核通过，所产生的挂帐凭证作为后续销帐凭证的销帐卡片号。</p><p><strong>业务校验规则：</strong></p><ol><li>所销的原待查支出挂帐凭证必须合法；</li><li>所销的原待查支出挂帐凭证必须已复核通过，处理完毕；</li><li>所销的原待查支出挂帐凭证不能已被销帐；</li><li>销帐总额(借方发生额之和不得大于原待查收入挂帐凭证发生额)并大于0 ；</li><li>借方必须是内部户。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/09/xfaKI06Q9J1bXyKAfsPv.png" alt="img"></p><h2 id="意外数据恢复逻辑"><a href="#意外数据恢复逻辑" class="headerlink" title="意外数据恢复逻辑"></a><strong>意外数据恢复逻辑</strong></h2><h3 id="1-意外数据恢复逻辑"><a href="#1-意外数据恢复逻辑" class="headerlink" title="1. 意外数据恢复逻辑"></a><strong>1. 意外数据恢复逻辑</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/09/cUkSXrQFLEh4ceTWcpxP.jpg" alt="img"></p><p><strong>重复支付：</strong>对同一内部订单号进行了二次或二次以上的支付。</p><p><strong>支付失败，金额不等：</strong>买家实际支付的金额与交易金额不等。一般产生的原因是，买家在支付时，产生了掉单，卖家随后修改了交易价格。 在进行网银对账的时候，即会出现订单金额和交易金额不等的情况，且是一笔掉单。<strong>2、3 两类情况只发生在支付上。</strong></p><p><strong>支付成功，金额不等（这一类异常，偶尔有发生）：</strong>商户订单状态为成功，后台订单状态也为成功，并且交易状态是买家已付款，等待卖家发货。</p><p>（金额不等，支付成功，是因为会员对一个交易进行支付，但由于网络或银行系统等原因支付公司未接收到银行扣款信息，支付侧交易状态未予以变更，后卖家对该交易修改了价格，买家又对该修改过的价格进行了支付。但该支付成功的信息仍然没有被支付侧接收到，该交易状态仍未变更，后支付侧后台人员先对后面的那笔意外数据进行了恢复，后再对前面那笔意外数据恢复，就会出现这种“金额不等，支付成功”的数据）</p><p><img src="http://image.woshipm.com/wp-files/2018/09/gzkeBBdYeluRXrnGIFKI.jpg" alt="img"></p><h3 id="2-对帐及异常恢复逻辑"><a href="#2-对帐及异常恢复逻辑" class="headerlink" title="2. 对帐及异常恢复逻辑"></a>2. 对帐及异常恢复逻辑</h3><p><strong>以商户成功订单为准：</strong></p><p>用商户上的成功订单与后台的订单来核对：</p><ul><li>若商户订单为成功，后台为初始或者失败，则更改后台状态为成功；</li><li>若后台为成功，商户成功订单中无该订单（时间差），则不更改后台状态；</li><li>若后台为初始或失败，商户成功订单中无该订单，则不更改后台状态。</li></ul><p><strong>不重复恢复：</strong></p><p>T+1 日恢复T 日的订单，并且在 T+1 日后不再下载 T 日的订单进行二次或多次恢复。（为考虑会员感受，T 日下班前恢复 T 日 0 点到下班时点的订单）</p><p><strong>时间性差异：</strong></p><p>由于各家银行系统日切点均不同，并且大多不会在每日的 24 点（或早或晚），所以下载到的 T 日的订单流水与后台T日（ 0:00－24:00 ）的订单流水并不能全部对应上。将商户订单流水与后台订单流水核对，会出现商户有，后台无；商户无，后台有；商户有，后台有三种情况。对于 1、2 两种情况为我们所说的时间性差异。</p><p><strong>商户数据与后台数据的关系为：</strong></p><p><strong>商户数据－（商户有，后台无）＋（商户无，后台有）＝ 后台数据</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/09/lglT4mXyl5vSsuQ8UIjD.png" alt="img"></p><h2 id="全面解构支付系统设计——你不可不知的会计核心"><a href="#全面解构支付系统设计——你不可不知的会计核心" class="headerlink" title="全面解构支付系统设计——你不可不知的会计核心"></a>全面解构支付系统设计——你不可不知的会计核心</h2><h2 id="一、复式记账"><a href="#一、复式记账" class="headerlink" title="一、复式记账"></a>一、复式记账</h2><p>第一个问题：如何理解账务系统单边记账，会计系统复式记账？</p><p>有些公司内部账户之间转账都采用复式记账法，如充值、提现交易，他们在<strong>账务系统都记单边流水</strong>，等和银行对账后，在<strong>会计系统复式记账</strong>。</p><h3 id="1-以充值为例"><a href="#1-以充值为例" class="headerlink" title="1. 以充值为例"></a>1. 以充值为例</h3><p>用户充值：秋秋支付宝充值100 元，那么在账务系统里面单边记账，主要就是如下的流水信息：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/KITeJFAamaLgBuvUwL7H.png" alt="img"></p><p>若有N 多条充值的流水，在账务系统中会记录客户分户N 多条账务流水，并实时更新<strong>外部分户</strong>的流水和分户余额。</p><p>同时发送该充值业务数据到会计核心，会计核心根据账务系统提供的会计科目做一条客户帐分户的贷方分录，日终汇总分别借记一条工商银行待清算款充值账户的分录，同时更新相应科目下的<strong>内部分户</strong>余额，在会计系统中会对应的生成会计分录流水：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/XF7CUXZ37O48DpHe5JRs.png" alt="img"></p><p>银行对账后 ，对账结果触发会计系统会计分录：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/Nyrybq2EOY9qOzNHOsig.png" alt="img"></p><h2 id="二、会计基础入门"><a href="#二、会计基础入门" class="headerlink" title="二、会计基础入门"></a>二、会计基础入门</h2><p><strong>第二个问题：如何理解会计中的“借”和“贷”？</strong></p><p>首先明确一个公式：资产= 负债+ 所有者权益</p><p><img src="http://image.woshipm.com/wp-files/2018/11/CrHhdkSf11NBMa41O8x8.png" alt="img"></p><p>规律：</p><ul><li>当秋秋收到现金时，都是<strong>借：我的现金</strong> <strong>贷：其他科目</strong>；说明我的现金时借方表示增加。</li><li>当秋秋借别人钱时，负债增加了，<strong>借：其他科目 贷：我的负债</strong>（属于别人的钱），说明我的负债是贷方表示增加。</li><li>当秋秋辛苦攒下的积蓄，所有者权益增加了，<strong>借：其他科目 贷：属于我的财产</strong>，说明属于我的财产是贷方表示增加。</li></ul><p><img src="http://image.woshipm.com/wp-files/2018/11/MgPZGeBI11FxicNjKHEG.png" alt="img"></p><h2 id="三、会计科目和账户"><a href="#三、会计科目和账户" class="headerlink" title="三、会计科目和账户"></a>三、会计科目和账户</h2><p><img src="http://image.woshipm.com/wp-files/2018/11/QLCg8qraOxFE03MY1qYX.png" alt="img"></p><h3 id="1-会计科目"><a href="#1-会计科目" class="headerlink" title="1. 会计科目"></a>1. 会计科目</h3><ul><li>会计科目按其反映经济内容的不同一般分为<strong>资产类、负债类、所有者权益类、收入类、费用类、利润类</strong>六大类科目。由于支付机构主要核算客户资金和备付金资金账户，没有直接采用所有者权益类、收入类、费用类和利润类科目，仅仅设置资产类、负债类、共同类（待清算），严格遵循会计恒等式。</li><li>资产类科目余额方向一般在借方，负债类科目的余额一般在贷方，共同类既具有资产也具有负责属性，属于双重科目。</li></ul><h3 id="2-科目层级"><a href="#2-科目层级" class="headerlink" title="2. 科目层级"></a>2. 科目层级</h3><p>为了既能够提供总额核算，又能提供明细核算，会计科目一般更具具体需求设置层级。</p><p>按照提供指标的详细程度不同，可以分为总分类科目、明细类科目。<strong>总分类科目</strong>就是我们说的<strong>总账科目</strong>或者叫一级科目，是总体反映会计要素具体内容的科目。</p><p><strong>明细分类科目</strong>，也就是明细科目，是对总分科目所含内容做详细分类形成的会计科目。</p><p>明细科目根据会计核算和经营管理需要还可设置二级、三级科目。没有下级科目的会计科目为叶子科目，即底层科目，底层科目下按照实际账务处理设置会计账户，会计账户与资金账户一一对应。<strong>只有叶子科目下才能开立账户，非叶子科目下不可以开立账户。</strong></p><h3 id="3-科目和账户的关系"><a href="#3-科目和账户的关系" class="headerlink" title="3. 科目和账户的关系"></a>3. 科目和账户的关系</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/JnnNR89pCSCxDk807Ijt.png" alt="img"></p><ul><li>资产类科目记在借方表示增加，记在贷方表示减少；</li><li>负债类科目记在借方表示减少，记在借方表示增加；</li><li>所有者权益记在借方表示减少，记在贷方表示减少；</li><li>费用类科目记在借方表示增加，记在贷方表示减少；</li><li>利润类科目记在借方表示增加，记在贷方表示增加。</li></ul><h3 id="4-交易流程与资金平衡"><a href="#4-交易流程与资金平衡" class="headerlink" title="4. 交易流程与资金平衡"></a>4. 交易流程与资金平衡</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/FupQPU2EIyXwcoWeqZa2.png" alt="img"></p><h3 id="5-内部户和科目的关系"><a href="#5-内部户和科目的关系" class="headerlink" title="5. 内部户和科目的关系"></a>5. 内部户和科目的关系</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/fIrDq3Cj0vIWKZz712br.png" alt="img"></p><h3 id="6-会计科目平衡关系"><a href="#6-会计科目平衡关系" class="headerlink" title="6. 会计科目平衡关系"></a>6. 会计科目平衡关系</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/QvU1KYG6igulPsdazE1M.png" alt="img"></p><ul><li>在一级科目110银行存款下，针对不同银行可以设置多个二级科目：11001 A银行存款科目，11002 B银行存款科目；</li><li>在每一个银行存款二级科目下，根据收付业务目的的不同，又可以设置多个三级科目：1100101 A银行存款_收款专用科目，1100102 A银行存款_付款专用科目，1100103 A银行存款_归集专用科目。</li></ul><h3 id="7-每个类目的科目平衡关系"><a href="#7-每个类目的科目平衡关系" class="headerlink" title="7. 每个类目的科目平衡关系"></a>7. 每个类目的科目平衡关系</h3><ul><li>叶子科目余额= 该科目下所有账户余额综合；如：1100201 科目余额= 1100201科目下所有账户的余额总和。</li><li>科目汇总余额= 该科目下所有叶子科目余额总和；如：110 一级科目余额= 110 一级科目下所有叶子科目的余额总和。</li><li>总账余额= 该科目下所有同级科目汇总余额总和；如：资产类总账= 资产类所有科目的余额总和。</li></ul><p><strong>201 和 202 科目属于客户账科目，其余科目均属于内部账科目，即 201 和 202 科目下的账户属于客户账，其余科目下的账户属于内部账。</strong></p><h2 id="四、会计资金平衡关系"><a href="#四、会计资金平衡关系" class="headerlink" title="四、会计资金平衡关系"></a>四、会计资金平衡关系</h2><p>采用复式记账法，保证会计核算资金的平衡关系，复式记账法是指对发生的每一项经济业务，都以相等的金额，在相互联系的两个或者两个以上账户中间同时进行登记的方法。</p><p>公式①：<strong>资产 （借方余额）= 负债（贷方余额）+ 待清算（借方余额）</strong></p><p>公式②：原始平衡关系：资产 （0）= 负债（0）+ 待清算（0）</p><p><img src="http://image.woshipm.com/wp-files/2018/11/XEzOlTgQh9A0JrZiCcxI.png" alt="img"></p><p>支付机构的资金管理体系是在银行资金管理体系基础上建立了，为了能清晰的理清资金的流入与流出关系，保证收支两条线；支付机构一般会在每家合作银行分别开设收款专用户和付款专用户。</p><p>其中收款专户是专门用来归集充值流入的资金，付款专户专门用来归集提现流出的资金。</p><h3 id="1-充值业务资金流动机制"><a href="#1-充值业务资金流动机制" class="headerlink" title="1. 充值业务资金流动机制"></a>1. 充值业务资金流动机制</h3><p>当充值业务发生时，银行直接从客户的银行账户进行扣款，但是并不会立即向支付机构的银行账户入账，而是先挂入银行内部过渡账户，在日终处理时统一讲当日累计充值资金一次性向支付机构收款专业银行账户入账。</p><h3 id="2-提现业务资金流动机制"><a href="#2-提现业务资金流动机制" class="headerlink" title="2. 提现业务资金流动机制"></a>2. 提现业务资金流动机制</h3><p>当提现业务发生时，支付机构并不是立即通知银行扣款，而是在每日定时将一段时间内同一家银行申请提现的请求汇总提交给银行，由银行负责从支付机构付款专用银行账户进行扣款，向客户的银行账户入账。</p><h3 id="3-资金调度机制"><a href="#3-资金调度机制" class="headerlink" title="3. 资金调度机制"></a>3. 资金调度机制</h3><p>为了保证每家银行的收款专户资金得到统一的调度支配，同时满足每家银行付款专户的资金需求，支付机构会指定唯一的一家合作银行开设统一归集账户，每日将各家银行收款专户内充值业务资金汇总归集到这个唯一的归集账户内，并根据各家银行付款专户提现业务需要支付的资金，从归集账户向各家银行付款专户划转调拨资金，确保提现支付成功。</p><p>支付机构在银行的资金管理体系的基础上，从自身的资金管理需求出发，搭建了自己的资金调度体系，其资金流基本和银行类似，典型的资金体系如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/XkmqVuJVx5VfgCHYsoJW.png" alt="img"></p><p>由于支付机构内部待清算充值款项是当晚核心系统日终后才能结转到银存收款账户后，才能进行调拨，而每日下午在产生给银行的提现数据时，就需要保证银存付款专户上的资金到位，这样资金调拨就会存在时间差，为了解决这个时间差问题，于是内部设置了一个调拨户进行资金中转。</p><p>调拨专户是一个虚拟的账户，不是与真实资金账户对应的账户，余额方向可以是借方或贷方。每日在向银行提交提现数据前，先内部从银行收款账户进行调拨，如果由于时间差原因收款账户资金余额不足，则直接从调拨专户上调拨资金到收款账户，再从收款账户向付款账户调拨。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/XxNSKyVpuGQ3Z91D9nFP.png" alt="img"></p><p><strong>资金调拨专户上的缺口部分需要在日终结转时予以轧差抹平，即现将待清算充值资金结转到调拨户，再从调拨户结转到银行存款收款账户。</strong></p><h2 id="五、会计驱动的入账机制"><a href="#五、会计驱动的入账机制" class="headerlink" title="五、会计驱动的入账机制"></a>五、会计驱动的入账机制</h2><p>账务系统作为会计系统的前置，一般的业务请求都是由账务系统先完成记账再向会计系统发送请求进行会计记账。</p><p>但是有两项特殊业务是会计系统独立处理，并是由会计系统向账务系统发起请求进行最终账务记账处理的，这就是涉及银行资金结算的<strong>充值、提现业务</strong>的待清算账户单边归总记账和日终的会计结转记账。</p><h3 id="1-充值业务在会计系统中单边汇总的流程"><a href="#1-充值业务在会计系统中单边汇总的流程" class="headerlink" title="1. 充值业务在会计系统中单边汇总的流程"></a>1. 充值业务在会计系统中单边汇总的流程</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/PcPqIvVQYaGty95p8XGp.png" alt="img"></p><h3 id="2-提现业务在会计系统中单边汇总的流程"><a href="#2-提现业务在会计系统中单边汇总的流程" class="headerlink" title="2. 提现业务在会计系统中单边汇总的流程"></a>2. 提现业务在会计系统中单边汇总的流程</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/xRnjEhDNziZJo4shLCbe.png" alt="img"></p><h2 id="六、会计日终处理"><a href="#六、会计日终处理" class="headerlink" title="六、会计日终处理"></a>六、会计日终处理</h2><p><img src="http://image.woshipm.com/wp-files/2018/11/txNiTGpNqWjoVrpkl1IO.png" alt="img"></p><h3 id="1-日终前的账务准备阶段"><a href="#1-日终前的账务准备阶段" class="headerlink" title="1. 日终前的账务准备阶段"></a>1. 日终前的账务准备阶段</h3><p>向对账中心通知会计日终处理开始。</p><p>针对充值业务和提现业务员的日间单边记账进行汇总，完成待清算款项的汇总单边记账。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/eZXdqSQmHfLutdqL1OFL.png" alt="img"></p><p>通知对账中心日终对账，并获取对账中心返回的银行对账结果数据。</p><p>根据各家银行充值业务的对账结果数据，汇总结转各银行待清算充值资金到各银行存款账户（若有资金调拨，则结转到资金调拨账户）。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/TcmJPHNZQ9ji4ElykQM9.png" alt="img"></p><p>对于有资金调拨的银行，根据充值业务的对账结果数据，汇总结转各家银行资金调拨资金到各银行存款账户。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/yjxrFQSq4RDEdc4Okc6S.png" alt="img"></p><p>根据提现业务的对账结果数据，汇总结转各银行待清算提现资金到各银行存款账户。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/poqfr0vH4de5f4JvIDIb.png" alt="img"></p><p>因为资金调拨专户需要在日终时归零，所以对于差额部分需要轧差记账，即结转各家银行资金调拨余额到各家银行存款账户。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/NUXabmRan5S50W9cfebd.png" alt="img"></p><h3 id="2-日终的轧差与汇总处理阶段"><a href="#2-日终的轧差与汇总处理阶段" class="headerlink" title="2. 日终的轧差与汇总处理阶段"></a>2. 日终的轧差与汇总处理阶段</h3><p>检查所有账户当日会计发生额是是否借贷相等，即借方发生额=贷方发生额，若不相等，则自动登记轧差金额的会计分录，保证借贷发生额平衡，对于导致借贷发生额不平的原因事后查询解决。</p><p>对账户的会计分录按借贷进行汇总，同时根据各账户上日余额和当日的发生额计算得到每个账户当日余额。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/8rBGRkNMefBdlLRB9MuH.png" alt="img"></p><p>按照科目对科目账户的会计分录进行汇总得到科目当日发生额，同时根据各科目上日余额和当日的发生额计算得到当日科目余额。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/YGgbWF1djHkpiy4Lct9J.png" alt="img"></p><h3 id="3-日终的平衡检查和日切阶段"><a href="#3-日终的平衡检查和日切阶段" class="headerlink" title="3. 日终的平衡检查和日切阶段"></a>3. 日终的平衡检查和日切阶段</h3><ol><li>平衡检查主要保证借方科目余额等于贷方科目余额；</li><li>科目总分检查保证下级科目余额总和等于对应的上级科目余额；</li><li>会计日余额表日切主要保证每日的账户余额数据得到保存；</li><li>更新会计日，保证下次日终处理的是下一个会计日。</li></ol><h2 id="七、会计结算业务参数的配置与管理"><a href="#七、会计结算业务参数的配置与管理" class="headerlink" title="七、会计结算业务参数的配置与管理"></a>七、会计结算业务参数的配置与管理</h2><p>会计系统作为核心重点负责清算、结算会计平衡的系统，在每增加一家银行时，都需要配置相关的会计结算关系。</p><p>会计系统的日间记帐处理包含两种模式：即时模式和缓冲模式，具体采用何种模式由账务系统触发时决定。</p><p><strong>即时模式</strong>需要会计系统严格按照账务系统发送的指令进行会计记帐处理；</p><p><strong>缓冲模式</strong>需要会计系统根据相关的参数配置进行会计记帐处理，<strong>一般日间都是单边的会计记账处理</strong>，如充值与提现业务。</p><p>日间会计系统根据参数配置仅记录客户帐的变化部分，不记录内部账的变化部分，内部账的变化部分在日终时根据相关参数和日间的单边账务记录，进行分类汇总后再分别记帐处理。</p><h3 id="1-会计业务相关参数包括以下部分内容"><a href="#1-会计业务相关参数包括以下部分内容" class="headerlink" title="1. 会计业务相关参数包括以下部分内容"></a>1. 会计业务相关参数包括以下部分内容</h3><p><strong>针对日间所有的充值类交易代码</strong>（含充值 4003、充值补账 4023 ）、提现类交易代码（含提现 5004 、提现补账 4022 、充退 4104 ）操作，其下每一个子交易码 sub_trans_code 对应的每一个涉及该业务的 title_code 科目代码都需要配置一条对应的参数记录，来确定日间该科目下的该交易代码进行怎样的单边会计记帐处理。</p><p>参数重点说明该科目该交易记帐的方向、是否需要汇总记帐、是否需要发送对帐中心处理、是否需要 cache ；如 400301 交易代码，业务涉及 20100 1个人账户科目和 2002001 公司账户科目，则需要对应的两条参数记录；具体配置如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/UP6JhPpadYrzD5NLCfcU.png" alt="img"></p><p>日终批量处理时，有一步是专门针对缓冲记账的处理，会计系统会根据参数表中充值、提现相关的每一个子交易码 sub_trans_code 对应的银行代码 bank_type 不同，分类统计日间的单边会计记账数据，按照汇总后的数据会计系统单边记账处理；完成缓冲记账的剩余部分。</p><p>如 400301 交易代码，日终时按照参数表中的银行代码分别统计日间 400301 交易的单边会计记录，产生另一边的待清算户的会计记帐记录。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/lBYRxyvsaeM9WxyH71fG.png" alt="img"></p><p>日终批量处理时，有一步是专门针对银行存款结转的，即将经过对帐的资金从待清算账户结转到银行存款账户，以保持与银行真实资金变化的一致。</p><p>会计系统会根据与银行的对账结果数据进行结转记账处理，参数表中记录了每家银行从待清算户到银行存款户进行结转的具体记账参数中充值；因为存在两种结算方式，所以存在两套记账参数：</p><ol><li>从待结算资金户结转到银行存款户的会计记帐参数；</li><li>从待结算资金户结转到资金调拨户的会计记帐参数；</li><li>从资金调拨户结转到银行存款户的会计记帐参数。</li></ol><p>当前的业务规则表包括字段如下：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/7EiQQFXlmmXYhofRozqo.png" alt="img"></p><p>会计业务规则在整个会计核心中起着非常重要的作用。会计核心的几个重要功能（记录分录，发送对账中心数据，汇总记账，日切结转）中，都有他的用处。目前来讲，会计规则主要有三个地方应用：</p><ol><li>日间生成分录：这部分规则叫做会计分录规则。</li><li>日切汇总记账：这部分规则叫做会计汇总规则。</li><li>日切资金结转：这部分规则叫做会计结转规则。</li></ol><p>会计汇总规则和会计结转规则同属于会计流转规则。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/2ZKA4jLcV7IdBCpdqQeA.png" alt="img"></p><h3 id="2-日间生成分录"><a href="#2-日间生成分录" class="headerlink" title="2. 日间生成分录"></a>2. 日间生成分录</h3><p>在日间过程中，会计核心主要负责把账务请求转化成分录要素并记录下来，同时根据需要发送给对账中心。在这过程中, 会计分录规则起如下作用(左边是账务请求已知信息，右边是通过会计分录规则得到的信息)：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/hXrgegRN8aqnwmN4kuyQ.png" alt="img"></p><p>通过会计分录规则的转化，就可以知道是否要进行汇总记账，从而决定<strong>是记单边分录</strong>还是也要记录<strong>待清算方科目的分录</strong>。可以知道会计要素中的银行是从账务请求的哪个字段取。</p><p>也可以知道是否要发送给对账中心，有了规则得到的这些信息，再加上能从账务请求直接拿来的会计要素（如：账户，科目，金额，会计日，借贷方向），就可以生成分录，并发送给对账中心。</p><p>从能够目前的会计业务规则表中的数据来看，这部分规则的使用如下：其中蓝色部分作为请求部分，黄色部分作为会计业务规则的产出部分。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/TFHLnEngXYoyhTAlDZE5.png" alt="img"></p><h3 id="3-日切汇总记账"><a href="#3-日切汇总记账" class="headerlink" title="3. 日切汇总记账"></a>3. 日切汇总记账</h3><p>在日切过程中，需要把充值、提现等业务的多方分录进行汇总，得到一方分录，并记录下来。会计汇总规则在由多方分录转化成一方分录时，起如下用途：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/Z6UOj9Q0Op9P0mWKhDVC.png" alt="img"></p><p>通过会计汇总规则的转化，得到一方分录的账户，科目和借贷方向要素，再加上其他一些会计要素（SubTransCode，会计日等），就可以生成一方分录了。</p><p>从目前的会计业务规则表中的数据来看，这部分规则的使用如下：</p><p>其中蓝色部分作为请求部分，黄色部分作为会计业务规则的产出部分。</p><p><img src="http://image.woshipm.com/wp-files/2018/11/2UjE5PDTN6eEoYOzp3xv.png" alt="img"></p><h3 id="4-日切资金结转"><a href="#4-日切资金结转" class="headerlink" title="4. 日切资金结转"></a>4. 日切资金结转</h3><p>在日切结转过程中，需要把已清算款或调拨户结转成银行存款。这些结转所使用规则叫做会计结转规则。日切资金结转有两种情况：</p><p><strong>（1）待清算结转</strong></p><p>对账中心对账完毕之后,在日切过程中,需要把待清算数据结转成银存或调拨户，所以需要建立一套会计结转业务规则,来约束如何从待清算结转到银行或调拨户。</p><p>在结转过程中,他是依赖会计结转规则的如下参数来查找规则：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/NchBiqFSVCm4rTxRVNuC.png" alt="img"></p><p>根据已清算汇总数据（ pac_gather_daily ）得到的SubTransCode，TitleCode，Remark（＝SubTransCode ），从会计结转规则中得到两条规则，<strong>一条是存放待清算方分录规则</strong>，<strong>一条是存银存方（或调拨方）分录规则</strong>。我们根据这两条规则，然后在根据其他分录要素（ SubTransCode , 会计日等），就可以生成两条分录。</p><p>同时要说明得是：这种情况的结转规则，都是成套的。</p><p>成套的含义是指用相同的 SubTransCode，BankType，Remark 取查找会计规则，如果能找得到，就是两条，这两条是成套的。</p><p>就目前的会计业务规则表中的数据来看，他的用途如下：（其中蓝色部分作为请求部分，黄色部分作为会计业务规则的产出部分。绿色部分是给调拨结转用的）</p><p><img src="http://image.woshipm.com/wp-files/2018/11/F57HZQpFskmefRJVP6N0.png" alt="img"></p><p><strong>（2）调拨结转</strong></p><p>调拨结转是日切过程中,把调拨户的钱结转到银存账户上，会计也需要配置这些结转规则来结转：</p><p><img src="http://image.woshipm.com/wp-files/2018/11/HGHFzhkHRLNAeiXi6Buj.png" alt="img"></p><p>把 SubTransCode 和 Remark 都是结转子交易类型（ 701105 ）的规则查找出来。对应如果有Memo 值，则表示结转规则，同时 Memo 保存得是银存方的科目代码，根据科目代码找到银存方的规则。从而获得银存方分录需要需要的 titleCode ,  iwAccountNo ,  借贷方向。</p><h2 id="八、案例分析"><a href="#八、案例分析" class="headerlink" title="八、案例分析"></a>八、案例分析</h2><p><img src="http://image.woshipm.com/wp-files/2018/11/Uy71Iupv6XBEbyG5gGdr.png" alt="img"></p><h3 id="1-打款业务流程图"><a href="#1-打款业务流程图" class="headerlink" title="1. 打款业务流程图"></a>1. 打款业务流程图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/4GhM1gAfAs6eUcvebCJk.png" alt="img"></p><h3 id="2-支付交易时序图"><a href="#2-支付交易时序图" class="headerlink" title="2. 支付交易时序图"></a>2. 支付交易时序图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/5USLALdDedJbNYQjwgai.png" alt="img"></p><h3 id="3-打款信息流程图"><a href="#3-打款信息流程图" class="headerlink" title="3. 打款信息流程图"></a>3. 打款信息流程图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/LuxYIzEfHyS966DTyRyz.png" alt="img"></p><h3 id="4-打款资金流程图"><a href="#4-打款资金流程图" class="headerlink" title="4. 打款资金流程图"></a>4. 打款资金流程图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/nEjwclCsL2yP5mO2mCFH.png" alt="img"></p><h3 id="5-退款业务流程图"><a href="#5-退款业务流程图" class="headerlink" title="5. 退款业务流程图"></a>5. 退款业务流程图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/hOZ11PgUcT4apoRGYD7L.png" alt="img"></p><h3 id="6-退款交易时序图"><a href="#6-退款交易时序图" class="headerlink" title="6. 退款交易时序图"></a>6. 退款交易时序图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/7tIFzVNXobDkJiHlhTLp.png" alt="img"></p><h3 id="7-信息流程图"><a href="#7-信息流程图" class="headerlink" title="7. 信息流程图"></a>7. 信息流程图</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/ZXyvzfm6CZLHKP3SXmhO.png" alt="img"></p><h2 id="九、记账逻辑"><a href="#九、记账逻辑" class="headerlink" title="九、记账逻辑"></a>九、记账逻辑</h2><h3 id="1-充值类业务记账处理"><a href="#1-充值类业务记账处理" class="headerlink" title="1. 充值类业务记账处理"></a>1. 充值类业务记账处理</h3><ol><li>被支付充值账户登记一条充值业务流水</li><li>实时更新被该充值账户余额</li><li>发送该充值业务数据到会计核心</li><li>会计核心根据账务系统提供的会计科目做一条客户帐的贷方分录</li><li>会计前置系统将该条充值业务订单发送之对帐中心数据库</li><li>日终处理程序根据对账中心当日的充值数据按业务类别（不含人工恢复数据）汇总分别借记一条中行银行待清算款充值账户的分录，同时更新相应科目下的内部户余额。（注：该分录入账时间与被充值账户的贷方分录中登记的入账日期保持一致）（业务要求：汇总的几条分录能分别查看到相应的明细流水）</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/11/FmgytxtZybsCBAUVtEUx.png" alt="img"></p><h3 id="2-充值业务订单的恢复处理"><a href="#2-充值业务订单的恢复处理" class="headerlink" title="2. 充值业务订单的恢复处理"></a>2. 充值业务订单的恢复处理</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/RKpwQXI6rK9lYJxTpENn.png" alt="img"></p><h3 id="3-充值订单对账处理"><a href="#3-充值订单对账处理" class="headerlink" title="3. 充值订单对账处理"></a>3. 充值订单对账处理</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/fFVXXHkXqAuvA6Umg8m5.png" alt="img"></p><h3 id="4-提现类业务记账处理"><a href="#4-提现类业务记账处理" class="headerlink" title="4. 提现类业务记账处理"></a>4. 提现类业务记账处理</h3><p><strong>（1）提现业务处理</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/11/dAmjac5U31vLG68M1NDl.png" alt="img"></p><p><strong>（2）提现业务处理记账逻辑</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/11/tuPWSQVA6YI9UZs45N6T.png" alt="img"></p><p><strong>（3）提现业务对账后账务处理</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/11/UbgOgXduSWUFiC6uX6dT.png" alt="img"></p><h3 id="5-对账处理"><a href="#5-对账处理" class="headerlink" title="5. 对账处理"></a>5. 对账处理</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/qCNquyx9PEmrKXyOH4vu.png" alt="img"></p><h3 id="6-会计分录"><a href="#6-会计分录" class="headerlink" title="6. 会计分录"></a>6. 会计分录</h3><p><img src="http://image.woshipm.com/wp-files/2018/11/GrmnHnJcE1HLl04bb3gw.png" alt="img"></p><h2 id="支付系统设计之查漏补缺的一环：差错账处理"><a href="#支付系统设计之查漏补缺的一环：差错账处理" class="headerlink" title="支付系统设计之查漏补缺的一环：差错账处理"></a>支付系统设计之查漏补缺的一环：差错账处理</h2><h2 id="当日反交易"><a href="#当日反交易" class="headerlink" title="当日反交易"></a><strong>当日反交易</strong></h2><h3 id="概念简述"><a href="#概念简述" class="headerlink" title="概念简述"></a>概念简述</h3><p>当日反交易是把当日初始凭证下所有后续业务登记（包括该初始凭证本身）所产生的账务流水和会计分录分录整套全部抹掉，适用场景特殊，特别是对于批量销帐类业务，慎用。</p><p>进行反交易处理后，如该初始凭证下存在未销帐的挂帐凭证，也是不允许对其进行后续销帐业务登记处理的。</p><h3 id="业务校验规则"><a href="#业务校验规则" class="headerlink" title="业务校验规则"></a><strong>业务校验规则</strong></h3><ol><li>被反交易凭证必须是当前日所产生的；</li><li>被反交易凭证以及其后续其他业务登记凭证状态必须全部是复核通过并处理结束；</li><li>已经被隔日冲正过业务凭证不能被反交易；</li><li>已被反交易过的业务凭证不允许被冲正；</li><li>补偿校验，必须通过会计核心业务校验：允许对所选择的凭证进行反交易。</li></ol><h3 id="系统数据反映"><a href="#系统数据反映" class="headerlink" title="系统数据反映"></a><strong>系统数据反映</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/10/1BAnk3k5ol44fSUhlYsZ.png" alt="img"></p><ul><li>源帐户指所有分录所对应的帐户，源金额指所对应的发生额；</li><li>会计平台中借贷方均为空，发生额为 0 ；</li><li>不需要同步对帐中心流水；</li><li>不产生新的账务流水，只在原流水上做抹账标记并反向更新帐户余额，被抹账的分录所对应的账务流水至少对前台用户不可见；</li><li>不产生新的红、蓝字分录；</li><li>对于红字或打上抹账标志的账务流水以及分录都不做更新。</li></ul><p><strong>注：不需要同步对账中心流水</strong></p><p><strong>举例：</strong>反交易是针对整套业务（依据原始业务凭证）进行反交易，仅限于整套都是当日的业务（可以包含当日正常和登记以及当日后续单边抹账产生的分录），反交易成功后账户明细和分录都将不体现，但记录反交易日志。</p><p><strong>凭证详细信息：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/10/ppAout1L4my2s4ZIFyho.png" alt="img"></p><p><strong>分录查询：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/10/RUO42ybhGHkar4sHvyza.png" alt="img"></p><p><strong>分录信息：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/10/p3W1r1JcqNuTVOPsT7sc.png" alt="img"></p><h2 id="当日单边抹账"><a href="#当日单边抹账" class="headerlink" title="当日单边抹账"></a><strong>当日单边抹账</strong></h2><h3 id="概念简述-1"><a href="#概念简述-1" class="headerlink" title="概念简述"></a>概念简述</h3><ul><li>针对当日复核通过并处理结束，而由于登记错误部分记账操作是错误的，可以针对所产生的分录进行当日单边抹账处理。</li><li>可对当日凭证做多次单边抹账处理，所达到的目的是将被抹账的分录所对应的款项转至指定的正确目标户，该凭证产生蓝字分录；允许多对多抹账，但方向必须一致。</li></ul><h3 id="业务校验规则-1"><a href="#业务校验规则-1" class="headerlink" title="业务校验规则"></a><strong>业务校验规则</strong></h3><ol><li>必须是单边抹账，即只能抹借贷一方，并且至少有一条被抹分录和目标户信息；</li><li>被抹账分录必须是当日所产生的；</li><li>被抹账分录必须归属于同一业务凭证；</li><li>被抹账分录业务代码必须一致；</li><li>被抹账分录所属的业务凭证状态必须是复核通过并处理结束；</li><li>被抹账分录所属的原始业务凭证及其后续业务登记凭证不能已被隔日冲正过；</li><li>被抹账分录所属的原始业务凭证不能已被反交易；</li><li>所抹账的分录必须与目标户所产生的蓝字分录方向一致；</li><li>所抹账的分录总额必须与目标户所产生的蓝字分录总额一致；</li><li>红字分录不允许被抹账；</li><li>已抹账的分录不允许被抹账；</li><li>补偿校验，必须通过会计核心业务校验：允许对所选择的分录进行当日单边抹账。</li></ol><h3 id="系统数据反映-1"><a href="#系统数据反映-1" class="headerlink" title="系统数据反映"></a><strong>系统数据反映</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/10/eGy42BmtIplpW98uOl9v.png" alt="img"></p><p>注：</p><ol><li>源帐户指被抹账分录所对应的帐户，源金额指所对应的发生额；</li><li>目标帐户指所指定的目标户，目标金额指指定的发生额；</li><li>会计平台中借/贷方只显示单边帐户信息；</li><li>不需要同步对帐中心流水；</li><li>由于不产生红字账务流水，只在原流水上做抹账标记并反向更新帐户余额，被抹账的分录所对应的账务流水至少对前台用户不可见；</li><li>蓝字(目标户)所新产生的账务流水以及会计分录的业务代码与被抹账分录的业务代码保持一致；</li><li>蓝字分录的方向根据所抹账分录的方向一致。</li></ol><p><strong>注中注：不需要同步对账中心流水</strong></p><p><strong>举例：</strong></p><ul><li>可根据业务登记中的初始凭证流水号选择原始数据（成套分录）进行单边抹账，对于分录级别的重复单边抹账，系统报错，不允许操作，单边抹账本身也产生业务凭证。</li><li>只允许针对当日的分录进行当日的单边抹账操作；</li><li>单边抹账是把选择要抹账的业务流水设置成删除，然后新增蓝字同向的新业务流水，操作上类似于冲正业务，可以选择需要进行单边抹账的业务流水，然后新增新的同方向的业务流水；</li></ul><p><strong>凭证详细信息：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/10/Gf3iKUl0OM3sRL5wa4tP.png" alt="img"></p><p><strong>分录查询：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/10/9zGIfw3TpbX7wqlOq2ap.png" alt="img"></p><p><strong>分录信息：</strong></p><p><img src="http://image.woshipm.com/wp-files/2018/10/mhjFRbE1qiaZi58EDeLX.png" alt="img"></p><h2 id="隔日冲正"><a href="#隔日冲正" class="headerlink" title="隔日冲正"></a><strong>隔日冲正</strong></h2><h3 id="概念简述-2"><a href="#概念简述-2" class="headerlink" title="概念简述"></a>概念简述</h3><p>所达到业务目的同当日单边抹账业务登记行为，不同的是必须在T日后方可对T日的分录进行冲正；可对T日凭证做多次冲正处理，所达到的目的是将被抹账的分录所对应的款项转至指定的正确目标户，该凭证产生红、蓝字分录。允许多对多冲正，但方向必须一致。</p><h3 id="业务校验规则-2"><a href="#业务校验规则-2" class="headerlink" title="业务校验规则"></a><strong>业务校验规则</strong></h3><ol><li>必须是单边冲正，即只能冲正借贷一方，并且至少有一条被冲正分录和目标户信息；</li><li>被冲正分录必须是当前日所产生的；</li><li>被冲正分录必须归属于同一业务凭证；</li><li>被冲正分录业务代码必须一致；</li><li>被冲正分录所属的业务凭证状态必须是复核通过并处理结束；</li><li>被冲正分录所属的原始业务凭证不能已被反交易；</li><li>所冲正的分录必须与目标户所产生的蓝字分录方向一致；</li><li>所冲正的分录总额必须与目标户所产生的蓝字分录总额一致；</li><li>红字分录不允许被冲正；</li><li>已被抹账的分录不允许被冲正；</li><li>已被冲正的分录不允许被冲正；</li><li>补偿校验，必须通过会计核心业务校验：允许对所选择的分录进行隔日冲正。</li></ol><h3 id="系统数据反映-2"><a href="#系统数据反映-2" class="headerlink" title="系统数据反映"></a><strong>系统数据反映</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/10/OrAXygg9dPg0cKUwZmNF.png" alt="img"></p><p>注：</p><ol><li>源帐户指被冲正分录所对应的帐户，源金额指所对应的发生额；</li><li>目标帐户指所指定的目标户，目标金额指指定的发生额；</li><li>会计平台中借/贷方只显示单边帐户信息；</li><li>不需要同步对帐中心流水；</li><li>产生红字账务流水，前台用户可见；</li><li>红、蓝字所新产生的账务流水以及会计分录的业务代码与被冲正分录的业务代码保持一致；</li><li>红、蓝字分录的方向根据被冲正分录的方向一致。</li></ol><p><strong>注中注：不需要同步对帐中心流水</strong></p><p><strong>举例：</strong></p><p>凭证详细信息</p><p><img src="http://image.woshipm.com/wp-files/2018/10/cR7jKLVRyNToUjzIIYWx.png" alt="img"></p><p>分录查询</p><p><img src="http://image.woshipm.com/wp-files/2018/10/jygRUnb22nEU1pTu106U.png" alt="img"></p><p>分录信息</p><p><img src="http://image.woshipm.com/wp-files/2018/10/csIZbPUi17eMmRltfauD.png" alt="img"></p><h2 id="实战举例（反交易、当日单边抹账、隔日冲正）"><a href="#实战举例（反交易、当日单边抹账、隔日冲正）" class="headerlink" title="实战举例（反交易、当日单边抹账、隔日冲正）"></a>实战举例（反交易、当日单边抹账、隔日冲正）</h2><p><img src="http://image.woshipm.com/wp-files/2018/10/XtR3efjG5sMizHlcYQCV.png" alt="img"></p><h2 id="干货-从入门到实践——财务系统设计详解"><a href="#干货-从入门到实践——财务系统设计详解" class="headerlink" title="干货 | 从入门到实践——财务系统设计详解"></a>干货 | 从入门到实践——财务系统设计详解</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p><img src="http://image.woshipm.com/wp-files/2018/12/efa0gPoZxVGTUiNbYzaU.jpeg" alt="img"></p><p>首先如图所示，支付的整体现状就是：</p><p><strong>①支付链路长</strong></p><p>链路长其实大家是有具体体会的。例如：C 端客户在线下商超或餐饮进行了购物消费，紧接着会通过入网商户，入网商户将本笔交易上传到第三方或第四方支付公司，最终通过银联网络完成银行卡内交易的资金清算。实际生活中，还有可能通过资方支持（例如小贷）完成非银行卡资金的交易扣款。</p><p>相比较传统的现金购物方式，互联网支付链路非常长。</p><p><strong>②各参与方均需获取收益</strong></p><p>支付链路长，就涉及到各个参与方需要获取收益，毕竟服务不是 0 成本的。如何计算这些收入并完成对账和结算，便显得尤为重要。</p><p>基于此，账务对账和结算相关的系统的重要性不言而喻。</p><h3 id="支付系统业务架构"><a href="#支付系统业务架构" class="headerlink" title="支付系统业务架构"></a><strong>支付系统业务架构</strong></h3><p><img src="http://image.woshipm.com/wp-files/2018/12/pLdS97m76luHn4jiRBKN.jpeg" alt="img"></p><p>首先给大家讲一下，这个并不是一个标准的支付业务架构图，这个架构图是从财务架构的角色出发而画的。</p><p>首先看接入层，从事支付相关的同学应该做过订单的接入，可能有 App、外部收银台等，这种接入与上图的架构图是不同的。从财务架构的角度来说，接入相当于本笔交易本身，更关注产品、产品属性、交易的方式等等。例如付款方以会员身份发起资金管理类交易，或者付款方以会员身份主动发起购物类结算等。</p><p>可将支付业务架构核心分为三层：</p><ul><li>第一层：接入层；</li><li>第二层：支付、交易、渠道层。</li><li>第三层：资金层。</li></ul><h3 id="为什么要关注交易层？"><a href="#为什么要关注交易层？" class="headerlink" title="为什么要关注交易层？"></a><strong>为什么要关注交易层？</strong></h3><p>上文提到的，财务架构更关注交易的产品属性、交易的场景属性，关注这些的目的在于：</p><ol><li>支付机构在给商家及渠道做签约的过程中，不同的场景及不同的产品就会涉及到不同的费率；</li><li>支付机构如京东金融，需要核算各个不同产品的收入、成本、利润。</li></ol><p>因此从财务架构的角度来说，此类信息应当在接入层（即收银台/POS刷卡接入系统），将上述属性进行传输。</p><h3 id="交易支付渠道层"><a href="#交易支付渠道层" class="headerlink" title="交易支付渠道层"></a><strong>交易支付渠道层</strong></h3><p>这一层把控影响着整个支付环节资金的来源于去向，所以在财务架构严重非常重要。例如交易层的银行卡收单，对于网关支付和快捷支付它的支付形式是不一样的，因此渠道商对支付公司、支付公司对商户的签约费率也是不一样的。但是对这两种不同产品的交易，资金的流转是一样的，银行把钱给支付机构、支付机构把钱结算给商户。</p><p>基于上述内容，对交易层的直接感官就是需要按照交易类型进行区分：第一种是银行卡支付，第二种是虚拟币支付（例如京豆、优惠券），第三种是余额支付（在支付机构支付账户余额）。</p><h3 id="资金层"><a href="#资金层" class="headerlink" title="资金层"></a><strong>资金层</strong></h3><p>首先介绍一下我依据个人经验，对整个清结算分为四类进行讨论：</p><ol><li>代收款结算；</li><li>代收款分账；</li><li>货款结算；</li><li>分润。</li></ol><h2 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a><strong>账户系统</strong></h2><p>账户系统的分类从账户属性入手，分为：</p><ol><li><strong>储蓄账户：</strong>类似于银行的储蓄账户，就是支付账户。</li><li><strong>信用账户：</strong>即将要产生一些贷款账户；另企业债和银行作为普通消费者与商家是不会过多关注的，但公司级财务是特别需要关注的。通过企业账，财务可以知道企业的损益情况；通过银行账，可以得知公司的收款、应收款、应付款以及成本等具体情况。</li></ol><h3 id="1-核算"><a href="#1-核算" class="headerlink" title="1. 核算"></a><strong>1. 核算</strong></h3><p>如图所示包含交易对账、资金对账、差错处理以及财务报告等四个功能。</p><p><img src="http://image.woshipm.com/wp-files/2018/12/zIh6JYWWhkhUvFgPVvfh.jpeg" alt="img"></p><p>当一笔交易通过订单完成到支付的环节的时候，通常的做法就是由一个支付信息到支付交易系统（各个公司的叫法可能不一样，有些公司可能叫支付页网关或者说叫总线的，我个人更多的叫支付交易系统），紧接着：</p><ol><li>要请求支付渠道把钱扣下来；</li><li>要入到公司自己内部的账务系统，把这笔交易记下来，并且记录收款和付款的参与方；</li><li>要从交易系统把这笔钱给到清结算系统去完成资金的清算；</li><li>清算就要参与到计费，就涉及到计费中心，完成手续费的计算；</li><li>清算完毕后，会根据与商户签约的一些结算周期去完成它的结算；</li><li>通过合同中心获取结算周期的信息；</li><li>（可能因为有些为了更加突出自己支付账户，很多支付机构都是把自己的对商户的结算款先要结算到他自己的账户里，就这样的话在结算的环节就会走一步）结算入账会把钱入到支付机构的支付账户，然后最终如果是商家说我给你签的合同需要把钱打到我的银行卡中，会通过一个结算出款，通过他的账户把钱存到银行卡上。</li></ol><p>通过支付渠道也可以理解为当笔交易资金过程，而资金过程最重要的一点就是要保证资金安全，因此需要进行交易对账。</p><p>首先从支付渠道会从银行或者说资方去拿到银行对账单，同时和公司的账务系统去对每一笔资金的流水去做勾兑，并将差错进行处理。</p><h2 id="账务系统-1"><a href="#账务系统-1" class="headerlink" title="账务系统"></a><strong>账务系统</strong></h2><p>整个账户的体系中还需要着重关注的是账户体系，即账户结构和账户包含哪些内容，核算要求那是会计必然要有的会计分录。</p><p><img src="http://image.woshipm.com/wp-files/2018/12/A9jUeuNXMOdepgNuGjI8.jpeg" alt="img"></p><p>简单来讲，产品就是说商家对个人提供业务形式；交易类型即在场景的基础上对整个交易作一个共性的抽取，在整个交易过程中不同的阶段会把它分成：例如收单，虽然都叫快捷收单，但是快捷收单会包含收单退款，甚至有可能会有退票的交易产生；账户体系主要基于前面的产品或者说交易的变化，我的账户的余额会发生变化，账户会有不同的流水；最终的会计分录用于财务核算。</p><p><img src="http://image.woshipm.com/wp-files/2018/12/lJmEobovPbdP593ob9CV.jpeg" alt="img"></p><p>如图所示，这个账户的含义，其实是有渊源的。08、09 年之前，支付机构的账户体系尚未提出，许多公司会有余额系统。现在账户和当年的余额很类似，但不完全一样。</p><ul><li>首先，账户包含账户号、账户类型，账户余额有可能包含我的可用余额以及我的冻结余额等等。</li><li>接下来是账户流水，方便用户了解余额变动的具体情况，自然就会产生流水号。</li><li>最后是账期对于普通用户不会特别关注，但是对于核算需特别关注。</li></ul><p>但是在做第三方支付的过程中，更多是参照于银行账户进行设计。每一笔流水需要：<strong>对手方是谁？</strong></p><p>例如：对方是银行卡收单的，需要记为商户的帐，因为贷记了对公司来说是负债的。这个商户今天有 100 块钱收单，他的对手方是谁，对手方可能是某一个个人，相当于付给商户的 100 块钱，这是说我要知道我的对手方。</p><p>然后是凭证号，所有的债务最终会拆到会计分录上，会计分录就是会计凭证，会有会计意义上的借和贷两方，通过凭证号能够看到账户流水是不是有缺失、是不是有差错，通过会计凭证的借和贷方发生额可以核算。</p><p>第三是摘要，摘要其实也是参照于银行账户，因为无论是过去的存折还是现在的银行卡流水都会给摘要或者备注，帮助记录每笔钱是什么来源及用户。</p><p><img src="http://image.woshipm.com/wp-files/2018/12/X6LLGsDHN6oi3IwLEEj2.jpeg" alt="img"></p><p>基于账户的组成，做支付账户系统的时候可以将账户分成四类账户：</p><ol><li>个人；</li><li>商户；</li><li>银行账户；</li><li>第四类是平台账户。</li></ol><p>银行账户是相对于资金渠道开立，记录某个资金渠道应收和应付的资金，方便对银行渠道做资金核对。在最后会多设一个账户叫银行余额户，表外户的概念是支付机构会给每一个银行账号开一个影子户，即银行卡有 100 块钱，我公司内部也要记录着银行的余额是 100 块钱，相当于是说要和我的银行流水是银行的真实的资金流是一致的，为了方便完成核算做资金对账余额调节表。</p><p><img src="http://image.woshipm.com/wp-files/2018/12/z93MxKnRnGGOmW7ELEYZ.jpeg" alt="img"></p><p>上图是一个标准的会计做账流程，手工做的也是这套流程。首先登记原始凭证，通过原始凭证拆分会计凭证并更新账簿（更新分户账以及账户余额）。</p><p>举个例子：银行卡收单 100 元，记应收账款某某资金通道，假设工行应收 100 ，然后会记录应付商户的货款，应收商户货款是 100 ，我这里面说了待清算账户是和前边的我们的账户商户开立待清算账户相关的，就像我在交易过程中，我会把所有的交易资金记入到商户的待清算户。收单是正单。</p><p>退款受理分成两部来记，既相当于会计分录。因为收单的环节几乎是秒级的，成功即成功失败即失败；但是退款有所不同，当我发起退款即便审核完成，由支付公司和银行去交货，也是有时间限制的，甚至可能还要根据公司备付金的资金情况、涉及到备付金的路由转换等等。因此将退款拆成两部分来处理：第一部分缴退款受理；第二部分实际通过渠道完成退款。</p><p>商户结算环节即将前一天收单金额和退款金额作轧差处理，需要收商户手续费。</p><p>付款处理和退款是相似的，付款也并非付款即可成功，银行同样有时限及大小额限制，需要打包处理。</p><h2 id="对账系统"><a href="#对账系统" class="headerlink" title="对账系统"></a><strong>对账系统</strong></h2><p><img src="http://image.woshipm.com/wp-files/2018/12/wHHNBpP0mJxa39RXIJZ5.jpeg" alt="img"></p><p><strong>对账系统是什么呢？</strong></p><p>实际上就是核对账目，是指在业务和财务核算过程中，为保证账簿记录的真实、正确、可靠，对账簿中记录的有关数据进行检查和核对的工作。目的就是要保证记录是真实可靠有效的，一旦出现对账不一致，需要依据整个交易的实际情况去处理。</p><p>对账第一个是业务核算，第二个是财务核算。业务核算举个例子，今天的交易在 T+1 做交易对账，该退款需要退款，该补单需要补单，这可能是属于业务范围。但是有可能今天的交易，T+1 才可以结算，那么实际上 T+2 的时候才可以做资金的核算。所以整个对账是两个环节，第一个是对，第二个是处理。</p><p>在术语上可能也不一样，比如说业务角度来说，更多时候对账也好勾兑也好，叫处理或者差错处理；但是从财务角度来说，对账会被认为是扎帐，看看帐是不是平。紧接着需要平账，把对账过程中发现不平的东西进行处理。</p><p>一般是有三种类型的对账：<strong>账账相符、账证相符以及账实相符。</strong></p><ol><li><strong>帐帐相符：</strong>因为每家支付公司都不可能只有一个系统，有很多套系统，账账相符要保证，公司内的一条交易在各个系统的状态是一致的，所表明的含义是一致的。</li><li><strong>账证相符：</strong>公司记得记录和资金渠道甚至商户提供的交易是能对的上的，就相当于公司内部交易和外部的交易做勾兑，保证内部交易和外部交易是平的。</li><li><strong>账实相符：</strong>经过前两轮的对账，保证公司内部的交易状态是一致的，与各个参与方的状态也是一致的，但是有可能出现资金到了或者缺失不能确认，需要进一步核对。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/12/qbpDCvrPq6VZGq0Acs1x.jpeg" alt="img"></p><p>首先要通过渠道对账单进行下载、解析，做成标准的对账；然后与账务系统的凭证做勾兑，勾兑的结果最终和对账结果对比处理。</p><p>举个例子，假设如图所示是公司的交易，第一条的对账相当于是平的，金额也一致，这说明我们第一步对账就对平了。但是以上面的第二条第三条为例，比如说给用户充值，我方发起请求的时候，有可能会超时，超时情况下不可能给用户入账，否则导致资损。</p><p>为了保证用户资金可靠，将以冲正的方式告诉银行，这笔我冲正了，帮我冲销掉，在这种情况下银行就不会有记录，但是我们公司内部有充值以及冲正，这两条记录。</p><p>这是第二种类型的对账，需要内部勾兑。</p><p>第三种就是退款，我方是两笔，银行是一笔，需要核单，就是多对一的勾兑。第四种是线下充值，线下充值是不走线上系统的，流水号、银行流水和企业流水是完全没有可对性的，这种情况下需要对客户、对资金，那对客户对资金就有可能有重的情况。多对多的对账，以先到先对的原则，那笔交易发生在前先对哪一笔，对不上的就是差异。</p><p><img src="http://image.woshipm.com/wp-files/2018/12/LTW6WfK7YD7CJ8TitLAl.jpeg" alt="img"></p><p>对账结果也比较简单，第一是对平的，第二是未对平的，未对平，以代付为例，代付可能我方是处理中，银行是成功。只是说这笔交易是对上了，金额也对上了，但是关键信息是不符的。</p><h2 id="清结算系统"><a href="#清结算系统" class="headerlink" title="清结算系统"></a><strong>清结算系统</strong></h2><p><img src="http://image.woshipm.com/wp-files/2018/12/1fZP0Rb9NzWaYgSDKfAC.jpeg" alt="img"></p><p>清结算是收单业务的资金管控模块，掌握资金交易的流向，所有备付金的收单款都应该由清结算处理，不应该交给别的系统来处理。</p><p>清结算分成大概三类：</p><ol><li>第一个是清分清算，根据交易结果和交易相关规定对会员的保证金等等的一系列的货款款项做计算；</li><li>第二部分的商务结算，按照和商户签约的结算周期，对应收应付的金额完成资金的划拨；</li><li>第三部分，我要做结算对账，保证货款两清。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/12/qXdw1ajpLHuv7t6rcgRb.jpeg" alt="img"></p><p>清结算系统的四个能力如图所示：</p><ol><li><strong>账扣：</strong>交易款结算实时从商户结算户中扣除；</li><li><strong>后收：</strong>结算款全额结算；</li><li><strong>预充实扣：</strong>结算款全额结算，结算时指定账户扣除手续费；</li><li><strong>溢价：</strong>交易过程中，对 C端用户额外收取手续费。</li></ol><p><img src="http://image.woshipm.com/wp-files/2018/12/600NWOjLhvwZqdYwYmQt.jpeg" alt="img"></p><p>对于计费能力可分为三种：①单笔费率；②累计梯度；③追溯梯度。</p><p>着重解释一下第三种，追溯是说随着销量的变化费率发生变化了，需要把之前的收费少收的要收回来，多收的要退回去。</p><h2 id="支付系统设计白皮书：支付系统的概念与架构"><a href="#支付系统设计白皮书：支付系统的概念与架构" class="headerlink" title="支付系统设计白皮书：支付系统的概念与架构"></a>支付系统设计白皮书：支付系统的概念与架构</h2><p>支付系统伴随着电子商务的出现而出现，为各类电子商务经营活动实现在线收付款交易，以及管理交易资金等功能，是具有一定独立性的内部系统模块。</p><h2 id="一、什么是支付系统"><a href="#一、什么是支付系统" class="headerlink" title="一、什么是支付系统"></a>一、什么是支付系统</h2><p>自古以来，所有的商业活动都会产生货币的收款与付款行为。在人类漫长的历史长河中，记录收付款行为的方式不断迭代：古代的账房先生通过手工记账，工业社会通过收银机机械记账……</p><p>今天，进入了互联网时代的我们，商业行为也一同进行了数字化与信息化的演变，成为今天的「电子商务」。</p><p>支付系统伴随着电子商务的出现而出现，为各类电子商务经营活动实现在线收付款交易以及管理交易资金等功能，是具有一定独立性的内部系统模块。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/Pu4Ub963M0txC0x0OdmM.png" alt="img"></p><ul><li><strong>平台</strong>：开展电子商务经济活动的主体。</li><li><strong>业务系统</strong>：实现平台用户注册、商品定价、营销活动等相关功能。</li></ul><p>平台与业务系统的关系：业务系统将用户购买行为通过各种交易订单的形式进行记录，并交付支付系统进行处理，最终由支付系统完成收款与付款。</p><p>根据央行的现行规定，人民币交易处理仅限于银行及第三方持牌支付机构，因此支付系统在实现上述功能时，需要通过外部银行、第三方持牌支付机构完成交易资金处理。因此，支付系统需要具备：</p><ul><li>统一封装处理的交易接口，以对接外部交易渠道，为业务系统实现交易订单处理的功能。</li><li>根据业务系统设置的资金分配规则，在一笔交易有多个收款方参与的情况下根据资金分配规则完成交易资金的自动化清分与结算，而后通过已对接的外部交易渠道完成划付。</li><li>账务数据记录功能，上述的交易、清分、结算形成的资金变动信息，需要支付系统通过账务数据记录功能加以记录，对交易资金进行统计并完成交易资金核对等财会工作。</li></ul><h2 id="二、支付系统架构"><a href="#二、支付系统架构" class="headerlink" title="二、支付系统架构"></a>二、支付系统架构</h2><p>支付系统的主要职责是处理业务系统发起的所有交易请求，包含收银台、交易系统、支付核心等模块，根据各模块不同的功能职责，可以将支付系统分为业务层和支付层两部分。</p><ul><li>业务层负责为业务系统提供收付款的操作界面以及处理业务系统提交的交易请求；</li><li>支付层负责通过支付渠道实时处理完成资金的收付款、记录参与交易的账户间资金流转情况并按照预定规则对账户所属资金进行拆分与合并。</li></ul><p><img src="http://image.woshipm.com/wp-files/2019/03/bGPtXEs29mg4HKur2uXN.png" alt="img"></p><h3 id="1-业务层"><a href="#1-业务层" class="headerlink" title="1. 业务层"></a>1. 业务层</h3><p>业务层包含收银台、交易系统以及会员系统三个功能模块：</p><p><strong>（1）收银台</strong><br><strong>收银台即用户日常付款前选择渠道的页面，是支付平台提供的基本功能之一，</strong>主要职责是协助业务平台完成支付交易，向用户提供一致的交易体验。一般情况下，根据不同终端类型定制标准化的收银台给到外部进行调用，保证各终端体验一致且针对各端特定需求、场景来展现不同的支付方式。</p><p><strong>①收银台的业务场景（边界）</strong>一般分为付款与充值两部分：</p><ul><li><strong>付款</strong>即通过各类支付方式针对业务订单发起付款，例如：用户在天猫店购买一件衣服，确认订单后自动跳转至支付宝，引导用户选择对应的方式（余额、花呗、银行卡等）进行付款。</li><li><strong>充值</strong>即用户对账户进行余额充值，例如：用户登录支付宝、微信或其他商户自有钱包系统对账户余额进行充值。</li></ul><p><strong>②支付渠道的服务模型，</strong>分为以下几个要点：</p><p><strong>服务模型的概念：</strong>从支付公司角度来看，服务模型是决定商户可以使用的交易形式（担保收单、即时到账等）、支付产品（快捷、网银、代扣、POS 等）、签约方式、阶段周期（T+0、T+1、T+N 等）以及费率等核心问题的综合体；</p><p>从电商平台角度来看，电商公司内部使用的支付系统与支付机构相比复杂度较低，可通过参考支付公司服务模型，梳理不同业务、不同交易类型、不同结算周期以及不同支付渠道等复杂需求，搭建合理且满足业务需求的服务模型，例如充值类交易，具有商城属性的业务可配置担保收单或即时到账等交易类型。</p><p><strong>服务模型的维度：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/VVAtveqqwbqSo0m0X4HP.png" alt="img"></p><p><strong>行业/服务维度：</strong>即从业务角度出发对支付产品进行划分。</p><p>例如：蚂蚁金融面向行业输出交易、结算、会员、安全等服务，且为不同的服务等级划定标准，贯穿所有内部系统；普通非支付公司（以电商为例），提供即时到账、担保收单等，基本上能满足大多数的业务场景。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/MLXbheo2s6cGEZlYdi62.png" alt="img"></p><p><strong>商品维度：</strong>针对不同行业的交易标的，由于交易价格、成本与利润差异大，因此在业务层面不同的支付渠道要有不同的可用性标准。</p><p>一般情况下，商品本身与市场或行业挂钩，例如喜马拉雅在接入微信/支付宝时，业务所在行业为视频影音属于虚拟商品，因此接入费率为 1%，结算周期为 T+7。</p><p>由此可得，支付公司针对不同商品本身的特性（例如风险等因素）在费率和结算周期上会进行一定的控制；同时，针对高风险行业会在支付方式、渠道层进行限制。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/bSfy5e0FE9SnYnFIoevV.png" alt="img"></p><p><strong>市场维度：</strong>此处「市场」指的是指引客户使用支付产品服务的场所，它可能是支付产品本身，亦可能为相关公司或平台的网站。例如某集团子公司、某公司投资的公司以及与该公司无关的外部公司等等，可分为集团、内部以及外部等维度。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/k4tfxWeRRC22LSxrJDpM.png" alt="img"></p><p><strong>客户维度：</strong>此处「客户」指的是服务的具体使用者。可分为个人客户及企业客户，通过支付系统内的会员系统进行区分。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/pr1BbSxKec95Y0MWzJVQ.png" alt="img"></p><p><strong>付款方维度：</strong>付款方在整个业务过程中未核心角色，针对付款方用户的特征应建立以支付渠道收款方维度的模型，例如付款方的账户模型、安装是否正式、证书等级等要素都决定着付款方的付款流程。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/JIb6qojO0LP5iT9IYRiw.png" alt="img"></p><p><strong>支付渠道维度：</strong>在电商平台，跳转到支付系统是，收银台根据付款方的参数规则，进而对该笔支付在收银台内可使用的支付渠道进行选择。例如充值账户余额不允许使用信用卡时，收银台在付款方付款时仅可展现借记卡等支付方式，喜马拉雅在于支付宝等第三方支付公司交互式，下单接口里一般含有做借贷分离的参数，该参数起到的作用就是可以指定付款方即用户不可使用借记卡或信用卡。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/Tnb5xZM6KNqkKZHIsUNi.png" alt="img"></p><p><strong>业务渠道维度：</strong>业务端使用的入口，代表着客户或者业务方和支付系统的交互方式。例如通过 PC 端跳转到收银台、通过 App 跳转到收银台以及纯接口形式跳转等等。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/oUvskCVHCKkpZZHYw7w1.png" alt="img"></p><p><strong>支付渠道各类配置：</strong></p><ol><li><strong>渠道配置</strong>：抽象收银台支付方式大类（第三方、网银储蓄卡、网银信用卡、信用类（花呗、白条）等），对应每个大类下配置对应的落地渠道，再分别对适用场景进行匹配（ App、H5、PC 端、公众号等等），不同的场景下应对应不同的支付方式。</li><li><strong>渠道参数配置</strong>：在业务进行中根据公司的具体情况，部分业务可能独立运营，因此在独立运营过程中财务需要就独立业务传入各支付渠道对应的密钥及商户 ID 等关键参数信息，以满足业务方需要支付系统根据不同商户信息调用对应渠道收款主体的需求。</li></ol><p><strong>（2）交易系统</strong></p><p>交易系统本身是作为支付系统外部处理业务逻辑的外围系统。由于支付核心系统本身并非面向业务端且业务逻辑的多变性与复杂性，支付系统为了兼顾稳定并能够为业务端提供灵活支持，因此需要在支付系统外层搭建面向业务端处理交易逻辑的交易系统。交易系统处理业务端的各种交易类型后，将业务信息转化为支付系统可识别的支付订单并导入。</p><p>以担保交易为例，C 端用户在天猫购买一件商品，成功支付后商家进行发货，用户确认收货后平台将货款结算给商家。此处设计到「担保交易支付」以及「确认收货」环节，与支付系统内部的支付与结算步骤一一对应：</p><ol><li>用户付款成功后对应交易的付款成功状态；</li><li>用户确认收货后对应交易的成功状态。</li></ol><p>从支付和收货缓解可以看出，担保收单交易就是讲支付系统的支付基础能力包装后对外支持业务的一款产品。</p><p><strong>交易系统的职责：</strong></p><p>交易系统作为支付系统的入口：</p><ul><li>首先需要对接上层业务系统；</li><li>其次将支付系统的支付能力抽象出来，对外提供各类交易方式，例如下单、支付、修改金额、确认结算、退款、关闭交易以及查询等能力；</li><li>最后，交易系统需要对各种交易类型进行定义，例如担保交易、即时到账、充值、提现等类型。</li></ul><p><strong>交易系统的场景（边界）：</strong></p><ul><li><strong>下单</strong>：生成交易订单，确定交易参与；</li><li><strong>退款</strong>：针对已支付的订单进行退款，退款金额不得大于实际支付金额，积分的退款退回原积分账户，同时针对退款交易类型，会生成交易订单号，关联入款订单；</li><li><strong>修改金额</strong>：修改交易金额，对应生成新的支付订单；</li><li><strong>查询</strong>：查询交易结果、支付结果；</li><li><strong>通知</strong>：通知上层业务系统交易状态；</li><li><strong>算费</strong>：通过算费子系统计算每笔订单的手续费。</li></ul><p><strong>交易系统的交易类型：</strong></p><ul><li><strong>即时到账交易</strong>：买家在电商平台选择购买商品下单，付款成功后金额直接入卖家支付账户或者卖家银行账户；</li><li><strong>担保收单交易</strong>：买家在电商平台选择购买商品下单，有部分金额为担保金额，买家付款成功后，担保部分进入平台方中间担保账户，未担保金额直接入卖家支付账户或者卖家银行账户；</li><li><strong>收单退款交易</strong>：买卖双方在达成退款协议后，可针对及时到账交易，订金下定等已支付交易由商户平台发起退款请求；</li><li><strong>普通转账交易</strong>：当平台方需要对会员进行转账时，通过此接口实现金额的转移；</li><li><strong>合并支付交易</strong>：多笔交易订单合并（并笔）付款，适用于购物车针对不同商家生成订单的场景；</li><li><strong>下订交易</strong>：卖家和买家达成购买协议，先行支付部分订金，该部分订金在最终付款的时候可以被使用；</li><li><strong>提现</strong>：客户将支付账户的余额提到客户绑定的银行卡账户，基于支付账户单笔或者批量付款；</li><li><strong>冻结解冻</strong>：在交易前通过冻结能力将用户的部分资金冻结，保障交易能正常进行，也可以由于某些原因（账户被盗、司法案件、反洗钱等），冻结用户资金操作，保证用户的资金安全；</li><li><strong>充值</strong>：基于支付账户做余额充值，将用户的银行卡账户资金充到用户的支付账户余额。</li></ul><p><strong>交易系统的交易特性归类：</strong></p><p><strong>①实效性：</strong></p><ul><li><strong>全额实时到账</strong>：即时到账类交易，付款后实时到账；</li><li><strong>部分确认支付、部分即时到账</strong>：担保收单类交易，这里分为部分担保的场景，只有指定金额部分需要确认结算；</li><li><strong>全额确认支付</strong>：全额担保交易，电商交易场景下需用户确认收货后才会将全部货款结算给卖家。</li></ul><p><strong>②交易系统的支付形式：</strong></p><ul><li><strong>单笔支付交易：</strong>单笔支付行为，用户基于一笔订单发起付款；</li><li><strong>合并支付交易</strong>：多笔合并支付行为，用户基于多笔订单发起合并付款；</li></ul><p><strong>③业务类型：</strong></p><ul><li><strong>收单交易</strong>：支付入款类型交易，付款人收款人分别是两个角色；</li><li><strong>充值交易</strong>：账户充值类交易，付款人和收款人都是同一个人，由外部账户到内部账户；</li><li><strong>出款交易</strong>：基于账户做提现，付款人和收款人都是同一个人，由内部账户到外部账户；</li><li><strong>退款交易</strong>：收单入款交易的反向流程。</li></ul><p><strong>（3）会员系统</strong></p><p>会员系统是完整的支付平台内极其重要的基础模块之一，负责管理支付系统内部的交易主体。会员系统保存了客户在支付系统内部账号的实体信息，为客户建立了统一的、以会员 ID 为标识的会员基本信息、关系信息（会员和账户、会员和操作人、会员与银行卡）视图。</p><p>一般情况，会员在支付系统内部分为个人会员和企业会员（默认企业会员有商户权限），以电商平台为例，C 端用户为个人会员，B 端商户为企业会员：</p><ul><li>通常，企业会员会配置一定的业务参数，比如结算周期、接口权限、支付方式配置等（开通商户权限的情况下）；</li><li>在大多数互联网公司，支付系统仅需要对接支付渠道的模块，在没有独立平台化的情况下，不太会出现需要独立的账户体系。</li></ul><h3 id="2-支付层"><a href="#2-支付层" class="headerlink" title="2. 支付层"></a>2. 支付层</h3><p>支付层包含支付核心、账务核心以及清算核心三个部分。</p><p><strong>（1）支付核心</strong></p><p>下方的内容介绍了支付核心的职责、边界以及系统架构三个部分。</p><p><strong>支付核心的职责：</strong></p><p>支付系统的职责为通过支付核心与后端清结算、会计、账务等系统的统一协作，让前端支付产品可以更关注产品本身的逻辑，而减少对清分、对账、储值等后端服务的考量及动作；同时通过标准化的支付指令定义，统一前端支付产品的支付请求接口，提供适应各类产品使用的基础支付服务。</p><p><strong>支付核心的边界：</strong></p><ul><li><strong>支付服务</strong>：负责对后端支付系统的接口进行业务包装，同时实现使用多个支付方式进行组合支付的功能；</li><li><strong>支付服务流程</strong>：对各支付类型的支付服务流程进行定义，具体定义为充值、提现、内转支付（转账）、退款等原子类型，并实现对基础服务的流程编排；</li><li><strong>支付指令</strong>：发起订单后，通过协议和协议明细项加工得出支付指令，需具备进行后续操作处理的全部要素信息；</li><li><strong>支付协议</strong>：根据产品设立支付协议，因此支付协议的关键要素包含产品码及支付编码，定义着产品的处理流程、收付款信息、对应的支付渠道信息。</li></ul><p><strong>支付核心的系统架构：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/FV9qHJv7y2uY6DIZzfnq.png" alt="img"></p><p>如图，将交易和支付分开，主要是为了体现出支付系统的核心支付功能，能够为会员提供丰富的支付服务：支付核心定义原子支付类型；服务层提供支付业务能力，例如出款、转账、红包、代金券、余额、现金等；产品层能够更加关注产品本身的逻辑，将后端标准化的逻辑交由支付层和清算层来处理，这样就能做到灵活和标准兼顾。</p><p><strong>（2）账务核心</strong></p><p>账务核心的功能为，根据前端业务系统的要求设计相匹配的账户类型、管理各类账户、记录账户资金变动等，同时，按照公司内部的财会规范提供反映各账户间交易资金变化情况的会计数据；并且负责将自身记录账务流水与支付渠道结算资金和结算流水进行核对，对对账结果中出现的差错交易进行差错处理。</p><p><strong>（3）清算核心</strong></p><p>清算核心负责维护客户参与交易时的清分、结算规则，并按照已配置的规则完成交易资金的清分与结算操作。</p><h2 id="支付系统设计白皮书：契合业务形态的收银台设计思路"><a href="#支付系统设计白皮书：契合业务形态的收银台设计思路" class="headerlink" title="支付系统设计白皮书：契合业务形态的收银台设计思路"></a>支付系统设计白皮书：契合业务形态的收银台设计思路</h2><h2 id="支付方式选择"><a href="#支付方式选择" class="headerlink" title="支付方式选择"></a>支付方式选择</h2><p>在收银台设计前，根据业务类型要对支付方式进行选择，目前常见的收银台支付类型包含两种：</p><ul><li>收单：通过各类支付方式针对业务订单发起付款。例如：C 端用户在天猫购买一件衣服，点击「提交订单」后，系统跳转至支付宝进行付款。这是标准的付款场景，也称之为收单。</li><li>充值：用户对账户进行余额充值。例如：C 端要用户登录支付宝等商户自有的钱包系统对账户进行余额充值。这是标准的充值场景。</li></ul><h2 id="业务流程及系统流程"><a href="#业务流程及系统流程" class="headerlink" title="业务流程及系统流程"></a>业务流程及系统流程</h2><h3 id="1-充值业务"><a href="#1-充值业务" class="headerlink" title="1. 充值业务"></a>1. 充值业务</h3><p><strong>①业务流程</strong></p><ol><li>用户对钱包账户发起充值；</li><li>跳转至收银台，根据展现的支付方式用户选择充值渠道（若该充值业务允许提现，收银台应根据充值业务配置对应的借记渠道，从业务侧规避用户使用信用卡充值做信用卡套现）；</li><li>充值成功后返回。</li></ol><p><strong>②系统流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/HJtKYQemaiOF8M0zo7OX.png" alt="img"></p><ol><li>用户在客户端发起充值流程，客户端获取收银台地址，收银台返回地址；</li><li>收银台根据请求类型跳转至收银台充值页面，显示对应的充值渠道；</li><li>用户选择对应的充值渠道后，收银台提交对应的充值订单到交易系统；</li><li>交易系统通过支付核心转化后给到清算核心，获取对应的支付渠道信息，返回给收银台；</li><li>收银台跳转支付渠道，用户在第三方支付页面进行支付；</li><li>支付结果以异步形式通知服务端，前台根据 return_url展示对应的充值结果页面。</li></ol><h3 id="2-收单业务"><a href="#2-收单业务" class="headerlink" title="2. 收单业务"></a>2. 收单业务</h3><p><strong>①业务流程</strong></p><ol><li>用户在业务端基于订单发起付款，跳转至收银台后选择支付渠道；</li><li>根据用户选择的支付方式决定后续流程：</li></ol><p><strong>余额支付</strong>：首先校验余额是否充足，若充足则用户可选择余额进行全额付款；确认付款后输入支付密码并校验支付密码是否正确，若正确则扣减余额，完成支付；</p><p><strong>网银或第三方支付</strong>：首先根据业务确定可使用的支付渠道列表，其次用户选择第三方支付后，调用第三方支付渠道发起付款，渠道限额校验由第三方完成，最后根据支付结果变更支付状态（正常情况下除了支付成功意外均以「处理中」做业务状态处理）。</p><p><strong>②系统流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/enMrOahcZpYCG6TTsMeb.png" alt="img"></p><ol><li>业务系统调用支付系统做业务下单，形成对应的入款交易订单，并跳转收银台；根据交易请求判断是否返回收银台（有部分业业务场景指定支付方式或以确认性付款成功等流程无需收银台）；</li><li>获取到收银台地址后，打开收银台界面，获取渠道列表并展示对应渠道；</li><li>用户选择支付方式，支付请求发送到清算核心，调用第三方支付渠道；</li><li>收银台跳转到对应支付渠道，用户在第三方支付页面进行付款；</li><li>支付结果以异步形式通知服务端，前台根据 return_url 返回对应页面。</li></ol><h2 id="组合支付"><a href="#组合支付" class="headerlink" title="组合支付"></a>组合支付</h2><p>组合支付即通过一种以上支付渠道完成付款的支付形式。组合支付是交易系统中提供的一种交易服务类型，例如早期支付宝有组合支付功能，最常见的组合支付类型为「账户余额 + 快捷支付」模式，此种类型可在做支付系统设计时进行借鉴，可实现「账户余额 + 第三方支付」的模式。</p><p>组合支付的衍生需求很好理解，当用户在平台的钱包账户内进行充值后，若想购买的商品价格超出了账户余额的可支付范围，即可使用组合支付的方式进行付款；此处的账户余额可理解为「广义范围内，所有涉及到支付系统内部清结算能力的支付形式」，凡是需要与其他渠道进行组合付款的场景均可使用组合支付的逻辑，例如基于营销设计的红包、代金券、积分以及预付卡等。</p><h2 id="组合支付的流程、设计"><a href="#组合支付的流程、设计" class="headerlink" title="组合支付的流程、设计"></a>组合支付的流程、设计</h2><h3 id="1-组合支付的流程"><a href="#1-组合支付的流程" class="headerlink" title="1. 组合支付的流程"></a>1. 组合支付的流程</h3><p><strong>①余额 + 第三方（支付成功）</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/4JCCU4xVyXZLJvChiz36.png" alt="img"></p><ol><li>用户发起组合支付，支付前置根据用户组合支付的行为生成组合支付业务订单；</li><li>支付前置系统根据系统配置的付款顺序对组合支付进行推进，由内部渠道和外部渠道进行的组合支付：原则上需要先调用外部渠道，因此支付前置基于组合支付订单生成了一笔第三方支付的子订单，也可以称为支付指令；待支付成功后，通知内部账户系统扣减账户余额，这样避免外部渠道不成功的情况下对余额进行了先行扣除；</li><li>外部渠道成功后通知前置系统，前置系统此时生成当笔内部余额扣减的支付指令并调用支付核心系统；核心系统返回成功后，将这比组合支付的业务订单置为成功并通知业务端。</li></ol><p><strong>②余额 + 第三方（支付失败）</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/r8d7akDbzT9Z0zesWZtC.png" alt="img"></p><p><strong>③组合支付设计</strong></p><p>组合支付本身对于交易系统来说差别不大，仅在订单发送至支付前置时，由于逻辑上来讲是两笔付款行为，因此会生成两条支付方式的请求：一条为余额支付请求，一条为第三方支付请求；转换到支付前置后，前置系统生成一笔组合支付的订单，且对应着两条支付指令（一条充值、一条转账），当充值的指令成功后去执行转账的指令，两笔都成功的情况下则通知上层系统变更业务状态。</p><ul><li>定义支付业务类型：组合；</li><li>对应指令：根据外部加内部的组合，根据具体指令需执行的原子类型，生成对应指令订单，遵循外部成功后再执行内部的流程；</li><li>支付方式：以组合种类为准，对应种类在网关传递交易时进行拆分，例如代金券 + 余额 + 第三方支付则需要分别定义三条支付方式信息。</li></ul><h2 id="优惠支付"><a href="#优惠支付" class="headerlink" title="优惠支付"></a>优惠支付</h2><p>优惠支付即基于支付系统的代金券、优惠券、红包等营销支付流程设计，本质上是基于账户做的营销支付体系，无论具体优惠形式，在支付系统内部都是以账户形式存在：例如代金券营销账户、优惠券营销账户等；根据具体的业务需求，支付系统对于此类营销支付在账户层面应设计两种方案：</p><ul><li>平台侧营销账户：代金券营销账户、优惠券营销账户等，其营销成本应从这两个账户中进行扣减，账户需自行预先充值，用户支付时所需部分抵扣的金额从该账户进行获取；</li><li>用户侧营销账户：红包、消费积分等营销账户与各个用户一一对应，用户在领取时视为开通了红包等营销账户；每当领取红包或获取消费积分，视为账户金额增加（相当于给用户的账户进行充值入账）。此外，也可以通过业务端对明细账户加以控制，支付系统则去维护总账户即可。</li></ul><h2 id="营销支付设计"><a href="#营销支付设计" class="headerlink" title="营销支付设计"></a>营销支付设计</h2><p>营销支付的设计可分为基于业务端做营销和基于支付端做营销两个方向：</p><p><strong>基于业务端做营销</strong>：在业务平台直接对优惠券金额进行扣除。</p><ol><li>调用支付系统前，业务系统根据优惠方式（立减、折扣或优惠券等）对可优惠金额完成计算并直接扣减调；</li><li>调用支付系统，并将用户实际待支付金额转入支付系统并生成支付订单。</li></ol><p>此方法的弊端在于，若平台型电商对营销成本进行结算，仅可通过线下或其他方式完成与商户间的结算工作，会增加财务工作量并造成账务不清晰等结果。<br><strong>基于支付端做营销：</strong>可分为平台侧与用户侧两部分。</p><p><strong>（1）平台侧：</strong></p><ol><li>将平台的优惠补贴金额通过内部户等形式存储在账户系统当中，类似「营销补贴户」；</li><li>用户在前端发起支付时，使用优惠券、红包、消费积分等营销工具抵扣部分金额，业务平台调用支付系统下单并传入总金额、支付金额以及抵扣金额等相关信息，根据总金额生成交易订单后，根据总金额的构成生成对应的支付订单；实际支付金额与用户待付款的支付订单相对应，抵扣金额为平台内部账户单独的内部流转支付订单，通过用户实际成功支付的消息进行后续处理；</li></ol><p>此类方法的优势在于将每个用户的业务明细留存在业务平台系统处理，支付系统只需要记录金额；收银台调用支付平台下单相关参数：业务平台订单号、UID、总金额、抵扣金额、支付金额、支付方式。</p><p><strong>（2）用户侧：</strong></p><p>当前电商平台有部分营销产品拥有较强的用户属性，例如红包、消费积分等，此类自带货币属性的虚拟账户余额，根据其业务属性对支付系统中的每位用户单独开设补贴账户，支付时根据营销账户 + 其他支付方式进行组合，与组合支付的逻辑相类似，一笔付款付多个付款渠道。</p><h2 id="支付系统设计白皮书：从收单网关及交易服务解析交易系统"><a href="#支付系统设计白皮书：从收单网关及交易服务解析交易系统" class="headerlink" title="支付系统设计白皮书：从收单网关及交易服务解析交易系统"></a>支付系统设计白皮书：从收单网关及交易服务解析交易系统</h2><blockquote><p>收单网关的设计要素包含：业务方、用户、业务系统、支付系统。</p></blockquote><h2 id="收单网关"><a href="#收单网关" class="headerlink" title="收单网关"></a>收单网关</h2><p>收单网关是平台方支付系统和用户/商户的PC、移动APP所使用的外部网络之间的接口，为支付系统操作将外网传输的数据转换为系统内部数据，同时负责将平台业务系统的内部请求转化为支付系统的内部数据。</p><p>收单网关的职责为支付平台化后，系统内部接口不可对外，因此所有外部系统需要通过统一的网关接口调用支付平台；由网关进行一系列格式校验、参数校验、业务调用权限检查后再向支付进行转发。</p><p>收单网关设计要素包含：</p><p><strong>业务方</strong>：指业务平台。可根据公司业务规模大小、业务领域或公司主体等维度，对对接的业务方进行区分，接入后这些业务方即成为支付平台的收单商户，使用平台支付产品实现其收付费功能需求；</p><p><strong>用户</strong>：业务平台 C 端用户，可根据业务方进行划分；</p><p><strong>业务系统</strong>：业务端的业务系统；</p><p><strong>支付系统</strong>：支付清结算平台。</p><h3 id="收单网关流程"><a href="#收单网关流程" class="headerlink" title="收单网关流程"></a>收单网关流程</h3><p><img src="http://image.woshipm.com/wp-files/2019/03/zNb13XCfMlvFRn2Jy8uq.png" alt="img"></p><ul><li><strong>构造请求信息</strong>：业务系统根据支付系统提供的接口规则构造请求信息，例如支付下单、取消订单、退款等等；</li><li><strong>发送请求信息</strong>：把构造好的信息发送到指定的地址；</li><li><strong>处理请求信息</strong>：支付系统会得到请求的数据信息，按照预定的验签，业务参数校验等一系列验证通过后，将请求的数据信息对业务（对应支付、取消、充值等等）进行处理；</li><li><strong>返回响应信息</strong>：支付系统会以同步和异步两种处理方式，返回业务数据处理结果；一般情况下，同步通知仅代表请求处理成功，业务订单处理状态会以异步通知的形式主动回调用户在下单的时候设置的异步回调地址，通知业务方时若得不到业务方的响应信息值「success」，支付系统会重复若干次（按照一定的频次配置），以防止掉单现象；若业务方户不设置，则不会通知；</li></ul><p>业务系统收到异步通知后，结合自身的业务规则改变支付单状态，进行如订单状态更新等业务处理。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><ul><li>业务系统和支付系统之间通过 https 协议来进行通信，接口以 URL 的形式提供并以 post 的请求方式进行处理；</li><li>文档的接口包括两种：服务接口和通知接口；</li><li>服务接口由支付系统提供，供业务方调用；</li><li>通知接口由业务方提供，供支付系统调用；</li><li>虽然通知接口由业务方提供，但是仍由支付系统制定接口规范；</li><li>服务接口包括接口说明中的所有接口信息，通知接口目前仅包括交易状态和退款状态的通知等。</li></ul><h3 id="接口设计说明"><a href="#接口设计说明" class="headerlink" title="接口设计说明"></a>接口设计说明</h3><ul><li><strong>基本请求接口</strong>：所有请求接口都要加上基本请求参数，例如接口名称、版本、App ID、签名、签名方式、同步跳转地址等关键信息，当发起调用时，所有业务接口都会加上该接口参数，可参考支付宝和微信等第三方支付公司的接口参数定义。</li><li><strong>服务请求接口</strong>：根据支付系统本身的能力抽象出的业务接口，给到外部业务方进行调用。</li><li><strong>即时到账交易网关接口</strong>：买家在业务系统中选择购买商品下单，付款成功后金额直接入卖家账户。</li><li><strong>担保交易网关接口</strong>：买家在业务系统中选择购买商品下单，有部分金额为担保金额，买家付款成功后，担保部分进入平台方账户，未担保金额直接入卖家账户。</li><li><strong>结算（分账）网关接口</strong>：买家使用担保交易下单付款完成，在收到货物后，将担保金额结算给卖家。</li><li><strong>继续支付网关接口</strong>：买家在支付页面未成功支付，需要在业务系统中继续支付时，调用该接口。</li><li><strong>退款网关接口</strong>：买卖双方在达成退款协议后，可针对及时到账交易，订金下定等已支付交易 由业务系统发起退款请求。</li><li><strong>交易查询网关接口</strong>：因为某一方原因， 可能导致业务方在预期时间内都收不到最终支付通知， 此时业务方可以通过该接口来查询订单的详细支付状态。</li><li><strong>通知接口</strong>：根据业务方提供的通知地址，将支付结果等信息返回给业务方</li></ul><p><strong>①交易状态变更通知</strong>：通知业务方时，接口信息里面会传递业务订单号、交易订单号、状态、金额、时间等相关信息，以便业务方能更好的做业务处理；</p><p><strong>a.交易状态</strong>：交易订单的状态；</p><ol><li>等待买家付款</li><li>付款成功</li><li>交易成功</li><li>交易结束</li><li>交易关闭</li></ol><p><strong>②退款状态变更通知</strong>：通知业务方时，接口信息里面会传递原始业务订单号、退款业务订单号、退款交易订单号、状态、金额、时间等相关信息，以便业务方能更好的做业务处理；</p><p><strong>a.退款状态</strong>：退款订单的状态；</p><ol><li>退款成功</li><li>退款失败</li></ol><h2 id="交易服务"><a href="#交易服务" class="headerlink" title="交易服务"></a>交易服务</h2><h3 id="交易服务的作用"><a href="#交易服务的作用" class="headerlink" title="交易服务的作用"></a>交易服务的作用</h3><ul><li>将支付系统的支付能力抽象出来，提供各类交易方式，例如下单、支付、修改金额、确认结算、退款、关闭交易、查询等标准接口，对外输出收单网关；</li><li>基于收付款方的交易链业务路抽象交易类型、交易产品以满足不同业务方各类交易场景的需求；</li><li>鉴权校验、交易结果通知；</li><li>对接业务方。</li></ul><h3 id="担保收单交易"><a href="#担保收单交易" class="headerlink" title="担保收单交易"></a>担保收单交易</h3><p><strong>①担保交易</strong>：用户在业务平台中选择某商家的商品进行购买，支付完成后该笔订单资金进入平台的担保账户，等到用户确认收货后，将该笔订单的资金结算给对应商家账户；此交易类型也可以适用于一些具备结算周期等时间属性的业务当中，通过网关的担保收单接口和结算接口做到由业务方灵活控制结算账期。<br><strong>②流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/DHyJe6XJpZzU5SSZksVE.png" alt="img"></p><p><strong>③担保交易设计</strong></p><p>定义担保交易产品代码，标识此类交易订单的类型。担保交易分为下单支付和结算两个环节：</p><ul><li>第一个环节为下单环节，交易参与双方当中付款人是用户，收款人则是平台在支付系统内部开设的一个担保账户，担保账户属于内部的一个结算过渡户，代表着这钱是要给出去的，时候时候给出去基于业务方的指令来决定。</li><li>第二个环节在发起结算的时候，确认之前这笔担保交易订单需要和商户进行最终结算，此时基于业务方调用结算接口，交易参与双方当中新增两条收付款人记录，付款人为担保账户，收款人为该笔订单的商户；最终资金以内部户转账的形式将担保账户中该笔订单资金，转给实际收款的商户账户。</li></ul><h3 id="即时到账交易"><a href="#即时到账交易" class="headerlink" title="即时到账交易"></a>即时到账交易</h3><p>即时到账交易即用户在平台上选择商品购买并支付，付款的资金立马结算到商家的收款账户中。</p><p>例如，早期支付宝 PC 端的即时到账产品，用户通过 PC 网银即时到账产品付款后，单笔交易即时结算到了商户的平台账户中，由此可得：</p><ul><li>若支付宝不垫资，则即时到账底层包装接口的银行为 T+0 给到支付宝；</li><li>若支付宝垫资，则银行资金未结算前，支付宝将备付金账户中的存量资金为商户的平台账户进行结算。</li></ul><p>即时到账交易与业务场景息息相关，在某些非担保流程中，若用户付款后需要立马进行履约的情况，则适合即时到账产品，例如各平台的会员产品购买场景。</p><p><strong>①流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/hhqEL8tqWMlELiuENOmu.png" alt="img"></p><p><strong>②即时到账的设计要点</strong>：</p><ul><li>定义担保交易产品代码，标识此类交易订单的类型；</li><li>和担保收单的区别，在于即时到账产品没有单独的结算环节；在下单的时候，接口参数里包含分润参数，当交易发起时就需要业务方算出该笔订单分润收款主题数、确定好用户的 UID（给谁充值）、账户类型（给什么账户充值）、金额等参数；</li><li>分润原则：先收钱再分钱且收到金额 ≥ 分润总金额，即先入后出、收大于等于付。</li></ul><h3 id="充值交易"><a href="#充值交易" class="headerlink" title="充值交易"></a>充值交易</h3><p>充值交易即用户对账户余额进行充值，一般运用于充值虚拟币、钱包余额等产品。用户对账户余额进行充值，一般运用于充值虚拟币、钱包等产品，首先需要对充值的两种做法做一个区分。</p><ul><li>业务平台充值</li><li>支付平台充值</li></ul><p>例如，在用户感知层面，早期的支付宝与淘宝不分你我，支付宝像是为淘宝定制的专属钱包，但实际上用户在支付宝充值的余额与淘宝业务并无关联；而腾讯的虚拟货币 Q 币则是由业务端发起的交易，因此与业务平台具有强关联性。因此基于支付平台的两种做法，一种是基于支付平台的账户做充值，另一种是基于业务平台做充值。</p><p><strong>①流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/KQUiknRCSzdfDHWMqhMz.png" alt="img"></p><p><strong>②充值交易的设计要点：</strong></p><ul><li>首先定义充值产品的产品代码；</li><li>业务端充值（虚拟币）：此类产品虚币账户体系独立于支付系统；</li></ul><ol><li>充值和虚拟币的消费业务端完全闭环，由支付系统内部针对该充值业务开设一个统一的收款账户，结算时通过支付系统提供的入账记资金分润，适用于直播、视频等纯互联网虚拟业务；</li><li>接口定义：下单支付接口；</li><li>优势：开发成本低，实现起来相对简单、可快速实现业务；</li><li>劣势：账务不清晰，流程不统一、有一定资金风险。</li></ol><ul><li>支付系统充值：通过支付系统账户体系实现，所有充值资金通过钱包收银台或支付系统的充值网关接口实现；</li></ul><ol><li>钱包收银台：充值行为发生在支付系统体系内（参考前文中讲到的支付宝逻辑）且独立于业务平台。原则上当公司业务规模扩大，不同的 App 统一接入支付系统时，独立的钱包账户余额应可同时支持不同业务的账户支付需求。例如，美团账户余额充值的资金同时适用于美团外卖、点评等，此时美团的钱包已经是拥有独立账户体系的产品，接入各业务平台仅需不同业务端识别用户的唯一标识即可；</li><li>充值网关接口：针对于业务方发起的充值行为，各个业务平台自己本身具备充值业务需要支付体系的账户能力提供支持。通过网关充值（入口在业务端）且可以满足各个业务方不同账户类型的诉求，需要每个业务方在用户发起充值时，充值至用户在此业务下开设的对应虚拟账户，例如 B 站的 B 币、金瓜子等，就来源于不同的业务方开设的不同虚币账户；</li><li>接口定义：充值接口（账户类型、uid、金额、支付方式等）；</li><li>优势：资金账户清晰、流程标准化、所有支付、账户由支付系统控制，资金安全有一定保证；</li><li>劣势：开发成本高，实现起来相对复杂。</li></ol><h3 id="出款交易"><a href="#出款交易" class="headerlink" title="出款交易"></a>出款交易</h3><p>出款也称之为<strong>提现。</strong>用户基于自己账户余额发起提现，一般电商平台涉及到的场景为 C端用户的钱包账户余额提现和B端用户收益账户的余额提现，是将资金从平台的虚币账户转移用户外部账户的过程。具体分类可分为出款到卡及出款到账户。<br><strong>①流程</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/rVhpwYDNHrdS4YcxWDTd.png" alt="img"></p><p><strong>②出款交易的设计要点：</strong><br>定义产品码，可以拆分为<strong>出款到卡</strong>和<strong>出款到账户</strong>等不同的产品，针对 B 端商户的提现交易记录，原则上最好单独用表单显示；按照流程图所示，提现时首选要做好余额校验动作；</p><ol><li><strong>出款到账户</strong>：目前常见的场景为用户发起提现到支付宝或者微信账户，接入支付宝微信等第三方支付公司的付款产品即可满足此需求，业务端需做好用户端的第三方账号信息采集，用户发起提现的时将账户等相关信息上传至第三方等待出款结果即可；根据业务模式，针对 B 端商户提现时，优先做实名认证再发起提现，且发起提现的账户信息和实名认证信息一致为佳，再根据业务端需求判断是否有针对 C 端用户做实名认证处理的必要；</li><li><strong>出款到卡</strong>：和付款到账户的主流程没有太大区别，但一般情况下需要商户端采集用户银行卡信息，因此需要将支付系统中存储银行卡相关的数据（卡 Bin 信息、城市、省份等），并对业务 端提供绑定、查询等接口为佳，这样用户前端绑卡时无论是卡 Bin 接口验证，还是前端做选择输入银行都能拥有较好的体验。*提现到银行卡需要接入对应的银行卡出款渠道。</li></ol><h2 id="支付系统设计白皮书：会员（客户）系统设计思路"><a href="#支付系统设计白皮书：会员（客户）系统设计思路" class="headerlink" title="支付系统设计白皮书：会员（客户）系统设计思路"></a>支付系统设计白皮书：会员（客户）系统设计思路</h2><p>客户系统分为内部客户与外部客户两种，内部客户是指集团内部的公司或个人，外部客户则是使用平台服务且与集团无关的外部公司或者个人。</p><h2 id="客户类型："><a href="#客户类型：" class="headerlink" title="客户类型："></a>客户类型：</h2><p>分为内部客户与外部客户两种类型：</p><p><strong>内部客户</strong>：集团内部的公司或个人。以阿里巴巴集团为例，不同业务线包含众多子公司，根据集团战略需要统一接入支付宝，这种情况下内部公司的接入在支付宝系统时一般会定义为内部客户，此类客户和外部客户之间会有一定的差异化服务，在一些风险、服务以及产品层面均会作出一定的调整；</p><p><strong>外部客户</strong>：使用平台服务且与集团无关的外部公司或者个人。以支付宝举例，喜马拉雅接入了支付宝，对于支付宝来说即外部客户，因为接入了支付宝所以可以使用支付宝的部分功能。</p><p>不同类型的客户，需要在平台端做差异化处理。以阿里集团举例，支付宝正常情况下一些风险程度较高的产品或服务，外部客户申请的门槛应远高于内部客户，甚至内部客户可以接入一些不对外的功能。</p><ul><li><strong>风控维度</strong>：集团体系内的业务团队申请成为内部客户后，申请使用支付平台能力时一些风控的规则策略可以降低，甚至白名单通过，例如接口限制、风险操作等；</li><li><strong>产品维度</strong>：部分不对外部客户调用的产品，内部客户可随意接入，例如代扣接口、下单并确认支付接口、批量扣款、冻结等。</li></ul><h2 id="客户性质"><a href="#客户性质" class="headerlink" title="客户性质"></a>客户性质</h2><p><strong>企业客户</strong>：以<strong>公司机构类型</strong>注册成为支付平台的用户被定义为企业客户，原则上当一个企业客户具备收单条件并接入了对应支付产品后，则默认成为商户，例如某电商公司为接入支付，注册成为了支付宝的企业账户并开通收款功能，这时候即可将该电商平台定义为支付宝的收单商户。</p><p><strong>企业客户关键字段：会员ID、三证一照、法人信息、企业名称、商户信息（产品权限、接口权限）；</strong></p><p><strong>个人客户</strong>：以<strong>个人类型</strong>注册成为支付平台的用户被定义为个人客户，一个用户仅拥有一个会员ID，一般在电商平台，C端用户注时会同步一个UID 到支付系统内部的会员系统，同时开通一个支付会员，且对应开通一个基本账户，便于后期发展钱包业务。</p><p><strong>个人客户关键字段：会员 ID、姓名、证件类型、证件号。</strong></p><h2 id="客户与账户"><a href="#客户与账户" class="headerlink" title="客户与账户"></a>客户与账户</h2><p>一个会员可以拥有多个支付账户，账户是会员资金相关信息存放的载体，真实金额存放于账户系统中，会员系统是账户系统对外展示的窗口，在会员系统内对账户进行接口调用，直接透传相关的请求到账户系统，然后将信息返回调用方。</p><p><strong>会员账户类型定义</strong>：配置相关信息存放在账户配置表，只有在配置表中存在的账户类型支持开户操作，此处的账户类型需与储值系统中的匹配一致。</p><p><img src="http://image.woshipm.com/wp-files/2019/03/grX7OTu649zwypezIRIP.png" alt="img"></p><p>会员和账户关联信息存放在会员账户信息关联表当中：</p><p><img src="http://image.woshipm.com/wp-files/2019/03/7CtC6olIK3ggQYzMk9o4.png" alt="img"><br><strong>核心业务逻辑：</strong></p><ol><li>一个会员可以拥有多个支付账户；</li><li>一个支付账户只属于一个会员；</li><li>会员可以是个人或者企业（机构账户）；</li><li>一个企业会员可以拥有多个操作员；</li><li>一个企业会员至少拥有一个操作员；</li><li>操作员的创建必须依赖于企业会员；</li><li>一个操作员只能归属于一个企业会员；</li><li>开通会员账户时创建账户；</li><li>账户可以开设多个，基本户有且只有1个；</li><li>一个企业会员可以拥有多个商户，企业会员默认成为商户。</li></ol><p><strong>会员系统模型：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/qyfXhELWJsgofQz8FZER.png" alt="img"></p><p>①商户：包含商户编号、商户名称以及商户类型；</p><p>②会员：会员编号、会员标识列表、会员名称以及登入状态；</p><p>③账户：与会员模块平级，包含会员编号、账户类型、账户号、金额以及账户状态；</p><p>④（个人）会员信息：包含个人信息；</p><p>⑤企业会员：除基本信息外需要补充企业资质信息；</p><p>⑥支付密码：属于账户下级模块，包含操作员编号、账户号以及支付密码；</p><p>⑦银行卡：属于会员下级模块，包含会员编号、银行卡卡号、银行编码、银行卡属性、银行卡类型、持卡人姓名以及会员姓名；</p><p>⑧认证信息：属于会员下级模块，包含会员号、认证实体、认证类型、认证时间以及认证状态。</p><p><strong>会员基本信息：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/aUANNIEjcAC3ld9QT16E.png" alt="img"></p><p>会员基本信息中需含有以下模块：</p><p><strong>①会员类型</strong>：</p><ol><li>个人会员：包含基本要素即可：姓名、性别、职业、只为、生日等；</li><li>企业会员：需对企业认证，因此需要具备关键要素：公司名称、公司地址、营业执照号、营业执照所在地、组织机构代码、税号、公司简介、法人姓名、法人身份证号、法人联系方式、联系人姓名、联系人电话、行业类型、营业执照过期时间、企业编号、规模等等。</li></ol><p><strong>②会员状态</strong>：【未激活：0 】、【正常：1 】、【休眠：2 】、【注销：3 】。</p><p><strong>③锁定状态</strong>：【未锁定：0 】、【已锁定：1 】。</p><p><strong>④会员认证信息：</strong></p><ol><li>认证类型：包含身份证、手机、邮箱三种主流认证方式。</li><li>认证渠道</li></ol><p><strong>开户流程：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/03/7heb6Qfw6nlqphX5fD3j.png" alt="img"></p><p>会员开户的流程，无论企业用户还是个人用户，底层逻辑是想通的：</p><p>①会员创建会员，进入会员系统层；</p><p>②填写基本信息后，在会员系统层进行保存；</p><p>③系统创建储值账户，进入账户系统层；</p><p>④账户系统返回 account ID 到会员系统层进行对应；</p><p>⑤会员系统对会员账户关系进行保存；</p><p>⑥返回 member ID、account ID 选择性对会员进行展示。</p><h2 id="支付系统设计白皮书：支付核心的-7-个要点"><a href="#支付系统设计白皮书：支付核心的-7-个要点" class="headerlink" title="支付系统设计白皮书：支付核心的 7 个要点"></a>支付系统设计白皮书：支付核心的 7 个要点</h2><h2 id="一、支付前置"><a href="#一、支付前置" class="headerlink" title="一、支付前置"></a>一、支付前置</h2><p>着业务定制化对交易支付需求复杂度的增加，交易系统保证系统稳定的同时，亦需灵活性以支持业务。但系统设计时，灵活和稳定是矛盾的，稳定意味着剥离变化，灵活意味着可配置化。</p><p>支付前置的职责即：解决支持业务变化的扩展性，将交易通过支付前置的配置转化为后端支付系统能统一处理的模式，方便后端多样化的记账需求。</p><p><strong>支付前置的定义</strong></p><ul><li>支付前置包装后端支付核心系统的接口，包装后对外提供的服务包括余额、 现金、网银、快捷支付、出款及相关订单的退款和控制接口；另提供后台系统调用的服务包括确定性入款、登账、冻结解冻、退票等，所有的支付行为都会以业务支付订单的形式落地；</li><li>用户在前端发起一次支付行为后，交易系统基于原始的交易订单，对应生成一条付款订单，通过这笔付款订单和支付核心进行交互。</li></ul><p><strong>业务产品码：</strong></p><p>交易系统各类交易接口包装成业务产品（提现、充值等）后，将对应的支付请求发送到支付前置系统，前置系统根据业务产品编码和本身的支付业务配置关系，生成对应的业务支付订单并处理后续流程。</p><p><strong>支付产品码：</strong></p><p>由于即时到账、担保交易在业务规则上不同，但支付渠道侧判断均为支付，因此支付产品码相同，但业务产品码不同。这里的支付产品编码配置来自于支付协议的配置，一个支付产品编码代表着一个支付协议。</p><h2 id="二、支付协议"><a href="#二、支付协议" class="headerlink" title="二、支付协议"></a>二、支付协议</h2><p><strong>支付协议即对支付模式、支付服务的封装。</strong></p><p>以收单支付为例，某个业务方在支付系统开设支付权限后，可理解为与支付系统本身签署了收单支付协议，即可通过交易系统对外输出担保交易产品、即时到账产品来使用收单支付的能力。</p><p>此时交易侧定义的两个业务产品码，与支付侧的收单支付产品编码为多对一关系，交易系统调用前置系统时，根据交易产品代码和支付协议的配置，对应生成一条收单支付的请求，前置系统根据该请求转化为对应的付款订单（支付协议的明细项，比如通过网银、现金、快捷等方式发起支付），然后根据对应支付模式、业务支付类型生成业务支付订单，且将业务支付订单转化为支付指令去执行下游系统的流程。</p><p><strong>提现协议：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/04/vkhHsx2dbdbYUsFgG81W.png" alt="img"></p><ol><li>以秋秋老师的提现协议为例，提现的明细项关联着业务方所传递的外部订单号，代表着这次业务支付行为的原始订单请求，对应着收付款人的信息；</li><li>调用支付服务层的时，会有客户权限校验等判断，通过的情况下此时去调用支付协议的配置信息落地一笔支付订单，并基于该订单生成对应的一笔或者多笔支付指令，接下来由指令去执行调用下游系统的具体方式，若是调用清算通道则生成清算类的操作指令（调用通道，调用时间，通道需要的信息等），可称为外部指令，若是要操作账户金额则生成账务类的操作指令（具体账户、金额、借记还是贷记），可称为内部指令。</li></ol><h2 id="三、支付引擎"><a href="#三、支付引擎" class="headerlink" title="三、支付引擎"></a>三、支付引擎</h2><h3 id="1-支付引擎的类型"><a href="#1-支付引擎的类型" class="headerlink" title="1. 支付引擎的类型"></a>1. 支付引擎的类型</h3><p>定义支付的原子级支付形态，所有的支付行为都是账户资金的流转，可梳理出以下几个支付类型：</p><ul><li><strong>充值</strong>：资金从外部资金源向内部资金源转移的支付动作；</li><li><strong>提现</strong>：资金从内部向外部资金源转移的支付动作；</li><li><strong>内转支付（转账）</strong>：资金在内部账户转移的支付动作，这里的定义和产品中定义的转账概念不同；</li><li><strong>退款</strong>：充值的反向操作。</li></ul><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h3><p>指令即支付核心的工单号，前置的每笔支付订单对应着一笔甚至多笔指令。指令里包含了这笔支付订单是原始支付类型（充值、提现、转账、退款，指令一定是基于原始支付类型来生成的，任何支付行为都能被原子类型所支持），对应着的业务请求类型、支付方式、支付产品编码、参与方信息（交易中收付款人的信息）、相关联的支付指令信息（退款时用于关联原支付指令）、支付服务流程等相关信息；由支付指令去调用支付服务流程时，再根据流程编排环节去确定何时生成账务类操作指令和清算类操作指令。</p><p>举例：用户在电商网站购买一本书价格 100 元，通过支付宝付款，交易类型为担保交易，在交易核心生成一笔担保支付的订单，调用支付核心系统时支付系统判断该业务调用方对应已经配置了「收单支付协议」，且根据对应协议生成一笔业务类型为第三方支付的支付订单，基于此订单生成了第一条充值的支付指令。</p><p>该指令在根据支付类型去调用服务流程时，先通过流程编排生成清算指令并调用（这里值得注意的是，先生成清算指令的原因在于需要先调用外部支付渠道，把钱收进来），用户付款成功后再生成账务指令并调用账务核心，执行内部账务入账。</p><h3 id="3-服务流程"><a href="#3-服务流程" class="headerlink" title="3. 服务流程"></a>3. 服务流程</h3><p>定义支付指令的执行流程，将支付拆分成原子级支付类型，并对支付类型的流程进行编排，任何一个交易的请求，都能被上述四种基础支付类型组合进而完成支付行为。</p><p>例如：一笔担保收单的交易，用户用支付宝等第三方支付完成了这笔交易，并在 7 天后确认收货，平台侧 7 天后根据用户的行为应该将该笔货款打给了商户。</p><p>这里我们将用户的行为分为<strong>支付</strong>和<strong>确认收货</strong>两个动作，对应着在交易侧这也是两次请求，一次支付，一次结算：</p><ul><li>在支付层对应收单支付协议；</li><li>在前置系统被拆分成了两笔业务支付订单，一笔是快捷支付（业务类型，类型自定义，可以叫第三方支付），一笔是余额转账（将资金从担保账户结算到商家账户）；</li></ul><p>而后分别生成两条支付指令（充值和转账），充值代表着用户的支行为，转账代表着用户的确认收货行为，因为从但保护结算到商家账户，可以定义为这是一笔账户之间的资金扭转。</p><h2 id="四、风控"><a href="#四、风控" class="headerlink" title="四、风控"></a>四、风控</h2><p>风控是风险交易防范与控制的简称。支付系统设计中，提升自身的风控意识，在必要时为交易增加风控模块，可以有效减少风险交易造成的资金损失。支付核心的风控模块，一般位于交易处理的最前端，每笔交易通过风控模块的检验后，才允许支付核心进行后续的交易处理。</p><p>是否设置风控模块，需要评价投入产出比。当支付系统内积累了一定量风险交易数据，并且已经产生实际经济损失的情况下，则需考虑在支付系统内设置风控模块。</p><h3 id="1-业务规则"><a href="#1-业务规则" class="headerlink" title="1. 业务规则"></a>1. 业务规则</h3><p>为支付核心设计交易流程和业务规则时，了解交易中可能发现的风险因素并注意异常环节，是拦截风险交易的有效途径。对于一些常见的支付产品设计中，已经形成了一些能够有效防范风险交易的通用业务规则。</p><p><strong>余额账户：</strong></p><p>用户使用余额账户进行首次充值时，必须通过账户信息的实名认证。由于用户在银行办理银行卡时，银行一定会对持卡人的身份进行实名认证，所以对平台余额账户使用者可以通过利用银行或支付机构提供的银行卡信息验证接口，对用户进行实名认证。</p><ul><li>进行实名认证时，需要验证姓名、身份证号、银行卡号、手机号；完成实名认证后，用户必须设置支付密码，后续自消费和提现时，就可以使用支付密码保证余额资金的安全。</li><li>用户更换余额账户提现银行卡时，必须对已绑定的银行卡进行进行校验，要求用户输入已绑定银行的完整账号和绑定手机号；同时新绑定的提现银行卡，也必须和账户已验证的身份信息一致。</li></ul><p>以上措施，可有效防止用户个人信息泄漏造成的余额账户资金损失。</p><h3 id="2-风控模型"><a href="#2-风控模型" class="headerlink" title="2. 风控模型"></a>2. 风控模型</h3><p>风控模型，是依赖可获取的交易信息和客户信息，抽象出的风险交易特征。可用于抽象分析风险交易特征的主要有三类：</p><ol><li><strong>交易信息</strong>：该笔交易自身的信息要素，例如交易类型、交易金额、交易时间、支付账号等信息；</li><li><strong>客户信息</strong>：发起该笔交易的平台用户信息，包括用户使用的设备类型、设备编号、用户定位信息、用户手机号、手机号归属地等；</li><li><strong>历史数据</strong>：用户在平台发生过历史交易，其历史交易的交易信息和用户信息。</li></ol><p>通过对已发生的风险交易，分析上述信息即可抽象出风控模型，供风控模块识别风险交易。</p><h3 id="3-风控运营"><a href="#3-风控运营" class="headerlink" title="3. 风控运营"></a>3. 风控运营</h3><p>对于风控模块识别出的风险交易，根据危害程度的等级不同，分为「事前拦截」和「事中审核」两种处理机制。</p><ul><li>对于明确一定属于风险交易的交易请求，采用事前拦截的处理机制，支付核心收到后，由风控模块直接拒绝交易。</li><li>对于无法确认是否属于风险交易的，进入风控模块的待审核交易列表，由风控专员对可疑交易进行人工审核。审核后认为是风险交易的，则拒绝交易；审核后不属于风险交易的，由支付核心继续后续的交易处理。</li></ul><h2 id="五、内部控台"><a href="#五、内部控台" class="headerlink" title="五、内部控台"></a>五、内部控台</h2><p>支付核心需要为内部的运营、财务、管理层，提供查看交易数据的可视化管理网站。</p><h3 id="1-交易操作"><a href="#1-交易操作" class="headerlink" title="1. 交易操作"></a><strong>1. 交易操作</strong></h3><ul><li>业务运营人员，需要对支付系统中已经发生的交易进行检索，确认某一具体交易的交易状态；</li><li>对于某一笔具体交易，进行退款操作；</li><li>内部控台要为业务运营人员提供交易操作入口。</li></ul><h3 id="2-交易数据展示"><a href="#2-交易数据展示" class="headerlink" title="2. 交易数据展示"></a><strong>2. 交易数据展示</strong></h3><p>管理层希望了解整个平台的业务运作情况，支付系统通过内部控台提供交易总额、订单转化率、支付渠道占比等可视化的数据图表，直观展示交易数据的变化情况。</p><h3 id="3-报表下载"><a href="#3-报表下载" class="headerlink" title="3. 报表下载"></a><strong>3. 报表下载</strong></h3><p>将历史交易数据整理为交易报表，供相关人员以下载的方式直接获取。</p><h3 id="4-权限控制"><a href="#4-权限控制" class="headerlink" title="4. 权限控制"></a><strong>4. 权限控制</strong></h3><p>支付系统的交易数据属于敏感信息。首先，内部控台要限制仅可以通过公司内网访问，并控制可以查看数据的人员数量，具有数据查看权限的人员，需要对数据安全和资金安全负责；其次，和用户有关的卡号、姓名等信息，要做脱敏显示，预防泄露用户信息。</p><h2 id="六、报表"><a href="#六、报表" class="headerlink" title="六、报表"></a>六、报表</h2><p>支付系统负责将交易数据，定期整理为报表，供有关人员下载使用。</p><h3 id="1-交易报表"><a href="#1-交易报表" class="headerlink" title="1. 交易报表"></a>1. 交易报表</h3><p>按照固定的时间周期，将支付系统中已成功处理的交易流水，生成交易报表。交易报表展示的交易流水，需要按照交易系统支持的交易服务类型，分别生成交易报表。</p><p>支付交易、充值交易、出款交易，在交易数据信息上各不相同，需要分别出具独立的交易报表；一般按照日、周、月为时间维度，固定出具交易报表；交易报表中除了提供交易流水明细，还需要提供该时间周期内的汇总数据，方便使用者快速了解这个时间段内的交易情况。</p><p><strong>交易报表的结构关系为：</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/04/7e9pkHzZ4m6Sh9uLf4on.png" alt="img"></p><h3 id="2-结算报表"><a href="#2-结算报表" class="headerlink" title="2. 结算报表"></a>2. 结算报表</h3><p>支付系统的清算核心对账户中资金进行结算时，生成结算报表，供运营或财务进行付款前的确认或者作为付款凭证作为后续查账、审核的依据。结算报表的属于来自于清算核心提供的结算数据，面向内部人员使用的结算报表可以根据本系统的业务需求，增加其他信息字段，更好的了解结算交易信息。</p><h3 id="3-财务报表"><a href="#3-财务报表" class="headerlink" title="3. 财务报表"></a>3. 财务报表</h3><p>账务核心分账户来管理资金，账户记录了所属会计科目和账务记录，账务记录标明了账户的资金收支情况。按照公司的财务报表编制期间需求，对同一类会计科目的账户，分别统计该报表编制期间内收入和支出金额，生成财务报表。</p><h2 id="七、交易监控"><a href="#七、交易监控" class="headerlink" title="七、交易监控"></a>七、交易监控</h2><p>支付系统的稳定性十分重要，一旦因为故障出现交易中断，会对整个平台的收入造成重大影响。</p><ul><li>监控支付渠道的交易稳定性：支付系统对接的外部渠道，监控支付渠道的<strong>接口响应时间</strong>和<strong>成功交易占比</strong>这两个重要指标，来监控支付渠道的稳定性。</li><li>监控支付核心处理交易的稳定性：主要监控支付核心处理交易的平均时间，保证支付系统的稳定信息。</li></ul><p>交易监控中发现的异常告警，以短信、邮件等方式及时通知负责人员处理交易异常信息，尽早恢复交易。</p><h2 id="互联网平台资金结算的合规处理方案"><a href="#互联网平台资金结算的合规处理方案" class="headerlink" title="互联网平台资金结算的合规处理方案"></a>互联网平台资金结算的合规处理方案</h2><p>央行对于支付资金的监管逐步加强。银行支付机构也推出了像匹配的资金解散产品。新领域新办法新条例的出现，都是为了保护消费者的合法权益不被侵害；守法合规同样也是互联网平台类公司健康发展的必备条件。</p><p>那么作为企业我们需要做出哪些对应的动作和调整，让企业在发展的过程中，严格遵守国家法律法规呢？</p><h2 id="一、为何现在聚焦合规处理的话题"><a href="#一、为何现在聚焦合规处理的话题" class="headerlink" title="一、为何现在聚焦合规处理的话题"></a>一、为何现在聚焦合规处理的话题</h2><h3 id="1-监管政策"><a href="#1-监管政策" class="headerlink" title="1. 监管政策"></a>1. 监管政策</h3><p><strong>1 ) 人行加强支付结算领域监管</strong></p><p>2017年底开始，人行开始对线上互联网电商平台及线下集中收银模式的“二清+大商户”进行整顿。支付服务商为非法业务提供服务，支付服务商挪用商户待结算资金最后跑路。</p><p>持续开展互联网支付领域的反洗钱监管，打击非法支付交易。配合国家对整个项目社会问题的打击，关闭非法交易渠道。</p><p>关注资金安全风险，禁止平台私设不具有真实交易背景、不受金融机构管控的资金池。</p><p><strong>2 ）《电子商务法》公布，平台责任加大</strong></p><ol><li>提高平台合规及安全性、资金流转率和使用效率；</li><li>提升会员活跃度、会员粘性，保证业务持续增量；</li><li>基于数据层面延伸更多应用，成为众多电商平台发展中的瓶颈。</li></ol><h3 id="2-市场需求"><a href="#2-市场需求" class="headerlink" title="2. 市场需求"></a>2. 市场需求</h3><p>互联网平台既是信息撮合方，也是交易撮合方。既为买家和卖家提供交易信息的展示，也提供了收款服务并为卖家提供了服务的解决方案，平台方交易撮合会产生痛点。</p><p><img src="http://image.woshipm.com/wp-files/2019/09/LMBIS63e5bv3tH2Q94UM.png" alt="img"></p><p><strong>1 ）平台痛点</strong></p><p>平台方收款后，将交易资金二次结算给其他商户，对于央行公布的二清和大商户入了监管范围之内。</p><ol><li>非金融机构在收付款人之间作为中介机构提供货币资金转移服务需要取得第三方支付牌照 第三方支付机构；</li><li>违规“变相开展支付资金结算”，在业务合规方面的问题。</li></ol><p>子商户对平台代管资金缺乏信任</p><ol><li>平台方挪用商户资金，商户不能按时获取交易资金，造成商户资金损失；</li><li>平台方为交易双方提供担保，商户的交易资金在客户收货后延时到账 用户支付成功，商户发货，用户确认收货平台方把交易资金严实结算给作为卖家的商户的账号。</li></ol><p><strong>2 ）保障交易资金安全</strong></p><p>用户/子商户在银行有独立账户，管理自身资金</p><p><strong>3 ） 助力资金合规清算</strong></p><p>对接银行存管账户类产品，实现交易资金的合规清算</p><h2 id="二、什么样的业务场景需要关注资金结算的合规处理"><a href="#二、什么样的业务场景需要关注资金结算的合规处理" class="headerlink" title="二、什么样的业务场景需要关注资金结算的合规处理"></a>二、什么样的业务场景需要关注资金结算的合规处理</h2><h3 id="1-业务合作方待结算资金"><a href="#1-业务合作方待结算资金" class="headerlink" title="1. 业务合作方待结算资金"></a>1. 业务合作方待结算资金</h3><p><strong>电商平台——B2B2C——天猫京东</strong></p><p>平台为卖方入驻后，提供优质的附加服务，买方通过平台购买商品</p><p><strong>社会化分销——B2C2C——微商</strong></p><p>商户平台统筹货源、订单及售后，由代理进行推广销售；并根据代理等级进行统一结算分润。</p><p><strong>社交电商——S2B2C</strong></p><p>商户平台对接厂家统筹货源与售后，平台拓展流量、营销推广并获得代理收益。</p><h3 id="2-用户储值资金"><a href="#2-用户储值资金" class="headerlink" title="2. 用户储值资金"></a>2. 用户储值资金</h3><p><strong>充值</strong></p><p>用户在平台方提前缴纳部分资金，作为自身账户的储值资金，用于后续在平台上消费时使用。</p><p><strong>押金/保证金</strong></p><p>用户在使用服务前将押金/保证金进行冻结，服务使用完毕后进行扣款，并对自动解冻押金，或者将押金/保证金作为已付费金额，继续支付订单剩余金额。</p><h2 id="三、资金结算合规方案"><a href="#三、资金结算合规方案" class="headerlink" title="三、资金结算合规方案"></a>三、资金结算合规方案</h2><h3 id="1-银行——资金存管账户"><a href="#1-银行——资金存管账户" class="headerlink" title="1. 银行——资金存管账户"></a>1. 银行——资金存管账户</h3><p>平台在银行开立的资金存管账户，有实体账户和银行内部账户两种类型。</p><p><strong>1 ）实体账户</strong></p><p>以平台方公司名称在银行开立的存管账户，本质上属于客户的对公账户，只是在账户用途上，限定为存管账户（不能消费、转账等，只能接受支付渠道结算资金）。</p><p><img src="http://image.woshipm.com/wp-files/2019/09/2u6stXuraWaMHj8xE6ec.png" alt="img"></p><ol><li>平台方资金存管账户：与存管银行签约后开具，用于接受支付渠道结算的交易资金</li><li>附属虚拟账户：按交易实际参与方开立虚拟账户、中间户、自有资金账户</li><li>资金托管账户</li></ol><p>特点：</p><ol><li>收款：支持支付宝、微信、银联等多种支付方式进行收款</li><li>结算：资金结算至入驻商户虚拟户；提现时入驻商户银行卡中的付款方为平台公司名称</li><li>资金流水往来：平台收款资金及入驻商户结算资金，体现为平台对公户中的资金进出；如为入驻子商户的交易资金，需通过“代收/代付”科目进行记录；银行提供电子流水单，对资金结算记录提供证明</li></ol><p><strong>2 ）虚拟账户</strong></p><p>银行内部账户。平台方在银行开立，账户名义上归银行所有，但由客户掌握账户的实际使用权，用途限定为存管账户（不能消费、转账等，只能接受支付渠道结算资金并把资金下发给相应的业务参与方）</p><ol><li>平台方的虚拟户，是属于银行存管产品下的一个银行内部虚拟户；</li><li>平台方业务中的入驻商户和注册用户，当需要有资金通过存管产品进行管理时，入驻商户和注册用户会在平台方的存管账户虚拟户下，分别开立属于自己的虚拟户；</li><li>入驻商户和注册用户内的资金，按照平台方的交易指令进行资金管理，如充值、结算、提现等。</li></ol><p><img src="http://image.woshipm.com/wp-files/2019/09/ls9qoV3OYPzcQ4fyR0xK.jpg" alt="img"></p><p>特点：</p><ol><li>收款：支持支付宝、微信、银联等多种支付方式进行收款；一般使用本行支付通道</li><li>结算：资金结算至公司或个人的虚拟户；提现时，虚拟户绑定银行卡中的付款方为虚拟户所属的公司或个人自身，相当于自身两张银行卡间的转账</li><li>资金流水往来：平台收款资金 及 入驻商户结算资金，通过银行内部账户管理，平台对公账户不产生相关资金往来流水；仅平台收入部分，通过提现进入平台对公账户；银行提供电子流水单，对资金结算记录提供证明</li></ol><p><strong>3）存管账户资金</strong></p><p><img src="http://image.woshipm.com/wp-files/2019/09/zB3tUDAZchJJg7M46oP4.jpg" alt="img"></p><ol><li>支付渠道将交易资金结算到平台方的资金存管账户</li><li>交易资金进入待清算账户，等待平台方的结算指令后完成交易结算</li><li>资金存管账户按平台方指定的资金收款方，将交易资金结算到收款子商户虚拟账户</li><li>子商户通过平台方发起提现，将交易资金从存管账户提现到本人银行卡</li></ol><h3 id="2-支付机构——合单支付"><a href="#2-支付机构——合单支付" class="headerlink" title="2. 支付机构——合单支付"></a>2. 支付机构——合单支付</h3><p>平台方的注册用户、商户，授权支付机构通过平台方来进行统一收款。</p><ul><li>入网：参与订单结算的个人/公司，在支付机构完成商户资料提交，完成商户入网。</li><li>授权：已完成商户入网的结算方，向支付机构提交授权书，授权平台方代理自身向支付机构发起交易。</li><li>交易：平台方发起交易，交易中包含参与结算的用户、商户，用户一次性完成支付。</li><li>结算：支付机构按照交易中平台、用户、商户的收款金额，直接进行结算。</li></ul><p>适用场景：</p><ul><li>参与方相对固定，可以提供资质材料；</li><li>每笔交易发生前，平台已经明确订单参与方。</li></ul><h3 id="3-支付机构——订单分账"><a href="#3-支付机构——订单分账" class="headerlink" title="3. 支付机构——订单分账"></a>3. 支付机构——订单分账</h3><ul><li>收款商户的待结算资金，支付机构按照平台的业务规则，二次调整收款资金的归属</li><li>通常限定分账资金比例</li></ul><p><img src="http://image.woshipm.com/wp-files/2019/09/LyGCMv5HIxOJEkMvd9EM.jpg" alt="img"></p><p>适用场景：</p><ul><li>分账方总金额一般不大于订单金额的30%；</li><li>支付完成后，才能明确订单分账方。</li></ul><h2 id="四、如何选择合规处理方案"><a href="#四、如何选择合规处理方案" class="headerlink" title="四、如何选择合规处理方案"></a>四、如何选择合规处理方案</h2><p><img src="http://image.woshipm.com/wp-files/2019/09/FUhPHQ99HiPdXHWR7s0T.jpg" alt="img"></p><p><img src="http://image.woshipm.com/wp-files/2019/09/Xz04GhTz25ggzquBTb77.jpg" alt="img"></p><p>▲电商平台</p><p><img src="http://image.woshipm.com/wp-files/2019/09/N5F0Gchks3xqgdlFieIN.jpg" alt="img"></p><p>▲会员储值</p><h2 id="最全最强解析：支付宝钱包系统架构内部剖析（架构图）"><a href="#最全最强解析：支付宝钱包系统架构内部剖析（架构图）" class="headerlink" title="最全最强解析：支付宝钱包系统架构内部剖析（架构图）"></a>最全最强解析：支付宝钱包系统架构内部剖析（架构图）</h2><h3 id="支付宝系统架构概况"><a href="#支付宝系统架构概况" class="headerlink" title="支付宝系统架构概况"></a><strong>支付宝系统架构概况</strong></h3><h3 id="典型处理默认"><a href="#典型处理默认" class="headerlink" title="典型处理默认"></a><strong>典型处理默认</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112641.png" alt="QQ20150605112641"></p><h3 id="资金处理平台"><a href="#资金处理平台" class="headerlink" title="资金处理平台"></a><strong>资金处理平台</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112653.png" alt="QQ20150605112653"></p><h3 id="财务会计"><a href="#财务会计" class="headerlink" title="财务会计"></a><strong>财务会计</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112701.png" alt="QQ20150605112701"></p><h3 id="支付清算"><a href="#支付清算" class="headerlink" title="支付清算"></a><strong>支付清算</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112710.png" alt="QQ20150605112710"></p><h3 id="核算中心"><a href="#核算中心" class="headerlink" title="核算中心"></a><strong>核算中心</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112730.png" alt="QQ20150605112730"></p><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a><strong>交易</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112751.png" alt="QQ20150605112751"></p><h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a><strong>柔性事务</strong></h3><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112821.png" alt="QQ20150605112821"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112834.png" alt="QQ20150605112834"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112857.png" alt="QQ20150605112857"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112909.png" alt="QQ20150605112909"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112919.png" alt="QQ20150605112919"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112929.png" alt="QQ20150605112929"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112943.png" alt="QQ20150605112943"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605112954.png" alt="QQ20150605112954"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605113005.png" alt="QQ20150605113005"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605113016.png" alt="QQ20150605113016"></p><h3 id="支付宝的开源分布式消息中间件–Metamorphosis-MetaQ"><a href="#支付宝的开源分布式消息中间件–Metamorphosis-MetaQ" class="headerlink" title="支付宝的开源分布式消息中间件–Metamorphosis(MetaQ)"></a><strong>支付宝的开源分布式消息中间件–Metamorphosis(MetaQ)</strong></h3><p>Metamorphosis (MetaQ) 是一个高性能、高可用、可扩展的分布式消息中间件，类似于LinkedIn的Kafka，具有消息存储顺序写、吞吐量大和支持本地和XA事务等特性，适用 于大吞吐量、顺序消息、广播和日志数据传输等场景，在淘宝和支付宝有着广泛的应用，现已开源。</p><p>Metamorphosis是淘宝开源的一个Java消息中间件。关于消息中间件，你应该听说过JMS规范，以及一些开源实现，如ActiveMQ和HornetQ等。Metamorphosis也是其中之一。</p><p>Metamorphosis 的起源是我从对linkedin的开源MQ–现在转移到apache的kafka的学习开始的，这是一个设计很独特的MQ系统，它采用pull机制，而 不是一般MQ的push模型，它大量利用了zookeeper做服务发现和offset存储，它的设计理念我非常欣赏并赞同，强烈建议你阅读一下它的设计 文档，总体上说metamorphosis的设计跟它是完全一致的。但是为什么还需要meta呢？</p><h3 id="简单概括下我重新写出meta的原因："><a href="#简单概括下我重新写出meta的原因：" class="headerlink" title="简单概括下我重新写出meta的原因："></a><strong>简单概括下我重新写出meta的原因：</strong></h3><p>1.Kafka是scala写，我对scala不熟悉，并且kafka整个社区的发展太缓慢了。</p><p>2.有一些功能是kakfa没有实现，但是我们却需要：事务、多种offset存储、高可用方案(HA)等</p><p>3.Meta相对于kafka特有的一些功能：</p><ul><li>文本协议设计，非常透明，支持类似memcached stats的协议来监控broker</li><li>纯Java实现，从通讯到存储，从client到server都是重新实现。</li><li>提供事务支持，包括本地事务和XA分布式事务</li><li>支持HA复制，包括异步复制和同步复制，保证消息的可靠性</li><li>支持异步发送消息</li><li>消费消息失败，支持本地恢复</li><li>多种offset存储支持，数据库、磁盘、zookeeper，可自定义实现支持group commit，提升数据可靠性和吞吐量。</li><li>支持消息广播模式</li><li>一系列配套项目：python客户端、twitter storm的spout、tail4j等。</li></ul><p>因此meta相比于kafka的提升是巨大的。meta在淘宝和支付宝都得到了广泛应用，现在每天支付宝每天经由meta路由的消息达到120亿，淘宝也有每天也有上亿的消息量。</p><h3 id="Meta适合的应用"><a href="#Meta适合的应用" class="headerlink" title="Meta适合的应用"></a><strong>Meta适合的应用</strong></h3><ul><li>日志传输，高吞吐量的日志传输本来就是kafka的强项；</li><li>消息广播功能，如广播缓存配置失效；</li><li>数据的顺序同步功能，如mysql binlog复制；</li><li>分布式环境下（broker,producer,consumer都为集群）的消息路由，对顺序和可靠性有极高要求的场景；</li><li>作为一般MQ来使用的其他功能。</li></ul><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605113032.png" alt="QQ20150605113032"></p><p><img src="http://image.woshipm.com/wp-files/2015/06/QQ20150605113042.png" alt="QQ20150605113042"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;人人都是产品经理，读后感&amp;amp;摘抄&lt;/p&gt;</summary>
    
    
    
    <category term="文章摘抄" scheme="https://morningbells.github.io/categories/%E6%96%87%E7%AB%A0%E6%91%98%E6%8A%84/"/>
    
    
    <category term="支付系统" scheme="https://morningbells.github.io/tags/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="人人都是产品经理" scheme="https://morningbells.github.io/tags/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>支付方法论摘抄</title>
    <link href="https://morningbells.github.io/2021/10/06/%E6%94%AF%E4%BB%98%E6%96%B9%E6%B3%95%E8%AE%BA%E6%91%98%E6%8A%84/"/>
    <id>https://morningbells.github.io/2021/10/06/%E6%94%AF%E4%BB%98%E6%96%B9%E6%B3%95%E8%AE%BA%E6%91%98%E6%8A%84/</id>
    <published>2021-10-06T14:09:33.000Z</published>
    <updated>2021-11-17T08:35:46.278Z</updated>
    
    <content type="html"><![CDATA[<p>《支付方法论》王伟，读后感&amp;摘抄</p><span id="more"></span><p>支付架构、支付工具、支付核心、支付支撑服务、支付渠道接入、支付清结算</p><ol><li><p>支付是什么</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li><p>支付三原基：交易、清分(计算金额)、结算</p><ul><li>交易过程：生成支付口令、验证支付风险、确认支付方式/支付通道</li><li>清分过程：计算出债权人和债务人各自应收和应付。完成支付指令的交换，计算出待清偿的债权和债务，计算算费，确保账务信息数据准确，确保账务是平的。</li><li>结算过程：完结支付，只要双方确认了，进行资产交割和转移。确保债权债务信息完整，核对状态，确保结算资金可用</li></ul></li><li><p>支付体系：支付服务组织、支付系统、支付工具、支付体系监督</p><ul><li><p>支付服务组织：是支付工具和支付系统的提供者。可以提供清分和结算服务的支付清算组织。中央银行、银行业金融机构、支付清算组织</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211010233956994.png" alt="image-20211010233956994"></p></li><li><p>支付系统</p><ul><li>用来实现资金、债权、债务的清算。完成资金转移</li><li>组成部分<ul><li>大额实时支付系统：主要是解决各个省市人行之间的转账。</li><li>小额批量支付系统：仅限银行之间。延时性较高</li><li>商业银行行内系统：</li><li>票据支付系统</li><li>网上支付跨行清算系统（超级网银系统）：支持三方持牌公司接入系统。网银贷记业务、网银借记业务</li><li>银行卡支付系统</li><li>境内外币支付系统：为中国境内银行业金融机构及外币清算机构提供境内外币支付服务的实时全额支付系统，并规定了代理结算银行和各自代理结算币种。</li></ul></li></ul></li><li><p>支付工具：</p><ul><li>狭义上指的是支付方式：现金支付，借记卡，贷记卡，汇票，网银支付</li><li>广义上：卡类支付、IVR支付、手机支付</li></ul></li><li><p>支付体系监管：</p><ul><li>支付体系的法规制度</li><li>政府及行业的有效监督管理</li></ul></li></ul></li><li><p>支付架构</p><ul><li><p>支付场景，支付网关，支付产品，支付路由，营销活动，订单系统，分账系统，清算核心，支撑服务(mns,数据统计，监控，告警)，</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211116102811176.png" alt="image-20211116102811176"></p></li></ul></li><li><p>支付的基础名词：</p><ul><li><p>T+1：T是交易（Trade）的意思。交易日通常都是工作日，因此T+1一般用于指工作日，比如股市T日交易，T+1资金交割。在支付里，需要确定结算是T+1日结算还是D+1日结算，如果是T+1日结算，一般星期五发生的交易，需要到下周一结算到账。</p></li><li><p>D+1：D是日（Day）的意思。D+1指自然日，比如一个月30天，那么就是30个自然日。在支付里，如果是D+1日结算，一般星期五发生的交易，星期六会结算到账。</p></li><li><p>全额结算（Gross Settlement）：对交易的已收资金进行全数结算、划拨，不扣除费用。比如老王托老李帮忙卖东西，老李卖了100元，给了老王100元，这就是全额结算。至于老王要不要请老李吃饭，那是后话。</p></li><li><p>净额结算（Net Settlement）：对交易的已收资金先扣除手续费再进行结算、划拨；或者双方互有买卖，先对各自应收应付资金进行抵扣再进行结算。比如老王托老李帮忙卖东西，事先约好辛苦费10元钱，老李卖了100元，扣除辛苦费，给了老王90元，这就是净额结算。又或者老王卖给老李100元东西，老李卖给老王90元的东西，两人算了算，互相冲抵，老李给老王10元钱就好了，这是第二种情况。</p></li><li><p>日切：日切两个字拆开就是日子和切换，所以日切就是指上一个工作日结束的时间点。比如我们说日切时间是每天24点，一般不特别说明，下一工作日就是次日0点之后。交易的数据、给出的对账单数据等是以0点至24点为一个统计日的，0点以后的交易对账单就要到下一个工作日才会给出。0点比较好理解，举个非0点的例子，日切时间是16点，比如14日15点的交易，15日会给出数据；14日17点的数据，因为过了当日的日切时间，就要到16日才会给出数据。就跟老王开店一样，开的是个24小时营业的便利店，22点统计好当日流水，那么日切时间就是22点，23点的数据就要到次日再统计了。</p></li><li><p>头寸：头寸，其实就是指款项的意思。</p></li><li><p>头寸松与头寸紧：头寸是款项的意思，也就是钱的意思。头寸松也叫多头寸，就是钱松、钱多的意思，代表资金的需求量小于闲置量。头寸紧也叫缺头寸，就是钱紧、钱少的意思，代表资金的需求量大于闲置量。二者就像我们平时常说的手头松、手头紧一样</p></li><li><p>轧头寸：预测头寸的宽松还是紧缺的行为叫作“轧头寸”。就跟每天做生意一样，需要收银柜台准备零钱，太多太少都不合适，需要根据以前的经验推断应该准备多少。</p></li><li><p>轧差：互相抵消债权和债务后的净金额，叫作轧差。就像老王和老李之间做生意，老王卖了老李6000元钱的货，老李卖了老王5000元钱的货，两人一算，6000减去5000等于1000，老李直接给老王1000元就行。</p></li><li><p>借记：借记业务是收款行或者收款人主动向付款行或者付款人发起的扣款业务。“借”字是指资产的增加或者负债的减少，最常见的借记应用服务是借记卡，也就是储蓄卡。平时我们用储蓄卡时，不能透支，只要卡上有钱，就是资产，所以也将它叫作借记卡。比如你在银行储蓄，或者工资到账，对于个人来说，银行的资产多了，都是借记业务。</p></li><li><p>贷记：贷记业务是付款行或者付款人主动向收款行或者收款人发起的付款业务。“贷”字是指资产的减少或者负债的增加，最常见的贷记应用服务是贷记卡，也就是信用卡。平时我们用信用卡时，额度减少，负债增加了，所以信用卡也被叫作贷记卡。比如你从银行转账到别的银行，或者从企业账户代付工资到各个员工账户，对于付款行来说，银行的资产都减少了，都是贷记业务。</p></li><li><p>准贷记卡：一种中国特色的信用卡，字面意思可以理解为类信用卡、非标准信用卡，也具备透支的功能。刚引进信用卡业务时，考虑到国情，国家发行了这样一款产品，目前它正在逐步退出历史舞台。普通贷记卡（也就是信用卡）至少有以下几个特点：一是可以透支，二是透支有一定免息期，三是预存款无利息。而准贷记卡的特点为：存款有利息，透支大多数无免息。</p></li><li><p>圈存：圈起来、存进去，就是圈存。圈存是指从资产账户（如银行卡）中把一定的资产（如现金）取出来（圈起来），存入指定的账户（存进去）。常用的有交通卡充值，比如从钱包中将200元钱取出来（圈起来）存入指定的交通卡里。</p></li><li><p>收单：提供商户受理终端受理用户各类支付工具并完成资金结算的服务，比如在线支付、二维码扫码、线下刷卡。常见的工具有POS机收单、二维码扫码枪等。</p></li><li><p>收单机构：提供收单服务的组织，可以是银行也可以是第三方机构，收单机构需要获得“银行卡收单”牌照。《银行卡收单业务管理办法》对收单机构的解释是：包括从事银行卡收单业务的银行业金融机构，获得银行卡收单业务许可、为实体特约商户提供银行卡受理并完成资金结算服务的支付机构，以及获得网络支付业务许可、为网络特约商户提供银行卡受理并完成资金结算服务的支付机构。最早常称为“收单行”，因为最早的参与组织一般是银行，后来一些三方组织或者公司比如银联、杉德等也参与其中，大家逐渐称之为“收单机构”。</p></li><li><p>拒绝交易（charge back）：持卡人收到账单一定时间内，出于某种原因，向银行申请拒付账单上某笔交易的行为。拒绝交易（charge back）：持卡人收到账单一定时间内，出于某种原因，向银行申请拒付账单上某笔交易的行为。</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211116103636194.png" alt="image-20211116103636194"></p></li><li><p>调单：“调”是调取，“单”是单据。调单是一种对争议交易的处理方式，持卡人对自己的银行卡交易有疑问，进行质疑或者否认交易，联系发卡行，发卡行会对收单方发起调单，调取原始交易信息，包括卡信息、交易内容等，进而还原持卡人质疑交易的当时场景，并认定和划分责任。</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000443381.png" alt="image-20211011000443381"></p></li><li><p>掉单：受网络、系统等不确定因素的影响，支付服务方未把支付结果信息返回给下单发起方。</p></li><li><p>冲正：一笔交易在终端已经置为成功标志，但是发送到主机的账务交易包没有得到响应，即终端交易超时。这时由于不确定该笔交易是否在主机端也成功完成，为了确保用户的利益，终端重新向主机发送请求，请求取消该笔交易的流水。如果主机端已经交易成功，则回滚交易；否则不处理，然后将处理结果返回给终端。</p></li><li><p>补偿机制：交易无结果，没有明确返回响应时，通过查询、冲正、退货等措施明确交易结果，以及对明确结果的处理机制。</p></li><li><p>本代本：本行受理本行卡业务。比如从工商银行转账到工商银行，本行转账就是本代本。</p></li><li><p>本代他：本行受理他行卡业务。比如从工商银行转账到农业银行，跨行转账就是本代他。</p></li><li><p>IVR支付：IVR（Interactive Voice Response，互动式语音应答）支付是电话支付。在互联网支付出现之前，很多人选择电话支付，即根据提示输入卡号、密码信息，完成支付。</p></li><li><p>卡基支付：以卡片作为支付工具，通过各种媒介提供并验证卡信息进行支付的行为。资产存储在卡里，卡基的核心是卡号，媒介有POS机、闪付、电话支付、无磁无密等。</p></li><li><p>账基支付：以账户作为支付工具提供并验证账户信息进行支付的行为。资产存储在账户里，账基的核心是实名认证，账户可以有余额，可以绑定多张银行卡，最常见的有微信、支付宝。</p></li></ul></li></ul></li><li><p>支付通道</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li><p>基本术语：</p><ul><li>支付方式：信用卡支付、借记卡支付、网银支付、账户支付等。可以归为两类：卡基和账基。卡基是直接输入卡号、有效期等卡要素进行支付的方式，账基是以账户为基础的支付方式</li><li>支付品牌：同一种支付方式可以有多个支付品牌，比如信用卡支付可以用中国工商银行信用卡、中国农业银行信用卡，第三方支付或账户支付有微信支付、支付宝、京东等各类钱包支付。</li><li>卡bin：每一张银行卡都有一个卡号，每个卡号都含有发卡行标识代码（BankIdentification Number，BIN），也就是我们俗称的卡BIN，一般由6位数字组成。（2014年年底，国际标准组织将BIN由6位数字调整到8位数字。）具体的支付品牌，根据合作渠道、发卡组织、发卡种类等的不同会有不同的卡BIN，而一个支付通道往往会由于没有处理权限或未及时更新等，不能覆盖全部的卡BIN。</li><li>支付能力：同一张卡有多种支付能力。支付能力既包括交易类型，比如同样一张卡有消费、预授权、代扣、代付、鉴权等不同的交易能力，又包括产品特性，比如有的卡不需要CVV，不需要银行发短信验证码，可以免密或免Token进行支付，有的则不能免密。此外，支付能力也包括交易币种。</li><li>其他的能力：大小额(联行号)，限额，结算时效，风险拒付率，费率方面，网络安全性</li></ul></li><li><p>支付通道结构：</p><ul><li><p>支付方式：对自身内部多个支付产品的包装，提供给外部商户。比如说 信用卡快捷、信用卡MOTO、信用卡代扣包装给商户都是信用卡支付。</p></li><li><p>支付品牌：指具体的品牌或者三方机构。农业银行或者支付宝</p></li><li><p>支付通道：支付通道是指支付品牌背后提供支付受理能力的具体提供方，比如工行直连通道、银联通道、连连支付等。</p></li><li><p>支付产品：支付产品是指把通道根据不同特性与维度（比如渠道、功能、价格等）归类并包装成具有一定特性的商户产品，如信用卡快捷产品、信用卡MOTO产品、鉴权产品等。</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000505629.png" alt="image-20211011000505629"></p></li></ul></li><li><p>支付通道分类</p><ul><li>快捷支付与协议支付：<ul><li>快捷支付可以理解为：第一次绑卡后，得到一个签约协议号。二次不需要用户再填写四要素进行认证。不过还是需要手机号验证码的。鉴权短信可以支付公司发，也可以银行发</li><li>协议支付：一次鉴权，多次直接扣款。协议支付可以用来做代收代付。鉴权短信是银行自己发。</li></ul></li></ul></li><li><p>支付通道维度归类：</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000522245.png" alt="image-20211011000522245"></p><ul><li>按用途分类：<ul><li>出款</li><li>入款</li><li>鉴权</li></ul></li><li>按通道支持对象分类：<ul><li>对公支付</li><li>对私支付</li></ul></li><li>按通道支持形式分类：<ul><li>卡基支付</li><li>账基支付</li></ul></li><li>按支持发卡行地区分类：<ul><li>内卡通道</li><li>外卡通道<ul><li>内卡外抛：指国内发行的银行卡本应该通过国内支付通道进行受理交易和清结算，结果被误认为是外卡，抛送给了支持外卡交易的通道的现象。<ul><li>造成原因：收营员误操作；卡bin识别错误；路由规则错误；收单方和商户故意牟利。</li><li>内卡外抛不符合国家的外卡管理条例</li></ul></li></ul></li></ul></li></ul></li><li><p>支付通道接入流程：</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211116104540754.png" alt="image-20211116104540754"></p></li><li><p>内卡支付怎么接：</p><ol><li><p>确认支持的卡种：借记卡、贷记卡</p></li><li><p>确认支持的银行(卡bin)：</p></li><li><p>确认所支持的交易类型：</p><ol><li><p>消费：一般是指我们的扣款交易，狭义上常和预授权区分开来</p></li><li><p>鉴权：与交易无关，不涉及交易金额，指通过一定手段对用户身份或卡信息进行验证</p></li><li><p>预授权：预授权是指预付款，商户估算持卡人的消费金额，然后在你卡内冻结相应的金额，等你消费完成后，商户再进行正式结算，就相当于押金。常见的使用场景是酒店，酒店根据持卡人的入住时间估算消费金额，然后持卡人进行预授权，支付一定的金额（这时钱实际上并没有转给商户，只是在你卡内冻结了）。等你退房后，商户会扣除实际消费金额，剩余冻结资金将会解冻。</p></li><li><p>代扣：也叫作代收，是由用户授权、商户主动发起，对用户指定账户进行扣款的一种支付交易业务。它具有以下几个特点：支付要素少、按笔收费、没有退回功能、支持单笔实时代扣和批量代扣。</p></li><li><p>代付：由商户主动发起，从自身结算账户付款给用户资金账户的一种支付交易业务。它具有以下几个特点：支付要素少、按笔收费、没有退回或者撤销功能、支持单笔实时代付和批量代付</p></li></ol></li><li><p>关联交易有哪些：</p><ol><li>冲正：对于交易结果未知的补偿机制。用来回滚交易。和撤销退货有点类似。冲正可以对未知结果的订单进行交易回滚，而撤销和退货都只能对明确结果成功的订单进行交易回滚。</li><li>查询：进行状态查询。</li><li>撤销：</li><li>退货：</li><li>预授权关联交易：</li><li>解约/解绑：解除协议支付/快捷支付的签约</li></ol></li><li><p>是否支持预授权关联交易</p><ul><li>预授权完成：预授权交易取得的扣款转为实际全额扣款结算的处理业务。</li><li>预授权部分完成：预授权交易取得的扣款转为实际部分扣款结算的处理业务</li><li>预授权完成撤销：针对已经扣款结算的预授权金额做全额撤销，退回用户账户，相当于退款功能</li><li>预授权完成部分撤销：是指针对已经扣款结算的预授权金额，进行部分金额撤销，退回用户账户，相当于退款功能。</li><li>预授权撤销：解除预授权交易取得的扣款权利的处理业务。</li><li>预授权追加：原有预授权因为各种原因需要增加预授权金额，发起交易类型为预授权追加的处理业务。</li></ul></li><li><p>预授权自动解冻时间是多久？</p><ul><li>银行对于预授权有如下规定：一定时间没进行预授权完成，就会自动撤销，一般是30天。一些业务（如酒店业务）为了防止到期自动撤销、造成损失，就需要明确这个日期，并在这个日期之前进行预授权完成。</li></ul></li><li><p>一些其他问题。</p><ol><li>是否允许重复签约</li><li>是否允许多个用户签约同一张卡</li><li>签约后如果用户的信息发生了变动，协议号是否还有效</li><li>是否支持退款、部分退款</li><li>订单最长退货时间是多少</li><li>订单发起和到账时间分别是什么时候</li><li>退款是否要求t+1日后退款</li><li>渠道的支付要素有哪些</li><li>是否是银行发短信</li><li>通道限制的商户和用户限额限次分别是多少。单日和单月</li><li>通道每秒并发量是多少</li><li>是否有最低金额限制</li><li>日切时间和账单获取时间分别是什么时候</li><li>对账单获取的方式</li><li>结算是全额结算还是净额结算</li><li>是否有测试环境和测试账号</li><li></li></ol></li></ol></li></ul></li><li><p>跨境支付</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li><p>想要解决的问题：</p><ul><li>计价问题，汇率：查汇策略，定价策略。DDC(动态汇率转换)</li><li>业务许可问题。需要符合当地的业务许可。国际支付合规资质问题</li><li>对商家的信任度。因为存在一些赊账之类的场景。风险控制问题。在国际支付里，商户与通道、发卡行、卡组织一起，通过验证更多要素、3DS验证等方式进行联合风险控制。</li><li>货源问题。支付币种和结算币种问题。重点币种会一一对应(美元–&gt;美元，人民币–&gt;人民币)，小币种统一结算为重点币种(墨西哥–&gt;美元)</li><li>地方性的产品问题。本地化收单方案。(荷兰最为流行的是ideal，中国香港有FPS，泰国有泰国央行推出的Prompt Pay。)</li></ul></li><li><p>什么是跨境支付</p><ul><li>不同交易币种、不同结算币种、不同跨国监管主体资金转移、不同国家支付网络（如SWIFT、卡组织等）的连接。交易、清分、结算</li><li>整个全景可以分为四个阶段<ul><li>交易发起阶段：参与方有客户、汇出行和汇率转换机构。客户与汇出行之间进行的事项有资金处理和费用受理、验证客户信息（Know Your Customer，KYC）和反洗钱（Anti-Money Laundering，AML）信息提交、与汇率转换机构进行换汇，以及交易查询和争议处理。</li><li>资金转移阶段：参与方有当地清分网络、SWIFT(联行号)和中间行（或称代理行）。当地清分网络进行资金和费用的计算，SWIFT提供国际间资金处理报文传输网络，中间行为汇出与汇入行无直接关系的资金转移活动提供中间账户。</li><li>资金交付阶段：参与方有汇入行、收款人和汇率转换机构。汇入行与客户之间进行资金处理和费用受理、客户信息和反洗钱信息提交，与汇率转换机构进行换汇，包括协助客户与汇入行进行转账交易的查询和争议处理。</li><li>资金交付后阶段：参与方有各环节银行、汇率转换机构和政府监管机构。各银行与汇率转换机构向政府监管机构提供交易详细信息和报告。</li></ul></li></ul></li><li><p>跨境支付复杂性</p><ul><li>跨境支付（Cross-border Payment）是指通过一定的结算工具和支付系统对于因贸易或投资发生的资金实现两个或两个以上国家或地区之间的转移行为。跨境支付包括境外线下支付、跨境转账汇款、跨境线上支付三种场景。<ul><li>境外线下支付和跨境线上支付场景：本质上都是基于交易进行的支付行为，底层驱动是商品与服务的跨国转移和流动</li><li>跨境转账汇款场景：本质上是基于转账进行的支付行为，底层驱动是人口的跨国转移和流动</li></ul></li><li>复杂性体现在两个方面：<ol><li>复杂在跨币种的资金转移与流动：在跨境支付交易或转账的场景里，有交易币种，有结算币种，有卡本币，不同币种之间的转换需要考虑交易计价、汇兑损失及汇率方案。<ul><li>页面计价：要不要进行动态汇率转换，是选择DCC动态转换成用户卡本币还是EDC使用当地交易币种交易。</li><li>查汇：使用哪里的汇率，是中国银行汇率还是结算行汇率，查哪个国家的汇率。</li><li>计价汇率规则：是用买入价还是卖出价，是用现汇价还是现钞价，或者是中间折算价。</li><li>查询汇率频率规则：是一天一汇还是一天两汇，或者是交易实时汇率。</li><li>汇兑风险控制：要不要在查询汇率时加上上浮加成，上浮多少；要不要进行延期结汇；要不要买反向远期外汇期货。</li><li>结算时交易币种与结算币种处理：什么交易币种结算成什么结算币种，什么币种结算到哪个国家或地区的账户。</li></ul></li><li>复杂在跨地区的资金转移与流动<ul><li>不同地区对于支付处理的政策法律、处理机制、认知都不相同，需要考虑当地特殊性。</li><li>不同地区所属时区不一样。双方账单的日切时间以哪个时区的时间为准。</li><li>不同地区监管环境不同。在有些地区，支付业务准入条件包括当地支付牌照，而有些地区则不包括；各地区在风控、反洗钱方面的要求也有差异。这种种不同点就要求支付机构在开展当地业务时要熟悉当地法规，而这给外来者带来了更高的合规成本。</li><li>不同地区语言和名词定义不同。不同地区语言不同，对于业务开展来说，跨境支付对人才储备能力的要求远超国内支付。交易双方对同一事情的名词定义不同，并且往往不能单从字面理解，比如同样是预授权，换成英文就成了Capture或Delay-hours。</li><li>不同地区的交易处理机制不一样。比如有的地区是单信息流，以交易时的结果为准；有的地区是双信息流，以最终账单结果为准。</li><li>不同地区清结算体系和产业链参与方不同。需要了解每个地区产业链参与方与他们所提供的支付能力，需要耗费更多时间去熟悉当地收单方案，与更多参与方进行沟通和交流，这带来了更高的操作难度和沟通成本。</li><li>专业汇款公司中最为出名的是西联汇款。</li><li>换汇机构提供汇率查询、汇率兑换。</li><li>第三方支付公司作为参与者提供国际支付服务，其中出色的参与者有PayPal、Adyen、支付宝等。</li><li>卡组织进行交易清结算处理、发卡等工作，知名卡组织有Visa、Mastercard、JCB、银联、美国运通等。</li><li>国际协会组织中最著名的是环球同业银行金融电信协会（SWIFT），协会的SWIFT系统为银行提供标准化通信服务。</li><li>代理银行建立代理账户，为汇出行与汇入行无直接账户关系资金流动提供服务。</li><li>当地清分网络是指当地处理金融机构之间交易的服务组织，如中国的大小额系统。</li></ul></li></ol></li></ul></li><li><p>跨境支付的方式</p><ol><li>电汇：汇出行应汇款人申请，通过电子报文（早期通过电报或电话）指示国外汇入行（目的地分行或代理行）支付对应金额给收款人的结算方式。<ul><li>费率。费率由手续费和电报费构成。</li><li>时效。电汇一般会在3~5个工作日内到达。一般来说，清算模式下T+1，代理模式下T+3</li><li>金额限制。单笔金额小于5万美元，可以直接汇出；单笔金额大于5万美元，需要提供相关证明材料。</li></ul></li><li>第三方支付：<ol><li>国内：支付宝，钱海，连连支付</li><li>国外：Paypal(通过独立品牌账户进行支付), Adyen(通过聚合多个品牌实现支付)</li><li>产品：跨境付款、转账、汇款、独立站收单、增值税缴纳、国际退税、国际账户开户与收款、结合卖家信息做的供应链金融</li></ol></li></ol></li><li><p>跨境支付展业资质</p><p>国内支付机构要想进行跨境支付展业，需要具备以下资质：</p><pre><code>* 支付业务许可证：《支付业务许可证》的业务类型包括互联网支付收单、移动电话支付收单、预付卡发行与受理收单、银行卡收单、固定电话支付收单、数字电视支付等。* 外汇管理局许可证：支付机构或者大型商户要想跨境展业，必须拥有国家外汇管理局发放的，允许其进行外币交易、结售汇及相关资金收付等业务的许可证。* 当地人行许可证：跨境人民币支付业务不需要外汇管理局的批复，由各地央行分支机构发布相关文件即可* 国际机构认证及本地化资质：国际各卡组织以及一些地区均有收单认证资质要求，未获得相关资质不允许处理其交易。</code></pre></li><li><p>汇率和购结汇：</p><ul><li>汇率是一国货币兑换另一国货币的比率，亦可视为一国货币对另一国货币的价值。跨境支付中涉及交易币种、结算币种、卡本币，所有非同币种之间的交易都离不开汇率，而在这些交易过程中离不开3个环节：查汇、购汇和结汇。<ul><li>查汇：实时汇率(汇率本身是24小时不断波动的)<ul><li>买入价（Buying Rate）的方向是从银行到客户，指银行从客户手中买入外币对应的汇率价格。</li><li>卖出价（Selling Rate）的方向是从客户到银行，指客户从银行手中买入外币对应的汇率价格。</li><li>中间价（Standard Price）也叫作基准价，是银行根据国际金融市场各币种流通与交易情况制定的汇率价格，在我国一般由外汇管理局发布。</li><li>批发价也叫作大额价格，是指单笔买入或者卖出金额较大时使用的汇率。就像生活中商品的批发价更便宜一样，汇率的批发价通常也会更划算一些。</li><li>现钞价是指钞票发生实物交割，买卖外币现钞时不同币种汇率的计价价格</li><li>现汇价是指钞票并不发生实物交割，只是在银行与银行、银行与客户之间发生信息流、资金流交换，而物流交割与资金流、信息流交换不是发生在同一节点，买卖外币现汇时不同币种汇率的计价价格</li></ul></li><li>加价汇率：DCC（卡本币汇率），消费者付款时根据汇率计算出需要多少本国货币。DCC是以同业拆借利率为基准，有第三方的参与，第三方为了规避汇率波动风险或者自身增加的一些成本，采用的汇率往往会在基准之上增加一些加成。所以一般来说对消费者是不利的</li><li>锁汇：锁汇是指交易方和结算方约定汇率结算规则，一天按某个时间或者多个时间的固定汇率计算，以方便进行资金结算。比如一天一汇，约定以中国银行9点挂牌中间价进行结算，那么当天整个日切时间周期内均以此汇率结算。或者一天两汇，约定以中国银行9点和17点挂牌中间价进行结算。如果日切时间是24点，那么0点至9点，交易汇率以上一日17点挂牌中间价进行结算；9点至17点，交易汇率以当日9点挂牌中间价进行结算；17点至24点，交易汇率以当日17点挂牌中间价进行结算。</li></ul></li><li>购汇和结汇：结汇是指个人或企业，根据银行外汇牌价把外汇兑换和卖出外汇来进行结算的行为。购汇就是在国内进行购买外币，是用自己账户上的本币来换外币，相当于外汇的买卖换完之后外币就可以放在自己的账户上，或者是银行卡上，但是就不可以去提现。主要有三种方式：<ol><li>与境内银行合作：在境内银行进行购汇业务，境内银行根据资质及业务凭证等资料，兑换相应外汇，许可企业兑换完成相应外汇后，结算给境外商户</li><li>与境内外银行或境外第三方支付机构合作：</li><li>与卡组织合作</li></ol></li><li>外卡支付怎么接<ul><li>外币交易有两种常见的结算方式。<ul><li>本币结本币</li><li>外币结美元</li></ul></li><li>汇率相关操作步骤：<ul><li>查汇：商户和支付服务提供商约定好以每天几点银行公布的汇率作为当日结算汇率；商户或支付服务提供商在约定时间向银行发起查汇请求，银行返回实时汇率；查询方记录汇率并同步。</li><li>锁汇：支付服务提供商与商户锁定汇率，当天所有交易均以此汇率进行记录。</li><li>购汇：支付服务提供商将交易业务报备外汇管理局，并进行购汇。</li><li>结汇：支付服务提供商根据约定好的汇率和结算币种，汇总统计应结款项及币种，并结算给商户。</li><li>买卖远期外汇：商户或支付服务提供商向银行买进或者卖出远期外汇以对冲风险。</li></ul></li></ul></li></ul></li><li><p>常见问题汇总：</p><ul><li>支持哪些交易币种</li><li>结算币种是什么</li><li>不同币种之间的结算采取什么汇率规则，是否锁汇</li><li>预授权是否有Delay Hours或Auto Capture？有的话，时间是多久<ul><li>Delay Hours的字面意思是延迟时间，指规定多少小时后预授权交易自动转完成。</li><li>Auto Capture也一样，规定多长时间后若没有撤销，直接将预授权自动转完成。</li></ul></li><li>日切时间点</li><li>外卡通道多语言的问题</li><li>最小单位问题。有的国家只有元的概念，没有毛和分。意思是不存在小数点后两位(韩国，越南，日本)</li><li>查询补单的时候用哪个单号去查</li><li>是否支持3ds</li><li>是否支持dcc：交易发生时金额所对应的币种叫作交易币种，用户办理银行卡的账户记账币种叫作卡本币，将商品的交易币种价格转换成用户所用的银行卡卡本币价格的过程叫作动态货币转换（DCC）</li></ul></li></ul></li><li><p>路由系统</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li><p>解决思路</p><ul><li>分流和备份</li><li>采购的策略：策略优先级：策略一、策略三、策略二依次递减。通过这些策略，老王兼顾了自身和供应商的利益，维护了供应商关系，实现了自身利益的最大化。</li></ul></li><li><p>什么是支付路由</p><ul><li><p>“路由”被定义为一个交换中心呼叫另一个交换中心时，在多个可传递信息的途径中进行选择。</p></li><li><p>路由定义</p><ul><li>路由系统是支付核心系统，对商户支付页面进行管理与输出、根据商户需求及通道特性基础对交易进行处理，并在此基础上对支付中的异常情况进行支付灾备处理。</li><li>是一种以提升用户需求体验满意度、支付成功率、收益率指标和支付安全度为目的，实现效益最大化的收益管理机制</li><li>交易订单经过交易路由系统时，系统会向支付平台返回支付品牌所支持的支付通道方案</li></ul></li><li><p>路由规则发布机制</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000600771.png" alt="image-20211011000600771"></p></li><li><p>路由收益管理：</p><ul><li><p>支付成本管理：找一个收益最大化的渠道。</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000614812.png" alt="image-20211011000614812"></p></li><li><p>合作关系维护。备用渠道也要时不时的切一点量给他们</p></li><li><p>通道指定方面。比如说商户指定要用某个渠道</p></li><li><p>风险控制层面</p></li><li><p>成功率保证层面</p></li><li><p>体验度层面</p></li></ul></li><li><p>支付能力覆盖面</p><ul><li>支付方式</li><li>支付营销能力</li><li>支付产品能力</li></ul></li><li><p>支付通道健康度</p><ul><li>并发量，吞吐量</li><li>自动熔断有问题的渠道</li></ul></li></ul></li><li><p>引导路由</p><ul><li><p>支付平台或者网关系统向服务请求获得所支持支付方式及品牌展示，然后服务对这个请求做出处理，并向商户返回涵盖支付方式及品牌、营销文案、推荐支付方式、常用支付习惯等信息的一揽子方案，这个服务被称为引导路由。</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000627799.png" alt="image-20211011000627799"></p></li><li><p>先配置品牌列表，再在引导方案中设置（方案中包含品牌列表分流配置），最后在引导规则中配置规则（规则中包含配置使用哪一套方案）</p></li></ul></li><li><p>交易路由：支付平台或者网关系统向服务请求可用通道，服务根据通道信息配置及规则优先级进行决策，向支付平台或者网关返回最优支付通道方案，这个服务被称为交易路由。</p><ul><li>交易路由整体思想：<ul><li>维度一：按路由算法优先级(风控维度、用户体验维度、通道自身特性维度、每天保量维度)<ul><li>通道信息</li><li>基础路由算法：基础路由算法是指根据配置规则匹配可用逻辑通道。配置的规则是根据同一物理通道不同属性的具体内容进行配置，如不同支付品牌、交易类型、交易金额、限额、商户、计费方式和费率等。</li><li>分组路由算法：分组路由算法是指有多个物理通道或者逻辑通道可用，根据分组规则中保量金额或者权重比例进行路由计算，分配交易至目标通道。渠道组的概念(一个渠道组里面，可能存在一个主渠道一个备份渠道)。注意，如果有多个通道可用，且既存在组内通道也存在组外通道，那么路由服务需要再按照基础路由将筛选出的组内最优通道与组外通道进行成本比较，从而得出最终的最优通道。</li><li>短路路由算法：“短路”顾名思义是最短的路。短路路由算法是指有多个物理通道或逻辑通道可用时，匹配规则优先级最高的通道，不看费率，不看分组，忽略其他规则。短路路由中的匹配条件有行业、商户号、交易类型、支付品牌、交易金额、卡号段、有效时间段等。注意，短路路由中的规则是优先原则，如果短路中的通道不可用，还是会按照基础路由和分组路由规则分配交易量。<ul><li>情形一：某通道不占优势，但是贴补营销费用后，用户或平台的整体体验或者收益反而最高。</li><li>情形二：某新通道上线，通道质量未知，所以不能全量放开，需要先选择某个行业下的具体小商户进行测试。</li><li>情形三：某通道不占优势，但却是重点战略合作客户和流量场景，需要在其流量场景里优先使用它的通道。</li></ul></li><li>风险路由算法：而我们认为其中支付安全度是第一位的，因为几笔欺诈交易就可能击垮一家创业公司。</li></ul></li><li>维度二：按路由调用节点<ul><li>事前路由：事前路由是用户发起支付，支付平台为了向用户展示支付方式、银行、输入要素而向路由系统发起请求的过程。</li><li>事中路由：事中路由是指在支付交易过程中，用户输入卡号、护照等支付要素，支付平台根据输入要素进行判定，若事前路由下发的最优通道不支持此交易（如不支持此卡BIN或者证件类型），会再次请求路由服务，获得支持此要素的支付通道的处理机制。</li><li>事后路由：事后路由是指在支付交易过程中，识别通道方返回的交易码，将一些因为通道方原因（如通道超限）造成的交易失败进行重试以挽回交易。</li></ul></li></ul></li></ul></li></ul></li><li><p>重试服务</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li>重试服务产生的原因<ul><li>通道限额问题<ul><li>通道服务异常问题</li><li>通道使用率问题</li></ul></li></ul></li><li>重试服务体系<ul><li>重试服务的运转与应用核心在于两部分：重试服务自身的重试规则和路由系统针对重试服务的处理机制。</li></ul></li><li>重试服务设计<ul><li>重试服务由两部分组成：重试规则建立和重试规则匹配。重试规则匹配的基础就是重试规则的建立，服务根据建立的规则内容进行匹配。匹配成功，参与重试；否则不参与。</li><li>重试服务原则：银行卡类交易、鉴权类交易、风险类订单交易、人工置失败交易、出款类交易</li></ul></li><li>路由-重试服务设计<ul><li>准备数据和清理数据</li><li>计算最优通道</li><li>返回计算结果</li></ul></li></ul></li><li><p>BIN服务</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li><p>卡bin的作用：支付中通过BIN服务判定通道支持能力，把交易请求送到支持的通道，从而提高支付成功率。()</p></li><li><p>卡BIN(发卡行标识码 )服务是一种通过对BIN进行管理，并提供外部查询用于识别和判断卡所属银行、卡组织、卡级别的支持服务。</p></li><li><p>可以通过卡bin来识别具体的发卡行、是借记卡还是贷记卡、是工资卡还是消费卡、是普通卡还是白金卡、是和哪家公司的联名卡、是哪个卡组织的卡</p></li><li><p>卡号的结构。(最后一位校验码可以用算法校验，应用Luhn算法进行验证)</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000643772.png" alt="image-20211011000643772"></p></li><li><p>国际六大卡组织：中国银联股份有限公司（UnionPay）、万事达卡国际卡组织（Mastercard）、维萨国际卡组织（Visa）、美国运通国际股份有限公司（AE）、日本国际信用卡公司（JCB）和大莱信用卡有限公司（Diners Club）</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000658643.png" alt="image-20211011000658643"></p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000709613.png" alt="image-20211011000709613"></p></li><li><p>卡BIN表的设计</p><ul><li>就像支付里支付品牌对应的支付通道一样，招商银行信用卡会存在不同的支付通道，这些支付通道的支付能力可能不一样，也就是支持的卡种不一样，支持的BIN段不一样。因此在这种多供应商、多品种的情况下，还需要划出编号来区分不同的供应商。</li><li>卡组织提供该组织下最为完整的各发卡行BIN信息。</li><li>发卡行提供该银行下最为完整的各卡种BIN信息。</li><li>通道服务商提供该通道支付能力以内的BIN信息。</li><li>根据以上所述，在进行BIN服务设计时，有两种方案：一种与通道无关，用于相对简单场景，比如单一通道场景；一种与通道有关，用来精确匹配，尽可能保证通道可用性。<ul><li>方案一：BIN不涉及通道方案，逻辑如下：<ol><li>判断该卡是否支持时，按照设计会判断BIN是否支持，经过校验，BIN服务支持该BIN；</li><li>判断最优通道，因为招行直连通道费率（0.1%）低于银联通道（0.3%），在没有其他算法参与的情况下，招行直连通道是最优通道。</li></ol></li><li>方案二：BIN涉及通道方案<ol><li>判断该卡是否支持时，按照设计会判断BIN是否支持，经过校验，BIN服务支持该BIN，且支持的通道只有一个，为银联通道。</li><li>判断最优通道，因为只有一个通道可用，所以最优通道就是银联通道。</li></ol></li><li>以上两个方案及其应用很像能量守恒定律，在做产品设计时自己费力一点，用户就会省心一点。做产品这样，做支付也是这样。</li></ul></li></ul></li><li><p>卡号的校验算法</p><ul><li>银行卡验证Luhn算法的规则如下：<ol><li>从卡号最后一位数字开始，逆向将奇数位相加</li><li>从卡号最后一位数字开始，逆向将偶数位数字先乘以2（如果乘积为两位数，则将其减去9），再求和</li><li>将奇数位总和加上偶数位总和，结果应该可以被10整除</li></ol></li></ul></li><li><p>卡bin的作用</p><ul><li>通过BIN针对卡等级（如白金卡、金卡用户）进行支付营销，提升支付收益；针对不同支付通道支持的BIN范围进行匹配交易，提升支付成功率。</li></ul></li></ul></li><li><p>清结算</p><p>本章主要介绍支付业务的构成、支付历史演进、支付架构与常见的支付基础名词，帮助读者通过了解支付逻辑、概念到架构功能模块，建立对支付的整体认知。</p><ul><li><p>清结算概述：</p><ul><li>清分是根据交易的终态结果，对商户、用户和支付通道进行手续费计算、账单和到账款项金额的核对。结算是根据清分的数据，用与商户、用户、支付通道等约定的结算方式、结算周期进行资金的划拨。清分与结算合称清结算。</li></ul></li><li><p>双边关系：</p><ul><li>进件环节分为两个部分(进件渠道我理解是做认证，开权限)：<ul><li>商户入驻支付平台：商户按照支付或者业务平台的要求提交进件信息，支付平台为商户开通秘钥、权限和支付产品等权限。</li><li>支付平台入驻支付通道：支付平台按照接入的各支付通道要求提交进件信息，支付通道为支付平台开通秘钥、权限和支付产品等权限。</li></ul></li><li>交易环节：<ul><li>商户向支付平台发起交易：商户按照支付平台签约信息，上送报文（包括支付平台为自己分配的密钥、开通的支付业务范围）给支付平台；支付平台返回给商户对应的支付结果和返回码，这个返回码是基于支付通道的原始返回码进行映射后转译的。</li><li>支付平台向支付通道发起交易：支付平台收到商户请求，按照自己的路由规则，计算出最优通道，上送报文（包括支付通道为自己分配的密钥、开通的支付业务能力）给支付通道；支付通道返回给支付平台对应的支付结果和返回码。</li></ul></li><li>清分环节：<ul><li>商户和支付平台对账：支付平台将商户的所有交易订单生成账单并推送给商户；商户按照支付平台推送的账单进行对账，如果有对不平的账单就联系支付平台进行差账处理</li><li>支付平台和支付通道对账：支付通道将支付平台的所有交易订单生成账单推送给支付平台；支付平台按照支付通道推送的账单进行对账，如果有对不平的账单联系支付通道进行差账处理。</li></ul></li><li>结算环节<ul><li>商户和支付平台结算：支付平台按照与商户约定的账期、费率、结算方式进行商户款项结算。</li><li>支付平台和支付通道结算：支付通道按照与支付平台约定的账期、费率、结算方式进行支付平台款项结算。</li></ul></li></ul></li><li><p>模块职能</p><ul><li>在清分的过程中，需要确保账务信息数据准确、账务对平，能够为后续债权债务提供数据支撑</li><li>在结算的过程中，需要确保债权债务信息完整、状态符合流程，确保结算资金的可用性，记录并通知结算结果等。</li></ul></li><li><p>计费服务(针对：上游的通道和下游的商户，有两套配置和计算)</p><ul><li>配置算费<ul><li>一个方向是把支付产品拆解得足够细，用支付产品来定义手续费： 比如可以将信用卡拆解为信用卡快捷、信用卡非快捷、信用卡不区分、信用卡3DS等。在这个方向上，可以按照业务需要无限枚举支付产品</li><li>另一个方向是支付产品颗粒度粗，用支付产品+其他字段属性代表一条唯一的规则：比如信用卡3DS产品可以用信用卡支付产品+是否3DS来表示</li></ul></li><li>查询算费</li><li>计费</li></ul></li><li><p>账单服务</p><ul><li>落地交易单数据<ol><li>商户向支付平台发起交易。</li><li>支付平台生成交易单或流水号并提供给商户</li><li>支付平台获取最优通道。</li><li>支付平台将交易上送给通道进行交易。</li><li>支付平台将支付结果返回给商户，将订单推送至账单服务。</li></ol></li><li>获取支付通道对账单<ul><li>明确对账文件规范和要求<ul><li>对账文件的命名规范与格式</li><li>对账文件的时间</li></ul></li><li>下载对账文件</li><li>解析对账文件</li></ul></li><li>生成与推送商户对账单<ul><li>生成商户对账单<ul><li>对账单日切时间与时区。</li><li>不同交易币种的对账单规则</li><li>不同结算币种的对账单规则</li><li>不同交易类型的对账单规则</li><li>对账单同一天发生正反交易的规则</li><li>一份对账单的最大文件容量与笔数</li></ul></li><li>推送商户对账单</li></ul></li><li>生成通道对账单。<ul><li>落地支付平台交易数据。</li><li>获取支付通道计费成本与落地支付通道交易数据。</li><li>生成支付通道对账文件。</li><li>更新支付通道对账单对账状态。</li></ul></li></ul></li><li><p>对账服务及会计与结算</p><ul><li><p>对账服务(对账是轧账和平账的过程)</p><ul><li>对账分为：单向对账和双向对账</li><li>从另一个角度，对账也分为：账账对账、账证对账和账实对账</li><li>对账的具体规则<ul><li>对账基准：以哪方的账单为准：以对方的账单为准，或者以自己的账单为准</li><li>对账内容：对账对的是哪些字段。</li><li>对账时间：日切时间临界点的交易订单怎么处理(如果存在一些在途资金之类的场景，需要第三天继续对账。也叫做连续对账、滚动对账)</li><li>对账结果：对账会出现的结果及其对应的处理方式<ul><li>对平</li><li>长款：支付通道有订单，支付平台侧无</li><li>短款：支付通道无订单，支付平台侧有订单。</li><li>金额不一致</li></ul></li></ul></li></ul></li><li><p>会计与结算</p><ul><li><p>会计</p><ul><li><p>记录会计科目：会计科目按照业务性质可分为资产类科目、负债类科目、资产负债共同类科目、所有者权益类科目、成本类科目和损益类科目这六大类。</p><ul><li><p>资产类</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000726397.png" alt="image-20211011000726397"></p></li><li><p>负债类</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000746666.png" alt="image-20211011000746666"></p></li><li><p>资产负债共同类科目</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000805746.png" alt="image-20211011000805746"></p></li><li><p>所有者权益类科目</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000820260.png" alt="image-20211011000820260"></p></li><li><p>成本类科目</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000833590.png" alt="image-20211011000833590"></p></li><li><p>损益类科目</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000848211.png" alt="image-20211011000848211"></p></li></ul></li></ul></li><li><p>生成会计账户与科目历史余额表：会计余额表是会计中用的基本做账表格，用于反映期初期末的资产变化，其中包括期初余额、发生额、期末余额等内容。</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000903534.png" alt="image-20211011000903534"></p><p>商户名下首先是账户，按照业务分为若干个账户，其次账户资金是由不同的交易组成的，在会计中，这些不同交易代表着不同科目。所以余额表根据需要有了账户余额表、一级科目余额表、二级科目余额表。会计服务支持生成历史余额表，可以是账户维度也可以是科目维度，可以是定期自动生成也可以是根据使用方需要生成。</p></li><li><p>会计科目试算平衡(这个叫做复式记账)：会计中讲究“有借必有贷，借贷必相等”。会计试算平衡是指根据记账规则与明细计算科目借贷双方金额是否相等，计算出来的结果应该恒等，否则便是记录有问题。但总体上说，会计偏向于财务，财务人员约定每一个业务行为的会计科目分录，当支付交易中触发了该业务行为，就会自动进行该业务的会计记账。</p></li></ul></li><li><p>结算：</p><ul><li>清结算是清分和结算的过程。前面几个服务介绍的都是清分，完成资金与账单的计算与核对；后面就是结算，是进行资产转移与交割的过程。</li><li>结算的规则：<ul><li>结算节点：什么时间点结算</li><li>结算方式：支持汇出、汇入哪些支付方式</li><li>结算金额：全额结算还是净额结算</li><li>结算币种：外币交易怎么结算</li></ul></li></ul></li></ul></li></ul></li><li><p>模块作用</p><p><img src="https://gitee.com/metabolism/blogimage/raw/master/img/image-20211011000915561.png" alt="image-20211011000915561"></p></li></ol><ul><li><p>支付核心模块:</p><p>支付核心模块用来接收支付交易请求，处理支付交易，比如收款、出款、鉴权等场景中的消费、预授权、退货等不同类型的支付交易。支付核心模块会调用路由系统，根据路由决策情况将交易上送给支付通道，根据支付通道返回结果更新支付通道流水状态和业务订单状态，同时将业务订单和支付通道流水号推送至清结算系统，进行后续账单生成、清分与结算处理。</p></li><li><p>账单模块:</p><p>账单模块主要有下面这4个职能。</p><p>1）落地交易单数据。商户发起交易，当支付状态流转至终态时（无论成功还是失败），系统会将终态订单推送至账单模块，账单模块记录下该支付数据（涵盖商户、交易单、通道单、交易金额、支付方式、交易类型、支付产品等数据）。</p><p>2）获取支付通道对账单。根据与支付通道的约定，支付平台通过各种形式获取支付通道对账单，如支付通道的邮件推送、FTP下载与推送，自己通过后台下载等。</p><p>3）生成并推送商户对账单。根据与商户的约定，通过各种形式让商户获取商户对账单，如邮件推送、FTP下载与推送、让商户自己通过后台下载等。</p><p>4）生成通道对账单。对账单包括商户对账单和支付通道对账单。账单服务分别对商户维度的业务订单和支付通道维度的通道流水进一步处理，调用计费模块获取商户和支付通道手续费，生成对账单，并将账单按照分类推送：将商户对账单推送至商户；将支付通道对账单推送至对账模块，进行通道交易对账和通道资金对账。</p></li><li><p>计费模块(算费)</p><p>计费模块主要负责商户手续费和通道成本的配置（可由商户合同系统或者路由配置推送至计费模块，生成数据），以及计算并返回费用结算方式、币种、金额及结算日期</p></li><li><p>对账差错模块</p><p>对账既包括自身支付平台与上游支付通道（如第三方支付公司或银行）对账，也包括自身各个服务间（比如账单与会计）对账，其作用是保证自身各个应用之间记录一致。我们将前者叫作单向对账，将后者叫作双向对账。</p><p>与上游支付通道的对账过程分为交易流水对账和到账凭证、到账实际资金的对账。我们把前者叫作账账对账，将后者叫作账证对账、账实对账。</p><p>对账用来将账单核算对平，对于不能核对匹配的交易进行补单或者退款等差账处理，最终实现账单对平。我们将这个过程称为轧账和平账。</p></li><li><p>账户模块</p><p>账户模块用来进行资产的账户分类，并根据交易和对账情况进行账户的记账及资金信息流变动。常见的账户有余额账户、冻结账户、礼品卡账户等。</p></li><li><p>会计模块</p><p>会计模块根据账户模块的请求进行会计的日间记账，并进行日终处理和财务并账。本书中不会详细阐述会计模块，原因有二：其一，会计借贷及科目分录需要有专业财务人员参与，在此不作为产品经理必备技能；其二，会计模块在清结算中并非必需模块，很多公司用流水账单汇总代替公司对账，并不采用会计模块。</p></li><li><p>财务模块</p><p>财务模块根据对账情况进行账证对账（核实对账结果与银行打款凭证是否匹配）、账实对账（核实对账结果与银行实际打款是否匹配），以及按照结算方式和账期进行结算处理。</p></li></ul><ol start="9"><li><p>模块之间的交互</p><ul><li>支付订单推送。支付核心模块将有效的支付订单（包括支付订单、退款订单、风险订单等）推送至账单模块。注意，这里说的是“有效”而不是“成功”，因为在有些类型的交易中（如外卡交易），有的交易不管成不成功都要支付风控手续费，也就是说即使支付失败，也是要记录并且收费的。</li><li>支付通道流水推送。支付核心模块将成功和失败的支付通道流水（包括支付、退款等）推送至账单模块。</li><li>请求商户计费。账单模块根据支付订单交易信息，请求计费模块计算商户手续</li><li>返回商户计费结果。计费模块返回商户手续费的计算结果、收费模式及收费日期。</li><li>请求通道成本计算。账单模块根据通道流水请求计费模块计算通道成本。</li><li>返回通道成本。计费模块返回通道成本的计算结果、收费模式及收费日期。</li><li>推送账单数据并记账。账单模块完成商户账单计费，生成商户账单后，将账单推送至商户账户并请求账户模块记账，变动资金信息流。</li><li>请求会计记账。账户模块记账成功后均请求会计模块进行会计记账。</li><li>支付通道流水对账。账单模块在支付通道流水成本计算完成后，将其推送至对账差错模块进行交易对账：解析支付通道订单格式，进行两边账单的账账对账；针对对不平的账单进行差账处理；根据对账结果推送给财务模块或者会计模块。</li><li>请求账户记账。对账差错模块将对账结果推送至账户进行记账。</li><li>对账差错处理。针对对账的长短款，对账差错模块请求支付核心模块进行补单和退款处理。</li><li>财务并账。每日将科目发生额和余额进行映射并自动推送到财务系统，每月进行核对。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《支付方法论》王伟，读后感&amp;amp;摘抄&lt;/p&gt;</summary>
    
    
    
    <category term="文章摘抄" scheme="https://morningbells.github.io/categories/%E6%96%87%E7%AB%A0%E6%91%98%E6%8A%84/"/>
    
    
    <category term="支付系统" scheme="https://morningbells.github.io/tags/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
